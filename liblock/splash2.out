diff -u -p a/codes/apps/barnes/stdinc.h b/codes/apps/barnes/stdinc.h
--- a/codes/apps/barnes/stdinc.h
+++ b/codes/apps/barnes/stdinc.h
@@ -25,6 +25,10 @@
 #include <math.h>
 #include <stdio.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <string.h>
 #include <time.h>
 #include <sys/times.h>
diff -u -p a/codes/apps/barnes/code_io.c b/codes/apps/barnes/code_io.c
--- a/codes/apps/barnes/code_io.c
+++ b/codes/apps/barnes/code_io.c
@@ -20,9 +20,17 @@
  */
 
 #include <pthread.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <sys/time.h>
 #include <unistd.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <malloc.h>
 extern pthread_t PThreadTable[];
 
@@ -92,6 +100,36 @@ void initoutput()
 	  nbody, dtime, eps, tol, dtout, tstop, fcells, NPROC);
 }
 
+void * function6(void *ctx4);
+void *function6(void *ctx4) {
+   {
+      vector tempv2;
+      vector tempv1;
+      long k;
+      long ProcessId=(long)(uintptr_t)ctx4;
+      {
+         Global->n2bcalc += Local[ProcessId].myn2bcalc;
+         Global->nbccalc += Local[ProcessId].mynbccalc;
+         Global->selfint += Local[ProcessId].myselfint;
+         ADDM(Global->keten, Global->keten, Local[ProcessId].myketen);
+         ADDM(Global->peten, Global->peten, Local[ProcessId].mypeten);
+         for (k = 0;k < 3;k++)
+            Global->etot[k] += Local[ProcessId].myetot[k];
+         ADDV(Global->amvec, Global->amvec, Local[ProcessId].myamvec);
+         MULVS(tempv1, Global->cmphase[0], Global->mtot);
+         MULVS(tempv2, Local[ProcessId].mycmphase[0], Local[ProcessId].mymtot);
+         ADDV(tempv1, tempv1, tempv2);
+         DIVVS(Global->cmphase[0], tempv1, Global->mtot + Local[ProcessId].mymtot);
+         MULVS(tempv1, Global->cmphase[1], Global->mtot);
+         MULVS(tempv2, Local[ProcessId].mycmphase[1], Local[ProcessId].mymtot);
+         ADDV(tempv1, tempv1, tempv2);
+         DIVVS(Global->cmphase[1], tempv1, Global->mtot + Local[ProcessId].mymtot);
+         Global->mtot += Local[ProcessId].mymtot;
+      }
+      return NULL;
+   }
+}
+
 /*
  * STOPOUTPUT: finish up after a run.
  */
@@ -113,26 +151,9 @@ void output(long ProcessId)
    diagnostics(ProcessId);
 
    if (Local[ProcessId].mymtot!=0) {
-      {pthread_mutex_lock(&(Global->CountLock));};
-      Global->n2bcalc += Local[ProcessId].myn2bcalc;
-      Global->nbccalc += Local[ProcessId].mynbccalc;
-      Global->selfint += Local[ProcessId].myselfint;
-      ADDM(Global->keten, Global-> keten, Local[ProcessId].myketen);
-      ADDM(Global->peten, Global-> peten, Local[ProcessId].mypeten);
-      for (k=0;k<3;k++) Global->etot[k] +=  Local[ProcessId].myetot[k];
-      ADDV(Global->amvec, Global-> amvec, Local[ProcessId].myamvec);
-
-      MULVS(tempv1, Global->cmphase[0],Global->mtot);
-      MULVS(tempv2, Local[ProcessId].mycmphase[0], Local[ProcessId].mymtot);
-      ADDV(tempv1, tempv1, tempv2);
-      DIVVS(Global->cmphase[0], tempv1, Global->mtot+Local[ProcessId].mymtot);
-
-      MULVS(tempv1, Global->cmphase[1],Global->mtot);
-      MULVS(tempv2, Local[ProcessId].mycmphase[1], Local[ProcessId].mymtot);
-      ADDV(tempv1, tempv1, tempv2);
-      DIVVS(Global->cmphase[1], tempv1, Global->mtot+Local[ProcessId].mymtot);
-      Global->mtot +=Local[ProcessId].mymtot;
-      {pthread_mutex_unlock(&(Global->CountLock));};
+      {
+      
+      liblock_execute_operation(&(Global->CountLock), (void *)(uintptr_t)(ProcessId), &function6); }
    }
 
    {
diff -u -p a/codes/apps/barnes/load.c b/codes/apps/barnes/load.c
--- a/codes/apps/barnes/load.c
+++ b/codes/apps/barnes/load.c
@@ -17,9 +17,17 @@
 
 
 #include <pthread.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <sys/time.h>
 #include <unistd.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <malloc.h>
 extern pthread_t PThreadTable[];
 
@@ -27,6 +35,20 @@ extern pthread_t PThreadTable[];
 
 #include "stdinc.h"
 
+union instance12 {struct input10{bodyptr p;long ProcessId;} input10;};
+void * function13(void *ctx11);
+void *function13(void *ctx11) {
+   {
+      struct input10 *incontext8=&(((union instance12 *)ctx11)->input10);
+      bodyptr p=incontext8->p;
+      long ProcessId=incontext8->ProcessId;
+      {
+         fprintf(stderr, "Process %ld found body %ld to have zero mass\n", ProcessId, (long)p);
+      }
+      return NULL;
+   }
+}
+
 /*
  * MAKETREE: initialize tree structure for hack force calculation.
  */
@@ -50,10 +72,15 @@ void maketree(long ProcessId)
 				 ProcessId);
       }
       else {
-	 {pthread_mutex_lock(&(Global->io_lock));};
-	 fprintf(stderr, "Process %ld found body %ld to have zero mass\n",
-		 ProcessId, (long) p);
-	 {pthread_mutex_unlock(&(Global->io_lock));};
+	 { union instance12 instance12 = {
+	    {
+   	    p,
+      	 ProcessId,
+   	 },
+	 };
+	 
+	 liblock_execute_operation(&(Global->io_lock), (void *)(uintptr_t)(&instance12),
+                                   &function13); }
       }
    }
    {
@@ -79,7 +106,7 @@ cellptr InitCell(cellptr parent, long Pr
       Level(c) = Level(parent) >> 1;
    Parent(c) = (nodeptr) parent;
    ChildNum(c) = 0;
-   return (c);
+   return( (c));
 }
 
 leafptr InitLeaf(cellptr parent, long ProcessId)
@@ -96,7 +123,7 @@ leafptr InitLeaf(cellptr parent, long Pr
       Level(l) = Level(parent) >> 1;
    Parent(l) = (nodeptr) parent;
    ChildNum(l) = 0;
-   return (l);
+   return( (l));
 }
 
 void printtree(nodeptr n)
@@ -163,6 +190,67 @@ void printtree(nodeptr n)
    fflush(stdout);
 }
 
+union instance26 {struct input24{volatile nodeptr mynode;volatile nodeptr *volatile qptr;bodyptr p;long flag;long ProcessId;long l;} input24;};
+union instance19 {struct input17{volatile nodeptr mynode;volatile nodeptr *volatile qptr;bodyptr p;long flag;long kidIndex;long l;long ProcessId;} input17;};
+void * function27(void *ctx25);
+void *function27(void *ctx25) {
+   {
+      struct input24 *incontext22=&(((union instance26 *)ctx25)->input24);
+      leafptr le;
+      volatile nodeptr mynode=incontext22->mynode;
+      volatile nodeptr *volatile qptr=incontext22->qptr;
+      bodyptr p=incontext22->p;
+      long flag=incontext22->flag;
+      long ProcessId=incontext22->ProcessId;
+      long l=incontext22->l;
+      flag = flag;
+      {
+         if (Type(*qptr) == LEAF) {
+            le = (leafptr)*qptr;
+            if (le->num_bodies == MAX_BODIES_PER_LEAF) {
+               *qptr = (nodeptr)SubdivideLeaf(le, (cellptr)mynode, l, ProcessId);
+            }else {
+               Parent(p) = (nodeptr)le;
+               Level(p) = l;
+               ChildNum(p) = le->num_bodies;
+               Bodyp(le)[le->num_bodies++] = p;
+               flag = FALSE;
+            }
+         }
+      }
+      return (void *)(uintptr_t)flag;
+   }
+}
+
+void * function20(void *ctx18);
+void *function20(void *ctx18) {
+   {
+      struct input17 *incontext15=&(((union instance19 *)ctx18)->input17);
+      leafptr le;
+      volatile nodeptr mynode=incontext15->mynode;
+      volatile nodeptr *volatile qptr=incontext15->qptr;
+      bodyptr p=incontext15->p;
+      long flag=incontext15->flag;
+      long kidIndex=incontext15->kidIndex;
+      long l=incontext15->l;
+      long ProcessId=incontext15->ProcessId;
+      flag = flag;
+      {
+         if (*qptr == NULL) {
+            le = InitLeaf((cellptr)mynode, ProcessId);
+            Parent(p) = (nodeptr)le;
+            Level(p) = l;
+            ChildNum(p) = le->num_bodies;
+            ChildNum(le) = kidIndex;
+            Bodyp(le)[le->num_bodies++] = p;
+            *qptr = (nodeptr)le;
+            flag = FALSE;
+         }
+      }
+      return (void *)(uintptr_t)flag;
+   }
+}
+
 /*
  * LOADTREE: descend tree and insert particle.
  */
@@ -226,39 +314,39 @@ nodeptr loadtree(bodyptr p, cellptr root
       }
       if (*qptr == NULL) {
 	 /* lock the parent cell */
-	 {pthread_mutex_lock(&CellLock->CL[((cellptr) mynode)->seqnum % MAXLOCK]);};
-	 if (*qptr == NULL) {
-	    le = InitLeaf((cellptr) mynode, ProcessId);
-	    Parent(p) = (nodeptr) le;
-	    Level(p) = l;
-	    ChildNum(p) = le->num_bodies;
-	    ChildNum(le) = kidIndex;
-	    Bodyp(le)[le->num_bodies++] = p;
-	    *qptr = (nodeptr) le;
-	    flag = FALSE;
+	 { union instance19 instance19 = {
+	    {
+   	    mynode,
+      	 qptr,
+      	 p,
+      	 flag,
+      	 kidIndex,
+      	 l,
+      	 ProcessId,
+   	 },
+	 };
+	 
+	 flag =(long)(uintptr_t)(liblock_execute_operation(&CellLock->CL[((cellptr)mynode)->seqnum % MAXLOCK],
+                                   (void *)(uintptr_t)(&instance19), &function20));
 	 }
-	 {pthread_mutex_unlock(&CellLock->CL[((cellptr) mynode)->seqnum % MAXLOCK]);};
 	 /* unlock the parent cell */
       }
       if (flag && *qptr && (Type(*qptr) == LEAF)) {
 	 /*   reached a "leaf"?      */
-	 {pthread_mutex_lock(&CellLock->CL[((cellptr) mynode)->seqnum % MAXLOCK]);};
-	 /* lock the parent cell */
-	 if (Type(*qptr) == LEAF) {             /* still a "leaf"?      */
-	    le = (leafptr) *qptr;
-	    if (le->num_bodies == MAX_BODIES_PER_LEAF) {
-	       *qptr = (nodeptr) SubdivideLeaf(le, (cellptr) mynode, l,
-						  ProcessId);
-	    }
-	    else {
-	       Parent(p) = (nodeptr) le;
-	       Level(p) = l;
-	       ChildNum(p) = le->num_bodies;
-	       Bodyp(le)[le->num_bodies++] = p;
-	       flag = FALSE;
-	    }
+	 { union instance26 instance26 = {
+	    {
+   	    mynode,
+      	 qptr,
+      	 p,
+      	 flag,
+      	 ProcessId,
+      	 l,
+   	 },
+	 };
+	 
+	 flag =(long)(uintptr_t)(liblock_execute_operation(&CellLock->CL[((cellptr)mynode)->seqnum % MAXLOCK],
+                                   (void *)(uintptr_t)(&instance26), &function27));
 	 }
-	 {pthread_mutex_unlock(&CellLock->CL[((cellptr) mynode)->seqnum % MAXLOCK]);};
 	 /* unlock the node           */
       }
       if (flag) {
@@ -269,7 +357,7 @@ nodeptr loadtree(bodyptr p, cellptr root
       }
    }
    SETV(Local[ProcessId].Root_Coords, xp);
-   return Parent((leafptr) *qptr);
+   return( Parent((leafptr) *qptr));
 }
 
 
@@ -294,7 +382,7 @@ bool intcoord(long xp[NDIM], vector rp)
 	 inb = FALSE;
       }
    }
-   return (inb);
+   return( (inb));
 }
 
 /*
@@ -322,7 +410,7 @@ long subindex(long x[NDIM], long l)
       else yes = FALSE;
    }
 
-   return (i);
+   return( (i));
 }
 
 
@@ -470,7 +558,7 @@ cellptr SubdivideLeaf(leafptr le, cellpt
       Level(p) = l >> 1;
       Bodyp(le)[le->num_bodies++] = p;
    }
-   return c;
+   return( c);
 }
 
 /*
@@ -496,7 +584,7 @@ cellptr makecell(long ProcessId)
       Subp(c)[i] = NULL;
    }
    Local[ProcessId].mycelltab[Local[ProcessId].myncell++] = c;
-   return (c);
+   return( (c));
 }
 
 /*
@@ -523,7 +611,7 @@ leafptr makeleaf(long ProcessId)
       Bodyp(le)[i] = NULL;
    }
    Local[ProcessId].myleaftab[Local[ProcessId].mynleaf++] = le;
-   return (le);
+   return( (le));
 }
 
 
diff -u -p a/codes/apps/barnes/code.h b/codes/apps/barnes/code.h
--- a/codes/apps/barnes/code.h
+++ b/codes/apps/barnes/code.h
@@ -49,7 +49,7 @@ global long maxmyleaf;		/* max num. of l
 global bodyptr bodytab; 	/* array size is exactly nbody bodies */
 
 global struct CellLockType {
-    pthread_mutex_t CL[MAXLOCK];        /* locks on the cells*/
+    liblock_lock_t CL[MAXLOCK];        /* locks on the cells*/
 } *CellLock;
 
 struct GlobalMemory  {	/* all this info is for the whole system */
@@ -70,10 +70,10 @@ struct GlobalMemory  {	/* all this info 
     
 pthread_barrier_t	(Barrier);
    /* barrier at the beginning of stepsystem  */
-    pthread_mutex_t CountLock; /* Lock on the shared variables            */
-    pthread_mutex_t NcellLock; /* Lock on the counter of array of cells for loadtree */
-    pthread_mutex_t NleafLock;/* Lock on the counter of array of leaves for loadtree */
-    pthread_mutex_t io_lock;
+    liblock_lock_t CountLock; /* Lock on the shared variables            */
+    liblock_lock_t NcellLock; /* Lock on the counter of array of cells for loadtree */
+    liblock_lock_t NleafLock;/* Lock on the counter of array of leaves for loadtree */
+    liblock_lock_t io_lock;
     unsigned long createstart,createend,computestart,computeend;
     unsigned long trackstart, trackend, tracktime;
     unsigned long partitionstart, partitionend, partitiontime;
diff -u -p a/codes/apps/barnes/util.c b/codes/apps/barnes/util.c
--- a/codes/apps/barnes/util.c
+++ b/codes/apps/barnes/util.c
@@ -17,9 +17,17 @@
 
 
 #include <pthread.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <sys/time.h>
 #include <unistd.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <malloc.h>
 extern pthread_t PThreadTable[];
 
diff -u -p a/codes/apps/barnes/grav.c b/codes/apps/barnes/grav.c
--- a/codes/apps/barnes/grav.c
+++ b/codes/apps/barnes/grav.c
@@ -21,9 +21,17 @@
 
 
 #include <pthread.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <sys/time.h>
 #include <unistd.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <malloc.h>
 extern pthread_t PThreadTable[];
 
diff -u -p a/codes/apps/barnes/getparam.c b/codes/apps/barnes/getparam.c
--- a/codes/apps/barnes/getparam.c
+++ b/codes/apps/barnes/getparam.c
@@ -20,9 +20,17 @@
  */
 
 #include <pthread.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <sys/time.h>
 #include <unistd.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <malloc.h>
 extern pthread_t PThreadTable[];
 
diff -u -p a/codes/apps/barnes/code.c b/codes/apps/barnes/code.c
--- a/codes/apps/barnes/code.c
+++ b/codes/apps/barnes/code.c
@@ -68,9 +68,17 @@ Command line options:
 
 
 #include <pthread.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <sys/time.h>
 #include <unistd.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <malloc.h>
 /** +EDIT */
 //#define MAX_THREADS 32
@@ -289,7 +297,7 @@ int main (int argc, string argv[])
 	long	i, Error;
 
 	for (i = 0; i < (NPROC) - 1; i++) {
-		Error = pthread_create(&PThreadTable[i], NULL, (void * (*)(void *))(SlaveStart), NULL);
+		Error = liblock_thread_create(&PThreadTable[i], NULL, (void * (*)(void *))(SlaveStart), NULL);
 		if (Error != 0) {
 			printf("Error in pthread_create().\n");
 			exit(-1);
@@ -348,8 +356,8 @@ void ANLinit()
 
    {pthread_barrier_init(&(Global->Barrier), NULL, NPROC);};
 
-   pthread_mutex_init(&(Global->CountLock), NULL);;
-   pthread_mutex_init(&(Global->io_lock), NULL);;
+   liblock_lock_init(TYPE_BARNES_1, ARG_BARNES_1, &(Global->CountLock), NULL);;
+   liblock_lock_init(TYPE_NOINFO, ARG_NOINFO, &(Global->io_lock), NULL);;
 }
 
 /*
@@ -378,7 +386,7 @@ long Log_base_2(long number)
    cumulative = 1;
    for (out = 0; out < 20; out++) {
       if (cumulative == number) {
-         return(out);
+         return((out));
       }
       else {
          cumulative = cumulative * 2;
@@ -424,7 +432,8 @@ void tab_init()
 	unsigned long	i, Error;
 
 	for (i = 0; i < MAXLOCK; i++) {
-		Error = pthread_mutex_init(&CellLock->CL[i], NULL);
+		Error = liblock_lock_init(TYPE_BARNES_2, ARG_BARNES_2,
+                                          &CellLock->CL[i], NULL);
 		if (Error != 0) {
 			printf("Error while initializing array of locks.\n");
 			exit(-1);
@@ -434,6 +443,17 @@ void tab_init()
 ;
 }
 
+void * function34(void *ctx32);
+void *function34(void *ctx32) {
+   {
+      long ProcessId;
+      {
+         ProcessId = Global->current_id++;
+      }
+      return (void *)(uintptr_t)ProcessId;
+   }
+}
+
 /*
  * SLAVESTART: main task for each processor
  */
@@ -442,9 +462,10 @@ void SlaveStart()
    long ProcessId;
 
    /* Get unique ProcessId */
-   {pthread_mutex_lock(&(Global->CountLock));};
-     ProcessId = Global->current_id++;
-   {pthread_mutex_unlock(&(Global->CountLock));};
+   {
+   
+   ProcessId =(long)(uintptr_t)(liblock_execute_operation(&(Global->CountLock), (void *)(uintptr_t)(NULL), &function34));
+   }
 
    {;};
 
@@ -652,10 +673,29 @@ long intpow(long i, long j)
 
     for (k = 0; k < j; k++)
         temp = temp*i;
-    return temp;
+    return( temp);
 }
 
 
+void * function41(void *ctx39);
+void *function41(void *ctx39) {
+    {
+        long i;
+        long ProcessId=(long)(uintptr_t)ctx39;
+        {
+            for (i = 0;i < NDIM;i++) {
+                if (Global->min[i] > Local[ProcessId].min[i]) {
+                    Global->min[i] = Local[ProcessId].min[i];
+                }
+                if (Global->max[i] < Local[ProcessId].max[i]) {
+                    Global->max[i] = Local[ProcessId].max[i];
+                }
+            }
+        }
+        return (void *)(uintptr_t)i;
+    }
+}
+
 /*
  * STEPSYSTEM: advance N-body system one time-step.
  */
@@ -790,16 +830,10 @@ void stepsystem(long ProcessId)
 	  }
        }
     }
-    {pthread_mutex_lock(&(Global->CountLock));};
-    for (i = 0; i < NDIM; i++) {
-       if (Global->min[i] > Local[ProcessId].min[i]) {
-	  Global->min[i] = Local[ProcessId].min[i];
-       }
-       if (Global->max[i] < Local[ProcessId].max[i]) {
-	  Global->max[i] = Local[ProcessId].max[i];
-       }
+    {
+    
+    i =(long)(uintptr_t)(liblock_execute_operation(&(Global->CountLock), (void *)(uintptr_t)(ProcessId), &function41));
     }
-    {pthread_mutex_unlock(&(Global->CountLock));};
 
     /* bar needed to make sure that every process has computed its min */
     /* and max coordinates, and has accumulated them into the global   */
diff -u -p a/codes/apps/fmm/defs.h b/codes/apps/fmm/defs.h
--- a/codes/apps/fmm/defs.h
+++ b/codes/apps/fmm/defs.h
@@ -20,6 +20,10 @@
 
 #include <stdio.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <assert.h>
 #include <math.h>
 #include <limits.h>
diff -u -p a/codes/apps/fmm/memory.h b/codes/apps/fmm/memory.h
--- a/codes/apps/fmm/memory.h
+++ b/codes/apps/fmm/memory.h
@@ -26,9 +26,17 @@
 
 
 #include <pthread.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <sys/time.h>
 #include <unistd.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <malloc.h>
 extern pthread_t PThreadTable[];
 
@@ -37,12 +45,12 @@ typedef struct _G_Mem g_mem;
 
 struct _G_Mem
 {
-   pthread_mutex_t io_lock;
-   pthread_mutex_t mal_lock;
-   pthread_mutex_t single_lock;
-   pthread_mutex_t count_lock;
+   liblock_lock_t io_lock;
+   liblock_lock_t mal_lock;
+   liblock_lock_t single_lock;
+   liblock_lock_t count_lock;
    long count;
-   pthread_mutex_t lock_array[MAX_LOCKS];
+   liblock_lock_t lock_array[MAX_LOCKS];
    
 pthread_barrier_t	(synch);
 
diff -u -p a/codes/apps/fmm/defs.c b/codes/apps/fmm/defs.c
--- a/codes/apps/fmm/defs.c
+++ b/codes/apps/fmm/defs.c
@@ -44,7 +44,7 @@ RoundReal (real val)
    temp = modf(shifted_frac, &new_frac);
    new_frac /= shifter;
    ret_val = (real) ldexp(new_frac, exp);
-   return ret_val;
+   return( ret_val);
 }
 
 
@@ -65,17 +65,36 @@ PrintVector (vector *v)
 }
 
 
+union instance5 {struct input3{va_list *ap;char *format_str;} input3;};
+void * function6(void *ctx4);
+void *function6(void *ctx4) {
+   {
+      struct input3 *incontext1=&(((union instance5 *)ctx4)->input3);
+      va_list *ap=incontext1->ap;
+      char *format_str=incontext1->format_str;
+      {
+         fflush(stdout);
+         vfprintf(stdout, format_str, (*ap));
+         fflush(stdout);
+      }
+      return NULL;
+   }
+}
+
 void
 LockedPrint (char *format_str, ...)
 {
    va_list ap;
 
    va_start(ap, format_str);
-   {pthread_mutex_lock(&(G_Memory->io_lock));};
-   fflush(stdout);
-   vfprintf(stdout, format_str, ap);
-   fflush(stdout);
-   {pthread_mutex_unlock(&(G_Memory->io_lock));};
+   { union instance5 instance5 = {
+      {
+         &ap,
+         format_str,
+      },
+   };
+   
+   liblock_execute_operation(&(G_Memory->io_lock), (void *)(uintptr_t)(&instance5), &function6); }
    va_end(ap);
 }
 
diff -u -p a/codes/apps/fmm/memory.c b/codes/apps/fmm/memory.c
--- a/codes/apps/fmm/memory.c
+++ b/codes/apps/fmm/memory.c
@@ -21,9 +21,17 @@
 
 
 #include <pthread.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <sys/time.h>
 #include <unistd.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <malloc.h>
 /** +EDIT */
 //#define MAX_THREADS 32
@@ -57,16 +65,17 @@ InitGlobalMemory ()
    }
    G_Memory->count = 0;
    G_Memory->id = 0;
-   pthread_mutex_init(&(G_Memory->io_lock), NULL);;
-   pthread_mutex_init(&(G_Memory->mal_lock), NULL);;
-   pthread_mutex_init(&(G_Memory->single_lock), NULL);;
-   pthread_mutex_init(&(G_Memory->count_lock), NULL);;
+   liblock_lock_init(TYPE_NOINFO, ARG_NOINFO, &(G_Memory->io_lock), NULL);;
+   liblock_lock_init(TYPE_NOINFO, ARG_NOINFO, &(G_Memory->mal_lock), NULL);;
+   liblock_lock_init(TYPE_NOINFO, ARG_NOINFO, &(G_Memory->single_lock), NULL);;
+   liblock_lock_init(TYPE_NOINFO, ARG_NOINFO, &(G_Memory->count_lock), NULL);;
    
 {
 	unsigned long	i, Error;
 
 	for (i = 0; i < MAX_LOCKS; i++) {
-		Error = pthread_mutex_init(&G_Memory->lock_array[i], NULL);
+		Error = liblock_lock_init(TYPE_FMM_1, ARG_FMM_1,
+                                          &G_Memory->lock_array[i], NULL);
 		if (Error != 0) {
 			printf("Error while initializing array of locks.\n");
 			exit(-1);
diff -u -p a/codes/apps/fmm/construct_grid.c b/codes/apps/fmm/construct_grid.c
--- a/codes/apps/fmm/construct_grid.c
+++ b/codes/apps/fmm/construct_grid.c
@@ -390,7 +390,7 @@ InitGrid (long my_id)
    grid_y_center = (grid_length / (real) 2.0) + Local[my_id].Local_Y_Min;
 
    ret_box = InitBox(my_id, grid_x_center, grid_y_center, grid_length, NULL);
-   return ret_box;
+   return( ret_box);
 }
 
 
@@ -464,7 +464,7 @@ FindHome (long my_id, particle *p, box *
 	 }
       }
    }
-   return pb;
+   return( pb);
 }
 
 
@@ -488,7 +488,7 @@ FindInitialRoot (particle *p, box *curre
       else
 	 found = TRUE;
    }
-   return current_home;
+   return( current_home);
 }
 
 
@@ -533,7 +533,7 @@ CreateChild (long my_id, box *pb, long n
    pb->children[new_child_num]->child_num = new_child_num;
    ret_box = pb->children[new_child_num];
    pb->num_children += 1;
-   return ret_box;
+   return( ret_box);
 }
 
 
@@ -755,7 +755,7 @@ CreateLeaf (long my_id, box *pb, long ne
       ret_box->particles[i] = p_array[i];
    }
    ret_box->num_particles = length;
-   return ret_box;
+   return( ret_box);
 }
 
 
@@ -782,67 +782,135 @@ InsertParticlesInLeaf (long my_id, parti
 }
 
 
+union instance19 {struct input17{box *b;box *pb;} input17;};
+void * function20(void *ctx18);
+void *function20(void *ctx18) {
+   {
+      struct input17 *incontext15=&(((union instance19 *)ctx18)->input17);
+      long success;
+      box *b=incontext15->b;
+      box *pb=incontext15->pb;
+      {
+         if (pb->children[b->child_num] == NULL) {
+            pb->children[b->child_num] = b;
+            pb->num_children += 1;
+            b->parent = pb;
+            success = TRUE;
+         }else
+            success = FALSE;
+      }
+      return (void *)(uintptr_t)success;
+   }
+}
+
+void * function13(void *ctx11);
+void *function13(void *ctx11) {
+   {
+      long success;
+      box *b=(box *)(uintptr_t)ctx11;
+      {
+         if (Grid == NULL) {
+            Grid = b;
+            success = TRUE;
+         }else
+            success = FALSE;
+      }
+      return (void *)(uintptr_t)success;
+   }
+}
+
 long
 InsertBoxInGrid (long my_id, box *b, box *pb)
 {
    long success;
 
    if (pb == NULL) {
-      {pthread_mutex_lock(&(G_Memory->single_lock));};
-      if (Grid == NULL) {
-	 Grid = b;
-	 success = TRUE;
+      {
+      
+      success =(long)(uintptr_t)(liblock_execute_operation(&(G_Memory->single_lock), (void *)(uintptr_t)(b),
+                                &function13));
       }
-      else
-	 success = FALSE;
-      {pthread_mutex_unlock(&(G_Memory->single_lock));};
    }
    else {
-      {pthread_mutex_lock(&G_Memory->lock_array[pb->particle_lock_index]);};
-      if (pb->children[b->child_num] == NULL) {
-	 pb->children[b->child_num] = b;
-	 pb->num_children += 1;
-	 b->parent = pb;
-	 success = TRUE;
+      { union instance19 instance19 = {
+         {
+            b,
+            pb,
+         },
+      };
+      
+      success =(long)(uintptr_t)(liblock_execute_operation(&G_Memory->lock_array[pb->particle_lock_index],
+                                (void *)(uintptr_t)(&instance19), &function20));
       }
-      else
-	 success = FALSE;
-      {pthread_mutex_unlock(&G_Memory->lock_array[pb->particle_lock_index]);};
    }
    if (success == TRUE)
       InsertSubtreeInPartition(my_id, b);
-   return success;
+   return( success);
 }
 
 
+union instance33 {struct input31{box *b;box *pb;} input31;};
+void * function34(void *ctx32);
+void *function34(void *ctx32) {
+   {
+      struct input31 *incontext29=&(((union instance33 *)ctx32)->input31);
+      long success;
+      box *b=incontext29->b;
+      box *pb=incontext29->pb;
+      {
+         if (pb->children[b->child_num] == b) {
+            pb->children[b->child_num] = NULL;
+            b->parent = NULL;
+            pb->num_children -= 1;
+            success = TRUE;
+         }else
+            success = FALSE;
+      }
+      return (void *)(uintptr_t)success;
+   }
+}
+
+void * function27(void *ctx25);
+void *function27(void *ctx25) {
+   {
+      long success;
+      box *b=(box *)(uintptr_t)ctx25;
+      {
+         if (Grid == b) {
+            Grid = NULL;
+            success = TRUE;
+         }else
+            success = FALSE;
+      }
+      return (void *)(uintptr_t)success;
+   }
+}
+
 long
 RemoveBoxFromGrid (box *b, box *pb)
 {
    long success;
 
    if (pb == NULL) {
-      {pthread_mutex_lock(&(G_Memory->single_lock));};
-      if (Grid == b) {
-	 Grid = NULL;
-	 success = TRUE;
+      {
+      
+      success =(long)(uintptr_t)(liblock_execute_operation(&(G_Memory->single_lock), (void *)(uintptr_t)(b),
+                                &function27));
       }
-      else
-	 success = FALSE;
-      {pthread_mutex_unlock(&(G_Memory->single_lock));};
    }
    else {
-      {pthread_mutex_lock(&G_Memory->lock_array[pb->particle_lock_index]);};
-      if (pb->children[b->child_num] == b) {
-	 pb->children[b->child_num] = NULL;
-	 b->parent = NULL;
-	 pb->num_children -= 1;
-	 success = TRUE;
+      { union instance33 instance33 = {
+         {
+            b,
+            pb,
+         },
+      };
+      
+      success =(long)(uintptr_t)(liblock_execute_operation(&G_Memory->lock_array[pb->particle_lock_index],
+                                (void *)(uintptr_t)(&instance33), &function34));
       }
-      else
-	 success = FALSE;
-      {pthread_mutex_unlock(&G_Memory->lock_array[pb->particle_lock_index]);};
    }
-   return success;
+   return( success);
 }
 
 
@@ -1095,7 +1163,7 @@ AncestorBox (box *b, box *ancestor_box)
    else
       ret_val = FALSE;
 
-   return ret_val;
+   return( ret_val);
 
 }
 
diff -u -p a/codes/apps/fmm/box.c b/codes/apps/fmm/box.c
--- a/codes/apps/fmm/box.c
+++ b/codes/apps/fmm/box.c
@@ -30,32 +30,34 @@ box *Grid = NULL;
 
 void ZeroBox(long my_id, box *b);
 
+union instance40 {struct input38{long num_boxes;long my_id;} input38;};
+void * function41(void *ctx39);
+void *function41(void *ctx39) {
+   {
+      struct input38 *incontext36=&(((union instance40 *)ctx39)->input38);
+      long num_boxes=incontext36->num_boxes;
+      long my_id=incontext36->my_id;
+      {
+         Local[my_id].B_Heap = (box *)valloc(num_boxes * sizeof(box));
+         ;
+      }
+      return NULL;
+   }
+}
+
 void
 CreateBoxes (long my_id, long num_boxes)
 {
    long i;
 
-   {pthread_mutex_lock(&(G_Memory->mal_lock));};
-   Local[my_id].B_Heap = (box *) valloc(num_boxes * sizeof(box));;
-
-/* POSSIBLE ENHANCEMENT:  Here is where one might distribute the
-   B_Heap data across physically distributed memories as desired.
-
-   One way to do this is as follows:
-
-   char *starting_address;
-   char *ending_address;
-
-   starting_address = (char *) Local[my_id].B_Heap;
-   ending_address = (((char *) Local[my_id].B_Heap)
-		     + (num_boxes * sizeof(particle *)) - 1);
-
-   Place all addresses x such that (starting_address <= x < ending_address)
-   on node my_id
-
-*/
-
-   {pthread_mutex_unlock(&(G_Memory->mal_lock));};
+   { union instance40 instance40 = {
+      {
+         num_boxes,
+         my_id,
+      },
+   };
+   
+   liblock_execute_operation(&(G_Memory->mal_lock), (void *)(uintptr_t)(&instance40), &function41); }
    Local[my_id].Max_B_Heap = num_boxes;
    Local[my_id].Index_B_Heap = 0;
 
@@ -139,10 +141,56 @@ InitBox (long my_id, real x_center, real
       b->level = 0;
    else
       b->level = parent->level + 1;
-   return b;
+   return( b);
 }
 
 
+void * function48(void *ctx46);
+void *function48(void *ctx46) {
+   {
+      box *b=(box *)(uintptr_t)ctx46;
+      {
+         fflush(stdout);
+         if (b != NULL) {
+            printf("Info for B%f :\n", b->id);
+            printf("  X center       = %.40g\n", b->x_center);
+            printf("  Y center       = %.40g\n", b->y_center);
+            printf("  Length         = %.40g\n", b->length);
+            printf("  Level          = %ld\n", b->level);
+            printf("  Type           = %d\n", b->type);
+            printf("  Child Num      = %ld\n", b->child_num);
+            if (b->parent == NULL)
+               printf("  Parent         = NONE\n");else
+               printf("  Parent         = B%f\n", b->parent->id);
+            printf("  Children's IDs : ");
+            if (b->num_children != 0)
+               PrintBoxArrayIds(b->children, b->num_children);else
+               printf("NONE\n");
+            printf("  Sibling's IDs : ");
+            if (b->num_siblings != 0)
+               PrintBoxArrayIds(b->siblings, b->num_siblings);else
+               printf("NONE\n");
+            printf("  Colleagues' IDs : ");
+            PrintBoxArrayIds(b->colleagues, b->num_colleagues);
+            printf("  U List IDs : ");
+            PrintBoxArrayIds(b->u_list, b->num_u_list);
+            printf("  V List IDs : ");
+            PrintBoxArrayIds(b->v_list, b->num_v_list);
+            printf("  W List IDs : ");
+            PrintBoxArrayIds(b->w_list, b->num_w_list);
+            printf("  # of Particles = %ld\n", b->num_particles);
+            printf("  Particles' IDs : ");
+            PrintParticleArrayIds(b->particles, b->num_particles);
+            printf("  Assigned Process ID : %ld\n", b->proc);
+            printf("  Cost : %ld\n", b->cost);
+            printf("\n");
+         }else
+            printf("Box has not been initialized yet.\n\n");
+      }
+      return NULL;
+   }
+}
+
 /*
  *  PrintBox (box *b)
  *
@@ -156,48 +204,9 @@ InitBox (long my_id, real x_center, real
 void
 PrintBox (box *b)
 {
-   {pthread_mutex_lock(&(G_Memory->io_lock));};
-   fflush(stdout);
-   if (b != NULL) {
-      printf("Info for B%f :\n", b->id);
-      printf("  X center       = %.40g\n", b->x_center);
-      printf("  Y center       = %.40g\n", b->y_center);
-      printf("  Length         = %.40g\n", b->length);
-      printf("  Level          = %ld\n", b->level);
-      printf("  Type           = %d\n", b->type);
-      printf("  Child Num      = %ld\n", b->child_num);
-      if (b->parent == NULL)
-	 printf("  Parent         = NONE\n");
-      else
-	 printf("  Parent         = B%f\n", b->parent->id);
-      printf("  Children's IDs : ");
-      if (b->num_children != 0)
-	 PrintBoxArrayIds(b->children, b->num_children);
-      else
-	 printf("NONE\n");
-      printf("  Sibling's IDs : ");
-      if (b->num_siblings != 0)
-	 PrintBoxArrayIds(b->siblings, b->num_siblings);
-      else
-	 printf("NONE\n");
-      printf("  Colleagues' IDs : ");
-      PrintBoxArrayIds(b->colleagues, b->num_colleagues);
-      printf("  U List IDs : ");
-      PrintBoxArrayIds(b->u_list, b->num_u_list);
-      printf("  V List IDs : ");
-      PrintBoxArrayIds(b->v_list, b->num_v_list);
-      printf("  W List IDs : ");
-      PrintBoxArrayIds(b->w_list, b->num_w_list);
-      printf("  # of Particles = %ld\n", b->num_particles);
-      printf("  Particles' IDs : ");
-      PrintParticleArrayIds(b->particles, b->num_particles);
-      printf("  Assigned Process ID : %ld\n", b->proc);
-      printf("  Cost : %ld\n", b->cost);
-      printf("\n");
-   }
-   else
-      printf("Box has not been initialized yet.\n\n");
-   {pthread_mutex_unlock(&(G_Memory->io_lock));};
+   {
+   
+   liblock_execute_operation(&(G_Memory->io_lock), (void *)(uintptr_t)(b), &function48); }
 }
 
 
@@ -317,7 +326,7 @@ AdjacentBoxes (box *b1, box *b2)
       else
 	 ret_val = FALSE;
 
-   return ret_val;
+   return( ret_val);
 }
 
 
@@ -359,7 +368,7 @@ WellSeparatedBoxes (box *b1, box *b2)
    else
       ret_val = FALSE;
 
-   return ret_val;
+   return( ret_val);
 }
 
 
diff -u -p a/codes/apps/fmm/particle.c b/codes/apps/fmm/particle.c
--- a/codes/apps/fmm/particle.c
+++ b/codes/apps/fmm/particle.c
@@ -18,6 +18,10 @@
 #include <stdio.h>
 #include <unistd.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include "defs.h"
 #include "memory.h"
 #include "particle.h"
@@ -174,31 +178,32 @@ CreateDistribution (cluster_type cluster
 }
 
 
+union instance54 {struct input52{long length;long my_id;} input52;};
+void * function55(void *ctx53);
+void *function55(void *ctx53) {
+   {
+      struct input52 *incontext50=&(((union instance54 *)ctx53)->input52);
+      long length=incontext50->length;
+      long my_id=incontext50->my_id;
+      {
+         Local[my_id].Particles = (particle **)valloc(length * sizeof(particle *));
+         ;
+      }
+      return NULL;
+   }
+}
+
 void
 CreateParticleList (long my_id, long length)
 {
-   {pthread_mutex_lock(&(G_Memory->mal_lock));};
-   Local[my_id].Particles = (particle **) valloc(length
-						   * sizeof(particle *));;
-
-/* POSSIBLE ENHANCEMENT:  Here is where one might distribute the
-   Particles data across physically distributed memories as desired.
-
-   One way to do this is as follows:
-
-   char *starting_address;
-   char *ending_address;
-
-   starting_address = (char *) Local[my_id].Particles;
-   ending_address = (((char *) Local[my_id].Particles)
-		     + (length * sizeof(particle *)) - 1);
-
-   Place all addresses x such that (starting_address <= x < ending_address)
-   on node my_id
-
-*/
-
-   {pthread_mutex_unlock(&(G_Memory->mal_lock));};
+   { union instance54 instance54 = {
+      {
+         length,
+         my_id,
+      },
+   };
+   
+   liblock_execute_operation(&(G_Memory->mal_lock), (void *)(uintptr_t)(&instance54), &function55); }
    Local[my_id].Max_Particles = length;
    Local[my_id].Num_Particles = 0;
 }
@@ -305,7 +310,7 @@ InitParticle (real charge, real mass)
    p->field.i = (real) 0.0;
    p->cost = 1;
    p->box = 0.0;
-   return p;
+   return( p);
 }
 
 
@@ -332,7 +337,7 @@ XRand (real low, real high)
    real ret_val;
 
    ret_val = low  + (high - low) * ((real) rand/*om*/() / 2147483647.0);
-   return ret_val;
+   return( ret_val);
 }
 
 
diff -u -p a/codes/apps/fmm/interactions.c b/codes/apps/fmm/interactions.c
--- a/codes/apps/fmm/interactions.c
+++ b/codes/apps/fmm/interactions.c
@@ -89,15 +89,38 @@ PrintExpTables ()
 }
 
 
+void * function69(void *ctx67);
+void *function69(void *ctx67) {
+   {
+      box *b=(box *)(uintptr_t)ctx67;
+      {
+         b->parent->interaction_synch += 1;
+      }
+      return NULL;
+   }
+}
+
+void * function62(void *ctx60);
+void *function62(void *ctx60) {
+   {
+      box *b=(box *)(uintptr_t)ctx60;
+      {
+         b->interaction_synch = 1;
+      }
+      return NULL;
+   }
+}
+
 void
 UpwardPass (long my_id, box *b)
 {
    InitExp(b);
    if (b->type == CHILDLESS) {
       ComputeMPExp(b);
-      {pthread_mutex_lock(&G_Memory->lock_array[b->exp_lock_index]);};
-      b->interaction_synch = 1;
-      {pthread_mutex_unlock(&G_Memory->lock_array[b->exp_lock_index]);};
+      {
+      
+      liblock_execute_operation(&G_Memory->lock_array[b->exp_lock_index],
+                                (void *)(uintptr_t)(b), &function62); }
    }
    else {
       while (b->interaction_synch != b->num_children) {
@@ -106,9 +129,10 @@ UpwardPass (long my_id, box *b)
    }
    if (b->parent != NULL) {
       ShiftMPExp(b, b->parent);
-      {pthread_mutex_lock(&G_Memory->lock_array[b->parent->exp_lock_index]);};
-      b->parent->interaction_synch += 1;
-      {pthread_mutex_unlock(&G_Memory->lock_array[b->parent->exp_lock_index]);};
+      {
+      
+      liblock_execute_operation(&G_Memory->lock_array[b->parent->exp_lock_index],
+                                (void *)(uintptr_t)(b), &function69); }
    }
 }
 
@@ -126,6 +150,17 @@ ComputeInteractions (long my_id, box *b)
 }
 
 
+void * function76(void *ctx74);
+void *function76(void *ctx74) {
+   {
+      box *b=(box *)(uintptr_t)ctx74;
+      {
+         b->interaction_synch = 0;
+      }
+      return NULL;
+   }
+}
+
 void
 DownwardPass (long my_id, box *b)
 {
@@ -140,9 +175,10 @@ DownwardPass (long my_id, box *b)
       b->interaction_synch = 0;
    }
    else {
-      {pthread_mutex_lock(&G_Memory->lock_array[b->exp_lock_index]);};
-      b->interaction_synch = 0;
-      {pthread_mutex_unlock(&G_Memory->lock_array[b->exp_lock_index]);};
+      {
+      
+      liblock_execute_operation(&G_Memory->lock_array[b->exp_lock_index],
+                                (void *)(uintptr_t)(b), &function76); }
    }
 }
 
@@ -196,6 +232,24 @@ InitExp (box *b)
 }
 
 
+union instance82 {struct input80{complex *result_exp;box *b;} input80;};
+void * function83(void *ctx81);
+void *function83(void *ctx81) {
+   {
+      struct input80 *incontext78=&(((union instance82 *)ctx81)->input80);
+      complex *result_exp=incontext78->result_exp;
+      long i;
+      box *b=incontext78->b;
+      {
+         for (i = 0;i < Expansion_Terms;i++) {
+            b->mp_expansion[i].r = result_exp[i].r;
+            b->mp_expansion[i].i = result_exp[i].i;
+         }
+      }
+      return NULL;
+   }
+}
+
 /*
  *  ComputeMPExp (long my_id, box *b)
  *
@@ -247,15 +301,35 @@ ComputeMPExp (box *b)
 	 COMPLEX_MUL(z0_pow_n, z0_pow_n, z0);
       }
    }
-   {pthread_mutex_lock(&G_Memory->lock_array[b->exp_lock_index]);};
-   for (i = 0; i < Expansion_Terms; i++) {
-      b->mp_expansion[i].r = result_exp[i].r;
-      b->mp_expansion[i].i = result_exp[i].i;
-   }
-   {pthread_mutex_unlock(&G_Memory->lock_array[b->exp_lock_index]);};
+   { union instance82 instance82 = {
+      {
+         result_exp,
+         b,
+      },
+   };
+   
+   liblock_execute_operation(&G_Memory->lock_array[b->exp_lock_index],
+                             (void *)(uintptr_t)(&instance82), &function83); }
 }
 
 
+union instance89 {struct input87{complex *result_exp;box *pb;} input87;};
+void * function90(void *ctx88);
+void *function90(void *ctx88) {
+   {
+      struct input87 *incontext85=&(((union instance89 *)ctx88)->input87);
+      complex *result_exp=incontext85->result_exp;
+      long i;
+      box *pb=incontext85->pb;
+      {
+         for (i = 0;i < Expansion_Terms;i++) {
+            COMPLEX_ADD((pb->mp_expansion[i]), (pb->mp_expansion[i]), result_exp[i]);
+         }
+      }
+      return NULL;
+   }
+}
+
 void
 ShiftMPExp (box *cb, box *pb)
 {
@@ -301,11 +375,15 @@ ShiftMPExp (box *cb, box *pb)
       COMPLEX_MUL(z0_pow_n, z0_pow_n, z0);
       COMPLEX_MUL(result_exp[i], temp, z0_pow_n);
    }
-   {pthread_mutex_lock(&G_Memory->lock_array[pb->exp_lock_index]);};
-   for (i = 0; i < Expansion_Terms; i++) {
-      COMPLEX_ADD((pb->mp_expansion[i]), (pb->mp_expansion[i]), result_exp[i]);
-   }
-   {pthread_mutex_unlock(&G_Memory->lock_array[pb->exp_lock_index]);};
+   { union instance89 instance89 = {
+      {
+         result_exp,
+         pb,
+      },
+   };
+   
+   liblock_execute_operation(&G_Memory->lock_array[pb->exp_lock_index],
+                             (void *)(uintptr_t)(&instance89), &function90); }
 }
 
 
@@ -475,6 +553,23 @@ WListInteraction (box *source_box, box *
 }
 
 
+union instance96 {struct input94{complex *result_exp;box *dest_box;} input94;};
+void * function97(void *ctx95);
+void *function97(void *ctx95) {
+   {
+      struct input94 *incontext92=&(((union instance96 *)ctx95)->input94);
+      complex *result_exp=incontext92->result_exp;
+      long i;
+      box *dest_box=incontext92->dest_box;
+      {
+         for (i = 0;i < Expansion_Terms;i++) {
+            COMPLEX_SUB((dest_box->x_expansion[i]), (dest_box->x_expansion[i]), result_exp[i]);
+         }
+      }
+      return NULL;
+   }
+}
+
 void
 XListInteraction (box *source_box, box *dest_box)
 {
@@ -510,12 +605,15 @@ XListInteraction (box *source_box, box *
 	 COMPLEX_ADD(result_exp[j], result_exp[j], temp);
       }
    }
-   {pthread_mutex_lock(&G_Memory->lock_array[dest_box->exp_lock_index]);};
-   for (i = 0; i < Expansion_Terms; i++) {
-      COMPLEX_SUB((dest_box->x_expansion[i]),
-		  (dest_box->x_expansion[i]), result_exp[i]);
-   }
-   {pthread_mutex_unlock(&G_Memory->lock_array[dest_box->exp_lock_index]);};
+   { union instance96 instance96 = {
+      {
+         result_exp,
+         dest_box,
+      },
+   };
+   
+   liblock_execute_operation(&G_Memory->lock_array[dest_box->exp_lock_index],
+                             (void *)(uintptr_t)(&instance96), &function97); }
    source_box->cost += X_LIST_COST(source_box->num_particles, Expansion_Terms);
 }
 
@@ -577,6 +675,23 @@ ComputeSelfInteraction (box *b)
 }
 
 
+union instance103 {struct input101{complex *result_exp;box *cb;} input101;};
+void * function104(void *ctx102);
+void *function104(void *ctx102) {
+   {
+      struct input101 *incontext99=&(((union instance103 *)ctx102)->input101);
+      complex *result_exp=incontext99->result_exp;
+      long i;
+      box *cb=incontext99->cb;
+      {
+         for (i = 0;i < Expansion_Terms;i++) {
+            COMPLEX_ADD((cb->local_expansion[i]), (cb->local_expansion[i]), result_exp[i]);
+         }
+      }
+      return NULL;
+   }
+}
+
 void
 ShiftLocalExp (box *pb, box *cb)
 {
@@ -620,12 +735,15 @@ ShiftLocalExp (box *pb, box *cb)
       COMPLEX_MUL(result_exp[i], temp, z0_pow_minus_n);
       COMPLEX_MUL(z0_pow_minus_n, z0_pow_minus_n, z0_inv);
    }
-   {pthread_mutex_lock(&G_Memory->lock_array[cb->exp_lock_index]);};
-   for (i = 0; i < Expansion_Terms; i++) {
-      COMPLEX_ADD((cb->local_expansion[i]), (cb->local_expansion[i]),
-		  result_exp[i]);
-   }
-   {pthread_mutex_unlock(&G_Memory->lock_array[cb->exp_lock_index]);};
+   { union instance103 instance103 = {
+      {
+         result_exp,
+         cb,
+      },
+   };
+   
+   liblock_execute_operation(&G_Memory->lock_array[cb->exp_lock_index],
+                             (void *)(uintptr_t)(&instance103), &function104); }
 }
 
 
diff -u -p a/codes/apps/fmm/partition_grid.c b/codes/apps/fmm/partition_grid.c
--- a/codes/apps/fmm/partition_grid.c
+++ b/codes/apps/fmm/partition_grid.c
@@ -264,6 +264,179 @@ CheckPartition (long my_id)
 }
 
 
+union instance180 {struct input178{box *b;long my_id;} input178;};
+union instance173 {struct input171{box *b;long my_id;} input171;};
+union instance166 {struct input164{box *b;long my_id;} input164;};
+union instance159 {struct input157{box *b;long my_id;} input157;};
+union instance152 {struct input150{box *b;long my_id;long partition_level;} input150;};
+union instance145 {struct input143{box *b;long my_id;} input143;};
+union instance138 {struct input136{box *b;long my_id;} input136;};
+union instance131 {struct input129{box *b;long my_id;} input129;};
+union instance124 {struct input122{box *b;long my_id;} input122;};
+union instance117 {struct input115{box *b;long my_id;} input115;};
+union instance110 {struct input108{box *b;long my_id;} input108;};
+void * function181(void *ctx179);
+void *function181(void *ctx179) {
+   {
+      struct input178 *incontext176=&(((union instance180 *)ctx179)->input178);
+      box *b=incontext176->b;
+      long my_id=incontext176->my_id;
+      {
+         if (b->type == CHILDLESS)
+            printf("ERROR : Extra CHILDLESS box in partition (B%f P%ld)\n", b->id, my_id);else
+            printf("ERROR : Extra PARENT box in partition (B%f P%ld)\n", b->id, my_id);
+         fflush(stdout);
+      }
+      return NULL;
+   }
+}
+
+void * function174(void *ctx172);
+void *function174(void *ctx172) {
+   {
+      struct input171 *incontext169=&(((union instance173 *)ctx172)->input171);
+      box *b=incontext169->b;
+      long my_id=incontext169->my_id;
+      {
+         if (b->type == CHILDLESS)
+            printf("ERROR : Extra CHILDLESS box in partition (B%f P%ld)\n", b->id, my_id);else
+            printf("ERROR : Extra PARENT box in partition (B%f P%ld)\n", b->id, my_id);
+         fflush(stdout);
+      }
+      return NULL;
+   }
+}
+
+void * function167(void *ctx165);
+void *function167(void *ctx165) {
+   {
+      struct input164 *incontext162=&(((union instance166 *)ctx165)->input164);
+      box *b=incontext162->b;
+      long my_id=incontext162->my_id;
+      {
+         printf("ERROR : PARENT box has particles (B%f P%ld)\n", b->id, my_id);
+         fflush(stdout);
+      }
+      return NULL;
+   }
+}
+
+void * function160(void *ctx158);
+void *function160(void *ctx158) {
+   {
+      struct input157 *incontext155=&(((union instance159 *)ctx158)->input157);
+      box *b=incontext155->b;
+      long my_id=incontext155->my_id;
+      {
+         printf("ERROR : PARENT box has no children (B%f P%ld)\n", b->id, my_id);
+         fflush(stdout);
+      }
+      return NULL;
+   }
+}
+
+void * function153(void *ctx151);
+void *function153(void *ctx151) {
+   {
+      struct input150 *incontext148=&(((union instance152 *)ctx151)->input150);
+      box *b=incontext148->b;
+      long my_id=incontext148->my_id;
+      long partition_level=incontext148->partition_level;
+      {
+         printf("ERROR : PARENT box in wrong partition level ");
+         printf("(%ld vs %ld) (B%f P%ld)\n", b->level, partition_level, b->id, my_id);
+         fflush(stdout);
+      }
+      return NULL;
+   }
+}
+
+void * function146(void *ctx144);
+void *function146(void *ctx144) {
+   {
+      struct input143 *incontext141=&(((union instance145 *)ctx144)->input143);
+      box *b=incontext141->b;
+      long my_id=incontext141->my_id;
+      {
+         printf("ERROR : PARENT box in childless partition (B%f P%ld %ld)\n", b->id, my_id, b->proc);
+         fflush(stdout);
+      }
+      return NULL;
+   }
+}
+
+void * function139(void *ctx137);
+void *function139(void *ctx137) {
+   {
+      struct input136 *incontext134=&(((union instance138 *)ctx137)->input136);
+      box *b=incontext134->b;
+      long my_id=incontext134->my_id;
+      {
+         printf("ERROR : CHILDLESS box has more particles than expected ");
+         printf("(B%f P%ld)\n", b->id, my_id);
+         fflush(stdout);
+      }
+      return NULL;
+   }
+}
+
+void * function132(void *ctx130);
+void *function132(void *ctx130) {
+   {
+      struct input129 *incontext127=&(((union instance131 *)ctx130)->input129);
+      box *b=incontext127->b;
+      long my_id=incontext127->my_id;
+      {
+         printf("ERROR : CHILDLESS box has fewer particles than expected ");
+         printf("(B%f P%ld)\n", b->id, my_id);
+         fflush(stdout);
+      }
+      return NULL;
+   }
+}
+
+void * function125(void *ctx123);
+void *function125(void *ctx123) {
+   {
+      struct input122 *incontext120=&(((union instance124 *)ctx123)->input122);
+      box *b=incontext120->b;
+      long my_id=incontext120->my_id;
+      {
+         printf("ERROR : CHILDLESS box has no particles (B%f P%ld)\n", b->id, my_id);
+         fflush(stdout);
+      }
+      return NULL;
+   }
+}
+
+void * function118(void *ctx116);
+void *function118(void *ctx116) {
+   {
+      struct input115 *incontext113=&(((union instance117 *)ctx116)->input115);
+      box *b=incontext113->b;
+      long my_id=incontext113->my_id;
+      {
+         printf("ERROR : CHILDLESS box has children (B%f P%ld)\n", b->id, my_id);
+         fflush(stdout);
+      }
+      return NULL;
+   }
+}
+
+void * function111(void *ctx109);
+void *function111(void *ctx109) {
+   {
+      struct input108 *incontext106=&(((union instance110 *)ctx109)->input108);
+      box *b=incontext106->b;
+      long my_id=incontext106->my_id;
+      {
+         printf("ERROR : CHILDLESS box in parent partition (B%f P%ld %ld)\n", b->id, my_id, b->proc);
+         fflush(stdout);
+      }
+      return NULL;
+   }
+}
+
 long
 CheckBox (long my_id, box *b, long partition_level)
 {
@@ -272,102 +445,148 @@ CheckBox (long my_id, box *b, long parti
    num_errors = 0;
    if (b->type == CHILDLESS) {
       if (partition_level != -1) {
-	 {pthread_mutex_lock(&(G_Memory->io_lock));};
-	 printf("ERROR : CHILDLESS box in parent partition (B%f P%ld %ld)\n", b->id, my_id, b->proc);
-	 fflush(stdout);
-	 {pthread_mutex_unlock(&(G_Memory->io_lock));};
+	 { union instance110 instance110 = {
+	    {
+   	    b,
+      	 my_id,
+   	 },
+	 };
+	 
+	 liblock_execute_operation(&(G_Memory->io_lock), (void *)(uintptr_t)(&instance110),
+                                   &function111); }
 	 num_errors += 1;
       }
       if (b->num_children != 0) {
-	 {pthread_mutex_lock(&(G_Memory->io_lock));};
-	 printf("ERROR : CHILDLESS box has children (B%f P%ld)\n", b->id, my_id);
-	 fflush(stdout);
-	 {pthread_mutex_unlock(&(G_Memory->io_lock));};
+	 { union instance117 instance117 = {
+	    {
+   	    b,
+      	 my_id,
+   	 },
+	 };
+	 
+	 liblock_execute_operation(&(G_Memory->io_lock), (void *)(uintptr_t)(&instance117),
+                                   &function118); }
 	 num_errors += 1;
       }
       if (b->num_particles == 0) {
-	 {pthread_mutex_lock(&(G_Memory->io_lock));};
-	 printf("ERROR : CHILDLESS box has no particles (B%f P%ld)\n", b->id, my_id);
-	 fflush(stdout);
-	 {pthread_mutex_unlock(&(G_Memory->io_lock));};
+	 { union instance124 instance124 = {
+	    {
+   	    b,
+      	 my_id,
+   	 },
+	 };
+	 
+	 liblock_execute_operation(&(G_Memory->io_lock), (void *)(uintptr_t)(&instance124),
+                                   &function125); }
 	 num_errors += 1;
       }
       if (b->particles[b->num_particles - 1] == NULL) {
-	 {pthread_mutex_lock(&(G_Memory->io_lock));};
-	 printf("ERROR : CHILDLESS box has fewer particles than expected ");
-	 printf("(B%f P%ld)\n", b->id, my_id);
-	 fflush(stdout);
-	 {pthread_mutex_unlock(&(G_Memory->io_lock));};
+	 { union instance131 instance131 = {
+	    {
+   	    b,
+      	 my_id,
+   	 },
+	 };
+	 
+	 liblock_execute_operation(&(G_Memory->io_lock), (void *)(uintptr_t)(&instance131),
+                                   &function132); }
 	 num_errors += 1;
       }
       if (b->particles[b->num_particles] != NULL) {
-	 {pthread_mutex_lock(&(G_Memory->io_lock));};
-	 printf("ERROR : CHILDLESS box has more particles than expected ");
-	 printf("(B%f P%ld)\n", b->id, my_id);
-	 fflush(stdout);
-	 {pthread_mutex_unlock(&(G_Memory->io_lock));};
+	 { union instance138 instance138 = {
+	    {
+   	    b,
+      	 my_id,
+   	 },
+	 };
+	 
+	 liblock_execute_operation(&(G_Memory->io_lock), (void *)(uintptr_t)(&instance138),
+                                   &function139); }
 	 num_errors += 1;
       }
    }
    else {
       if (partition_level == -1) {
-	 {pthread_mutex_lock(&(G_Memory->io_lock));};
-	 printf("ERROR : PARENT box in childless partition (B%f P%ld %ld)\n",
-		b->id, my_id, b->proc);
-	 fflush(stdout);
-	 {pthread_mutex_unlock(&(G_Memory->io_lock));};
+	 { union instance145 instance145 = {
+	    {
+   	    b,
+      	 my_id,
+   	 },
+	 };
+	 
+	 liblock_execute_operation(&(G_Memory->io_lock), (void *)(uintptr_t)(&instance145),
+                                   &function146); }
 	 num_errors += 1;
       }
       else {
 	 if (partition_level != b->level) {
-	    {pthread_mutex_lock(&(G_Memory->io_lock));};
-	    printf("ERROR : PARENT box in wrong partition level ");
-	    printf("(%ld vs %ld) (B%f P%ld)\n", b->level, partition_level, b->id, my_id);
-	    fflush(stdout);
-	    {pthread_mutex_unlock(&(G_Memory->io_lock));};
+	    { union instance152 instance152 = {
+	       {
+   	       b,
+      	    my_id,
+      	    partition_level,
+   	    },
+	    };
+	    
+	    liblock_execute_operation(&(G_Memory->io_lock), (void *)(uintptr_t)(&instance152),
+                                      &function153); }
 	    num_errors += 1;
 	 }
       }
       if (b->num_children == 0) {
-	 {pthread_mutex_lock(&(G_Memory->io_lock));};
-	 printf("ERROR : PARENT box has no children (B%f P%ld)\n", b->id, my_id);
-	 fflush(stdout);
-	 {pthread_mutex_unlock(&(G_Memory->io_lock));};
+	 { union instance159 instance159 = {
+	    {
+   	    b,
+      	 my_id,
+   	 },
+	 };
+	 
+	 liblock_execute_operation(&(G_Memory->io_lock), (void *)(uintptr_t)(&instance159),
+                                   &function160); }
 	 num_errors += 1;
       }
       if (b->num_particles != 0) {
-	 {pthread_mutex_lock(&(G_Memory->io_lock));};
-	 printf("ERROR : PARENT box has particles (B%f P%ld)\n", b->id, my_id);
-	 fflush(stdout);
-	 {pthread_mutex_unlock(&(G_Memory->io_lock));};
+	 { union instance166 instance166 = {
+	    {
+   	    b,
+      	 my_id,
+   	 },
+	 };
+	 
+	 liblock_execute_operation(&(G_Memory->io_lock), (void *)(uintptr_t)(&instance166),
+                                   &function167); }
 	 num_errors += 1;
       }
    }
    if (b->parent == NULL) {
       if (b != Grid) {
-	 {pthread_mutex_lock(&(G_Memory->io_lock));};
-	 if (b->type == CHILDLESS)
-	    printf("ERROR : Extra CHILDLESS box in partition (B%f P%ld)\n", b->id, my_id);
-	 else
-	    printf("ERROR : Extra PARENT box in partition (B%f P%ld)\n", b->id, my_id);
-	 fflush(stdout);
-	 {pthread_mutex_unlock(&(G_Memory->io_lock));};
+	 { union instance173 instance173 = {
+	    {
+   	    b,
+      	 my_id,
+   	 },
+	 };
+	 
+	 liblock_execute_operation(&(G_Memory->io_lock), (void *)(uintptr_t)(&instance173),
+                                   &function174); }
 	 num_errors += 1;
       }
    }
    else {
       if (b->parent->children[b->child_num] != b) {
-	 {pthread_mutex_lock(&(G_Memory->io_lock));};
-	 if (b->type == CHILDLESS)
-	    printf("ERROR : Extra CHILDLESS box in partition (B%f P%ld)\n", b->id, my_id);
-	 else
-	    printf("ERROR : Extra PARENT box in partition (B%f P%ld)\n", b->id, my_id);
-	 fflush(stdout);
-	 {pthread_mutex_unlock(&(G_Memory->io_lock));};
+	 { union instance180 instance180 = {
+	    {
+   	    b,
+      	 my_id,
+   	 },
+	 };
+	 
+	 liblock_execute_operation(&(G_Memory->io_lock), (void *)(uintptr_t)(&instance180),
+                                   &function181); }
 	 num_errors += 1;
       }
    }
-   return num_errors;
+   return( num_errors);
 }
 
 
diff -u -p a/codes/apps/fmm/cost_zones.c b/codes/apps/fmm/cost_zones.c
--- a/codes/apps/fmm/cost_zones.c
+++ b/codes/apps/fmm/cost_zones.c
@@ -68,6 +68,21 @@ CostZones (long my_id)
 }
 
 
+union instance187 {struct input185{box *b;box *pb;} input185;};
+void * function188(void *ctx186);
+void *function188(void *ctx186) {
+   {
+      struct input185 *incontext183=&(((union instance187 *)ctx186)->input185);
+      box *b=incontext183->b;
+      box *pb=incontext183->pb;
+      {
+         pb->subtree_cost += b->subtree_cost;
+         pb->interaction_synch += 1;
+      }
+      return NULL;
+   }
+}
+
 void
 ComputeSubTreeCosts (long my_id, box *b)
 {
@@ -82,10 +97,15 @@ ComputeSubTreeCosts (long my_id, box *b)
    b->subtree_cost += b->cost;
    pb = b->parent;
    if (pb != NULL) {
-      {pthread_mutex_lock(&G_Memory->lock_array[pb->exp_lock_index]);};
-      pb->subtree_cost += b->subtree_cost;
-      pb->interaction_synch += 1;
-      {pthread_mutex_unlock(&G_Memory->lock_array[pb->exp_lock_index]);};
+      { union instance187 instance187 = {
+         {
+            b,
+            pb,
+         },
+      };
+      
+      liblock_execute_operation(&G_Memory->lock_array[pb->exp_lock_index],
+                                (void *)(uintptr_t)(&instance187), &function188); }
    }
 }
 
diff -u -p a/codes/apps/fmm/fmm.c b/codes/apps/fmm/fmm.c
--- a/codes/apps/fmm/fmm.c
+++ b/codes/apps/fmm/fmm.c
@@ -71,6 +71,10 @@
 #include <math.h>
 #include <errno.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <string.h>
 #include "defs.h"
 #include "memory.h"
@@ -171,7 +175,7 @@ main (int argc, char *argv[])
 	long	i, Error;
 
 	for (i = 0; i < (Number_Of_Processors) - 1; i++) {
-		Error = pthread_create(&PThreadTable[i], NULL, (void * (*)(void *))(ParallelExecute), NULL);
+		Error = liblock_thread_create(&PThreadTable[i], NULL, (void * (*)(void *))(ParallelExecute), NULL);
 		if (Error != 0) {
 			printf("Error in pthread_create().\n");
 			exit(-1);
@@ -200,6 +204,18 @@ main (int argc, char *argv[])
 }
 
 
+void * function195(void *ctx193);
+void *function195(void *ctx193) {
+   {
+      long my_id;
+      {
+         my_id = G_Memory->id;
+         G_Memory->id++;
+      }
+      return (void *)(uintptr_t)my_id;
+   }
+}
+
 void
 ParallelExecute ()
 {
@@ -216,10 +232,11 @@ ParallelExecute ()
    {
 	pthread_barrier_wait(&(G_Memory->synch));
 };
-   {pthread_mutex_lock(&(G_Memory->count_lock));};
-     my_id = G_Memory->id;
-     G_Memory->id++;
-   {pthread_mutex_unlock(&(G_Memory->count_lock));};
+   {
+   
+   my_id =(long)(uintptr_t)(liblock_execute_operation(&(G_Memory->count_lock), (void *)(uintptr_t)(NULL),
+                             &function195));
+   }
 
 /* POSSIBLE ENHANCEMENT:  Here is where one might pin processes to
    processors to avoid migration */
diff -u -p a/codes/apps/ocean/contiguous_partitions/decs.h b/codes/apps/ocean/contiguous_partitions/decs.h
--- a/codes/apps/ocean/contiguous_partitions/decs.h
+++ b/codes/apps/ocean/contiguous_partitions/decs.h
@@ -73,12 +73,12 @@ extern double ****q_multi;
 extern double ****rhs_multi;
 
 struct locks_struct {
-   pthread_mutex_t idlock;
-   pthread_mutex_t psiailock;
-   pthread_mutex_t psibilock;
-   pthread_mutex_t donelock;
-   pthread_mutex_t error_lock;
-   pthread_mutex_t bar_lock;
+   liblock_lock_t idlock;
+   liblock_lock_t psiailock;
+   liblock_lock_t psibilock;
+   liblock_lock_t donelock;
+   liblock_lock_t error_lock;
+   liblock_lock_t bar_lock;
 };
 
 extern struct locks_struct *locks;
diff -u -p a/codes/apps/ocean/contiguous_partitions/subblock.c b/codes/apps/ocean/contiguous_partitions/subblock.c
--- a/codes/apps/ocean/contiguous_partitions/subblock.c
+++ b/codes/apps/ocean/contiguous_partitions/subblock.c
@@ -17,9 +17,17 @@
 
 
 #include <pthread.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <sys/time.h>
 #include <unistd.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <malloc.h>
 extern pthread_t PThreadTable[];
 
diff -u -p a/codes/apps/ocean/contiguous_partitions/slave1.c b/codes/apps/ocean/contiguous_partitions/slave1.c
--- a/codes/apps/ocean/contiguous_partitions/slave1.c
+++ b/codes/apps/ocean/contiguous_partitions/slave1.c
@@ -21,9 +21,17 @@
 
 
 #include <pthread.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <sys/time.h>
 #include <unistd.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <malloc.h>
 extern pthread_t PThreadTable[];
 
@@ -32,8 +40,37 @@ extern pthread_t PThreadTable[];
 #include <math.h>
 #include <time.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include "decs.h"
 
+union instance12 {struct input10{double psibipriv;} input10;};
+void * function13(void *ctx11);
+void *function13(void *ctx11) {
+   {
+      struct input10 *incontext8=&(((union instance12 *)ctx11)->input10);
+      double psibipriv=incontext8->psibipriv;
+      {
+         global->psibi = global->psibi + psibipriv;
+      }
+      return NULL;
+   }
+}
+
+void * function6(void *ctx4);
+void *function6(void *ctx4) {
+   {
+      long procid;
+      {
+         procid = global->id;
+         global->id = global->id + 1;
+      }
+      return (void *)(uintptr_t)procid;
+   }
+}
+
 void slave()
 {
    long i;
@@ -83,10 +120,10 @@ void slave()
 
    ressqr = lev_res[numlev-1] * lev_res[numlev-1];
 
-   {pthread_mutex_lock(&(locks->idlock));}
-     procid = global->id;
-     global->id = global->id+1;
-   {pthread_mutex_unlock(&(locks->idlock));}
+   {
+   
+   procid =(long)(uintptr_t)(liblock_execute_operation(&(locks->idlock), (void *)(uintptr_t)(NULL), &function6));
+   }
 
 #if defined(MULTIPLE_BARRIERS)
    {
@@ -537,9 +574,13 @@ eof(double) +
    private and shared sum method avoids accessing the shared
    variable psibi once for every element of the matrix.  */
 
-   {pthread_mutex_lock(&(locks->psibilock));}
-     global->psibi = global->psibi + psibipriv;
-   {pthread_mutex_unlock(&(locks->psibilock));}
+   { union instance12 instance12 = {
+      {
+         psibipriv,
+      },
+   };
+   
+   liblock_execute_operation(&(locks->psibilock), (void *)(uintptr_t)(&instance12), &function13); }
 
 /* initialize psim matrices
 
diff -u -p a/codes/apps/ocean/contiguous_partitions/jacobcalc2.c b/codes/apps/ocean/contiguous_partitions/jacobcalc2.c
--- a/codes/apps/ocean/contiguous_partitions/jacobcalc2.c
+++ b/codes/apps/ocean/contiguous_partitions/jacobcalc2.c
@@ -20,9 +20,17 @@
 
 
 #include <pthread.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <sys/time.h>
 #include <unistd.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <malloc.h>
 extern pthread_t PThreadTable[];
 
diff -u -p a/codes/apps/ocean/contiguous_partitions/slave2.c b/codes/apps/ocean/contiguous_partitions/slave2.c
--- a/codes/apps/ocean/contiguous_partitions/slave2.c
+++ b/codes/apps/ocean/contiguous_partitions/slave2.c
@@ -21,9 +21,17 @@
 
 
 #include <pthread.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <sys/time.h>
 #include <unistd.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <malloc.h>
 extern pthread_t PThreadTable[];
 
@@ -32,8 +40,25 @@ extern pthread_t PThreadTable[];
 #include <math.h>
 #include <time.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include "decs.h"
 
+union instance19 {struct input17{double psiaipriv;} input17;};
+void * function20(void *ctx18);
+void *function20(void *ctx18) {
+   {
+      struct input17 *incontext15=&(((union instance19 *)ctx18)->input17);
+      double psiaipriv=incontext15->psiaipriv;
+      {
+         global->psiai = global->psiai + psiaipriv;
+      }
+      return NULL;
+   }
+}
+
 void slave2(long procid, long firstrow, long lastrow, long numrows, long firstcol, long lastcol, long numcols)
 {
    long i;
@@ -908,9 +933,13 @@ void slave2(long procid, long firstrow, 
 /* after computing its private sum, every process adds that to the
    shared running sum psiai  */
 
-   {pthread_mutex_lock(&(locks->psiailock));}
-   global->psiai = global->psiai + psiaipriv;
-   {pthread_mutex_unlock(&(locks->psiailock));}
+   { union instance19 instance19 = {
+      {
+         psiaipriv,
+      },
+   };
+   
+   liblock_execute_operation(&(locks->psiailock), (void *)(uintptr_t)(&instance19), &function20); }
 #if defined(MULTIPLE_BARRIERS)
    {
 	pthread_barrier_wait(&(bars->sl_phase_7));
diff -u -p a/codes/apps/ocean/contiguous_partitions/jacobcalc.c b/codes/apps/ocean/contiguous_partitions/jacobcalc.c
--- a/codes/apps/ocean/contiguous_partitions/jacobcalc.c
+++ b/codes/apps/ocean/contiguous_partitions/jacobcalc.c
@@ -20,9 +20,17 @@
 
 
 #include <pthread.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <sys/time.h>
 #include <unistd.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <malloc.h>
 extern pthread_t PThreadTable[];
 
diff -u -p a/codes/apps/ocean/contiguous_partitions/multi.c b/codes/apps/ocean/contiguous_partitions/multi.c
--- a/codes/apps/ocean/contiguous_partitions/multi.c
+++ b/codes/apps/ocean/contiguous_partitions/multi.c
@@ -22,9 +22,17 @@
 
 
 #include <pthread.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <sys/time.h>
 #include <unistd.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <malloc.h>
 extern pthread_t PThreadTable[];
 
@@ -33,8 +41,27 @@ extern pthread_t PThreadTable[];
 #include <math.h>
 #include <time.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include "decs.h"
 
+union instance26 {struct input24{double local_err;} input24;};
+void * function27(void *ctx25);
+void *function27(void *ctx25) {
+   {
+      struct input24 *incontext22=&(((union instance26 *)ctx25)->input24);
+      double local_err=incontext22->local_err;
+      {
+         if (local_err > multi->err_multi) {
+            multi->err_multi = local_err;
+         }
+      }
+      return NULL;
+   }
+}
+
 /* perform multigrid (w cycles)                                     */
 void multig(long my_id)
 {
@@ -108,11 +135,13 @@ void multig(long my_id)
 
 /* update the global error if necessary                         */
 
-     {pthread_mutex_lock(&(locks->error_lock));}
-     if (local_err > multi->err_multi) {
-       multi->err_multi = local_err;
-     }
-     {pthread_mutex_unlock(&(locks->error_lock));}
+     { union instance26 instance26 = {
+        {
+           local_err,
+        },
+     };
+     
+     liblock_execute_operation(&(locks->error_lock), (void *)(uintptr_t)(&instance26), &function27); }
 
 /* a single relaxation sweep at the finest level is one unit of    */
 /* work                                                            */
diff -u -p a/codes/apps/ocean/contiguous_partitions/main.c b/codes/apps/ocean/contiguous_partitions/main.c
--- a/codes/apps/ocean/contiguous_partitions/main.c
+++ b/codes/apps/ocean/contiguous_partitions/main.c
@@ -42,9 +42,17 @@
 
 
 #include <pthread.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <sys/time.h>
 #include <unistd.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <malloc.h>
 /** +EDIT */
 //#define MAX_THREADS 32
@@ -72,6 +80,10 @@ pthread_t PThreadTable[MAX_THREADS];
 #include <math.h>
 #include <time.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include "decs.h"
 
 struct multi_struct *multi;
@@ -426,12 +438,12 @@ int main(int argc, char *argv[])
    locks = (struct locks_struct *) valloc(sizeof(struct locks_struct));;
    bars = (struct bars_struct *) valloc(sizeof(struct bars_struct));;
 
-   pthread_mutex_init(&(locks->idlock), NULL);
-   pthread_mutex_init(&(locks->psiailock), NULL);
-   pthread_mutex_init(&(locks->psibilock), NULL);
-   pthread_mutex_init(&(locks->donelock), NULL);
-   pthread_mutex_init(&(locks->error_lock), NULL);
-   pthread_mutex_init(&(locks->bar_lock), NULL);
+   liblock_lock_init(TYPE_NOINFO, ARG_NOINFO, &(locks->idlock), NULL);
+   liblock_lock_init(TYPE_NOINFO, ARG_NOINFO, &(locks->psiailock), NULL);
+   liblock_lock_init(TYPE_NOINFO, ARG_NOINFO, &(locks->psibilock), NULL);
+   liblock_lock_init(TYPE_NOINFO, ARG_NOINFO, &(locks->donelock), NULL);
+   liblock_lock_init(TYPE_NOINFO, ARG_NOINFO, &(locks->error_lock), NULL);
+   liblock_lock_init(TYPE_NOINFO, ARG_NOINFO, &(locks->bar_lock), NULL);
 
 #if defined(MULTIPLE_BARRIERS)
    {pthread_barrier_init(&(bars->iteration), NULL, nprocs);}
@@ -496,7 +508,7 @@ int main(int argc, char *argv[])
 	long	i, Error;
 
 	for (i = 0; i < (nprocs) - 1; i++) {
-		Error = pthread_create(&PThreadTable[i], NULL, (void * (*)(void *))(slave), NULL);
+		Error = liblock_thread_create(&PThreadTable[i], NULL, (void * (*)(void *))(slave), NULL);
 		if (Error != 0) {
 			printf("Error in pthread_create().\n");
 			exit(-1);
diff -u -p a/codes/apps/ocean/contiguous_partitions/linkup.c b/codes/apps/ocean/contiguous_partitions/linkup.c
--- a/codes/apps/ocean/contiguous_partitions/linkup.c
+++ b/codes/apps/ocean/contiguous_partitions/linkup.c
@@ -20,9 +20,17 @@
 
 
 #include <pthread.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <sys/time.h>
 #include <unistd.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <malloc.h>
 extern pthread_t PThreadTable[];
 
diff -u -p a/codes/apps/ocean/contiguous_partitions/laplacalc.c b/codes/apps/ocean/contiguous_partitions/laplacalc.c
--- a/codes/apps/ocean/contiguous_partitions/laplacalc.c
+++ b/codes/apps/ocean/contiguous_partitions/laplacalc.c
@@ -19,9 +19,17 @@
 
 
 #include <pthread.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <sys/time.h>
 #include <unistd.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <malloc.h>
 extern pthread_t PThreadTable[];
 
diff -u -p a/codes/apps/ocean/non_contiguous_partitions/decs.h b/codes/apps/ocean/non_contiguous_partitions/decs.h
--- a/codes/apps/ocean/non_contiguous_partitions/decs.h
+++ b/codes/apps/ocean/non_contiguous_partitions/decs.h
@@ -26,9 +26,17 @@
 
 
 #include <pthread.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <sys/time.h>
 #include <unistd.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <malloc.h>
 extern pthread_t PThreadTable[];
 
@@ -105,12 +113,12 @@ struct multi_struct {
 };
 
 struct locks_struct {
-   pthread_mutex_t idlock;
-   pthread_mutex_t psiailock;
-   pthread_mutex_t psibilock;
-   pthread_mutex_t donelock;
-   pthread_mutex_t error_lock;
-   pthread_mutex_t bar_lock;
+   liblock_lock_t idlock;
+   liblock_lock_t psiailock;
+   liblock_lock_t psibilock;
+   liblock_lock_t donelock;
+   liblock_lock_t error_lock;
+   liblock_lock_t bar_lock;
 };
 
 struct bars_struct {
diff -u -p a/codes/apps/ocean/non_contiguous_partitions/slave1.c b/codes/apps/ocean/non_contiguous_partitions/slave1.c
--- a/codes/apps/ocean/non_contiguous_partitions/slave1.c
+++ b/codes/apps/ocean/non_contiguous_partitions/slave1.c
@@ -23,9 +23,38 @@
 #include <math.h>
 #include <time.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 
 #include "decs.h"
 
+union instance40 {struct input38{double psibipriv;} input38;};
+void * function41(void *ctx39);
+void *function41(void *ctx39) {
+   {
+      struct input38 *incontext36=&(((union instance40 *)ctx39)->input38);
+      double psibipriv=incontext36->psibipriv;
+      {
+         global->psibi = global->psibi + psibipriv;
+      }
+      return NULL;
+   }
+}
+
+void * function34(void *ctx32);
+void *function34(void *ctx32) {
+   {
+      long procid;
+      {
+         procid = global->id;
+         global->id = global->id + 1;
+      }
+      return (void *)(uintptr_t)procid;
+   }
+}
+
 void slave()
 {
    long i;
@@ -68,10 +97,10 @@ void slave()
 
    ressqr = lev_res[numlev-1] * lev_res[numlev-1];
 
-   {pthread_mutex_lock(&(locks->idlock));}
-     procid = global->id;
-     global->id = global->id+1;
-   {pthread_mutex_unlock(&(locks->idlock));}
+   {
+   
+   procid =(long)(uintptr_t)(liblock_execute_operation(&(locks->idlock), (void *)(uintptr_t)(NULL), &function34));
+   }
 
 /* POSSIBLE ENHANCEMENT:  Here is where one might pin processes to
    processors to avoid migration. */
@@ -360,9 +389,13 @@ void slave()
    private and shared sum method avoids accessing the shared
    variable psibi once for every element of the matrix.  */
 
-   {pthread_mutex_lock(&(locks->psibilock));}
-   global->psibi = global->psibi + psibipriv;
-   {pthread_mutex_unlock(&(locks->psibilock));}
+   { union instance40 instance40 = {
+      {
+         psibipriv,
+      },
+   };
+   
+   liblock_execute_operation(&(locks->psibilock), (void *)(uintptr_t)(&instance40), &function41); }
 
    for(psiindex=0;psiindex<=1;psiindex++) {
      if (procid == MASTER) {
diff -u -p a/codes/apps/ocean/non_contiguous_partitions/slave2.c b/codes/apps/ocean/non_contiguous_partitions/slave2.c
--- a/codes/apps/ocean/non_contiguous_partitions/slave2.c
+++ b/codes/apps/ocean/non_contiguous_partitions/slave2.c
@@ -23,8 +23,25 @@
 #include <math.h>
 #include <time.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include "decs.h"
 
+union instance47 {struct input45{double psiaipriv;} input45;};
+void * function48(void *ctx46);
+void *function48(void *ctx46) {
+   {
+      struct input45 *incontext43=&(((union instance47 *)ctx46)->input45);
+      double psiaipriv=incontext43->psiaipriv;
+      {
+         global->psiai = global->psiai + psiaipriv;
+      }
+      return NULL;
+   }
+}
+
 void slave2(long procid, long firstrow, long lastrow, long numrows, long firstcol, long lastcol, long numcols)
 {
    long i;
@@ -762,9 +779,13 @@ void slave2(long procid, long firstrow, 
 /* after computing its private sum, every process adds that to the
    shared running sum psiai  */
 
-   {pthread_mutex_lock(&(locks->psibilock));}
-   global->psiai = global->psiai + psiaipriv;
-   {pthread_mutex_unlock(&(locks->psibilock));}
+   { union instance47 instance47 = {
+      {
+         psiaipriv,
+      },
+   };
+   
+   liblock_execute_operation(&(locks->psibilock), (void *)(uintptr_t)(&instance47), &function48); }
 #if defined(MULTIPLE_BARRIERS)
    {
 	pthread_barrier_wait(&(bars->sl_phase_7));
diff -u -p a/codes/apps/ocean/non_contiguous_partitions/multi.c b/codes/apps/ocean/non_contiguous_partitions/multi.c
--- a/codes/apps/ocean/non_contiguous_partitions/multi.c
+++ b/codes/apps/ocean/non_contiguous_partitions/multi.c
@@ -24,8 +24,27 @@
 #include <math.h>
 #include <time.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include "decs.h"
 
+union instance54 {struct input52{double local_err;} input52;};
+void * function55(void *ctx53);
+void *function55(void *ctx53) {
+   {
+      struct input52 *incontext50=&(((union instance54 *)ctx53)->input52);
+      double local_err=incontext50->local_err;
+      {
+         if (local_err > multi->err_multi) {
+            multi->err_multi = local_err;
+         }
+      }
+      return NULL;
+   }
+}
+
 /* perform multigrid (w cycles)                                     */
 void multig(long my_id)
 {
@@ -99,11 +118,13 @@ void multig(long my_id)
 
 /* update the global error if necessary                            */
 
-     {pthread_mutex_lock(&(locks->error_lock));}
-     if (local_err > multi->err_multi) {
-       multi->err_multi = local_err;
-     }
-     {pthread_mutex_unlock(&(locks->error_lock));}
+     { union instance54 instance54 = {
+        {
+           local_err,
+        },
+     };
+     
+     liblock_execute_operation(&(locks->error_lock), (void *)(uintptr_t)(&instance54), &function55); }
 
 /* a single relaxation sweep at the finest level is one unit of    */
 /* work                                                            */
diff -u -p a/codes/apps/ocean/non_contiguous_partitions/main.c b/codes/apps/ocean/non_contiguous_partitions/main.c
--- a/codes/apps/ocean/non_contiguous_partitions/main.c
+++ b/codes/apps/ocean/non_contiguous_partitions/main.c
@@ -28,13 +28,25 @@
 #include <math.h>
 #include <time.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include "decs.h"
 
 
 #include <pthread.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <sys/time.h>
 #include <unistd.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <malloc.h>
 /** +EDIT */
 //#define MAX_THREADS 32
@@ -241,12 +253,12 @@ int main(int argc, char *argv[])
    locks = (struct locks_struct *) valloc(sizeof(struct locks_struct));;
    bars = (struct bars_struct *) valloc(sizeof(struct bars_struct));;
 
-   pthread_mutex_init(&(locks->idlock), NULL);
-   pthread_mutex_init(&(locks->psiailock), NULL);
-   pthread_mutex_init(&(locks->psibilock), NULL);
-   pthread_mutex_init(&(locks->donelock), NULL);
-   pthread_mutex_init(&(locks->error_lock), NULL);
-   pthread_mutex_init(&(locks->bar_lock), NULL);
+   liblock_lock_init(TYPE_NOINFO, ARG_NOINFO, &(locks->idlock), NULL);
+   liblock_lock_init(TYPE_NOINFO, ARG_NOINFO, &(locks->psiailock), NULL);
+   liblock_lock_init(TYPE_NOINFO, ARG_NOINFO, &(locks->psibilock), NULL);
+   liblock_lock_init(TYPE_NOINFO, ARG_NOINFO, &(locks->donelock), NULL);
+   liblock_lock_init(TYPE_NOINFO, ARG_NOINFO, &(locks->error_lock), NULL);
+   liblock_lock_init(TYPE_NOINFO, ARG_NOINFO, &(locks->bar_lock), NULL);
 
 #if defined(MULTIPLE_BARRIERS)
    {pthread_barrier_init(&(bars->iteration), NULL, nprocs);}
@@ -465,7 +477,7 @@ int main(int argc, char *argv[])
 	long	i, Error;
 
 	for (i = 0; i < (nprocs) - 1; i++) {
-		Error = pthread_create(&PThreadTable[i], NULL, (void * (*)(void *))(slave), NULL);
+		Error = liblock_thread_create(&PThreadTable[i], NULL, (void * (*)(void *))(slave), NULL);
 		if (Error != 0) {
 			printf("Error in pthread_create().\n");
 			exit(-1);
diff -u -p a/codes/apps/radiosity/smallobj.c b/codes/apps/radiosity/smallobj.c
--- a/codes/apps/radiosity/smallobj.c
+++ b/codes/apps/radiosity/smallobj.c
@@ -26,9 +26,17 @@
 
 
 #include <pthread.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <sys/time.h>
 #include <unistd.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <malloc.h>
 extern pthread_t PThreadTable[];
 ;
@@ -99,7 +107,7 @@ of the program, as well as lobal data st
 
 typedef struct
 {
-    pthread_mutex_t lock;
+    liblock_lock_t lock;
 } Shared_Lock ;
 
 #define SHARED_LOCK_SEG_SIZE (MAX_SHARED_LOCK / 2)
@@ -650,10 +658,10 @@ typedef struct _task {
 typedef struct {
     char pad1[PAGE_SIZE];	 	/* padding to avoid false-sharing
     and allow page-placement */
-    pthread_mutex_t q_lock;
+    liblock_lock_t q_lock;
     Task  *top, *tail ;
     long   n_tasks ;
-    pthread_mutex_t f_lock;
+    liblock_lock_t f_lock;
     long   n_free ;
     Task  *free ;
     char pad2[PAGE_SIZE];	 	/* padding to avoid false-sharing
@@ -921,16 +929,16 @@ typedef struct
 
     /* Task queue */
     /* ***** */ long index;
-    /* ***** */	pthread_mutex_t index_lock;
+    /* ***** */	liblock_lock_t index_lock;
     Task_Queue task_queue[ MAX_TASKQUEUES ] ;
     Task task_buf[ MAX_TASKS ] ;
 
     /* BSP tree root */
-    pthread_mutex_t bsp_tree_lock;
+    liblock_lock_t bsp_tree_lock;
     Patch *bsp_root ;
 
     /* Average radiosity value */
-    pthread_mutex_t avg_radiosity_lock;
+    liblock_lock_t avg_radiosity_lock;
     long   converged ;
     Rgb   prev_total_energy ;
     Rgb   total_energy ;
@@ -938,7 +946,7 @@ typedef struct
     long   iteration_count ;
 
     /* Computation cost estimate */
-    pthread_mutex_t cost_sum_lock;
+    liblock_lock_t cost_sum_lock;
     long cost_sum ;
     long cost_estimate_sum ;
     Patch_Cost patch_cost[ MAX_PATCHES ] ;
@@ -950,34 +958,34 @@ pthread_barrier_t	(barrier);
 
     /* Private varrier */
     long pbar_count ;
-    pthread_mutex_t pbar_lock;
+    liblock_lock_t pbar_lock;
 
     /* Task initializer counter */
     long task_counter ;
-    pthread_mutex_t task_counter_lock;
+    liblock_lock_t task_counter_lock;
 
     /* Resource buffers */
-    pthread_mutex_t free_patch_lock;
+    liblock_lock_t free_patch_lock;
     Patch *free_patch ;
     long   n_total_patches ;
     long   n_free_patches ;
     Patch patch_buf[ MAX_PATCHES ] ;
 
-    pthread_mutex_t free_element_lock;
+    liblock_lock_t free_element_lock;
     Element *free_element ;
     long     n_free_elements ;
     Element element_buf[ MAX_ELEMENTS ] ;
 
-    pthread_mutex_t free_interaction_lock;
+    liblock_lock_t free_interaction_lock;
     Interaction *free_interaction ;
     long         n_free_interactions ;
     Interaction interaction_buf[ MAX_INTERACTIONS ] ;
 
-    pthread_mutex_t free_elemvertex_lock;
+    liblock_lock_t free_elemvertex_lock;
     long         free_elemvertex ;
     ElemVertex  elemvertex_buf[ MAX_ELEMVERTICES ] ;
 
-    pthread_mutex_t free_edge_lock;
+    liblock_lock_t free_edge_lock;
     long   free_edge ;
     Edge  edge_buf[ MAX_EDGES ] ;
 
@@ -1187,7 +1195,7 @@ float vector_length(Vertex *v)
     t1 = v->y * v->y ;
     t2 = v->z * v->z ;
 
-    return( sqrt( t0 + t1 + t2 ) ) ;
+    return(( sqrt( t0 + t1 + t2 ) )) ;
 }
 
 
@@ -1208,7 +1216,7 @@ float distance(Vertex *p1, Vertex *p2)
     v12.y = p2->y - p1->y ;
     v12.z = p2->z - p1->z ;
 
-    return( vector_length( &v12 ) ) ;
+    return(( vector_length( &v12 ) )) ;
 }
 
 /***************************************************************************
@@ -1232,7 +1240,7 @@ float normalize_vector(Vertex *v1, Verte
     v1->y = v2->y * t0 ;
     v1->z = v2->z * t0 ;
 
-    return( length ) ;
+    return(( length )) ;
 }
 
 
@@ -1252,7 +1260,7 @@ float inner_product(Vertex *v1, Vertex *
     ip += v1->y * v2->y ;
     ip += v1->z * v2->z ;
 
-    return( ip ) ;
+    return(( ip )) ;
 }
 
 
@@ -1295,7 +1303,7 @@ float plane_normal(Vertex *vc, Vertex *p
 
     /* Compute cross product and normalize */
     cross_product( vc, &v1, &v2 ) ;
-    return( normalize_vector( vc, vc ) ) ;
+    return(( normalize_vector( vc, vc ) )) ;
 }
 
 
@@ -1409,10 +1417,34 @@ ElemVertex *create_elemvertex(Vertex *p,
     ev_new = get_elemvertex(process_id) ;
     ev_new->p = *p ;
 
-    return( ev_new ) ;
+    return(( ev_new )) ;
 }
 
 
+void * function15(void *ctx13);
+void *function15(void *ctx13) {
+    {
+        int ret3;
+        long process_id=(long)(uintptr_t)ctx13;
+        {
+            ret3 = 0;
+            if (MAX_ELEMVERTICES - global->free_elemvertex < N_ELEMVERTEX_ALLOCATE) {
+                fprintf(stderr, "Fatal:Ran out of ElemVertex buffer\n");
+                ret3 = 0 + 1;
+                goto done4;
+            }
+            sobj_struct[process_id].n_local_free_elemvertex = N_ELEMVERTEX_ALLOCATE;
+            sobj_struct[process_id].local_free_elemvertex = &global->elemvertex_buf[global->free_elemvertex];
+            global->free_elemvertex += N_ELEMVERTEX_ALLOCATE;
+            done4:
+            {
+                
+            }
+        }
+        return (void *)(uintptr_t)ret3;
+    }
+}
+
 /***************************************************************************
 *
 *    get_elemvertex
@@ -1425,23 +1457,23 @@ ElemVertex *create_elemvertex(Vertex *p,
 
 ElemVertex *get_elemvertex(long process_id)
 {
+    int ret3;
     ElemVertex *ev ;
 
     if( sobj_struct[process_id].n_local_free_elemvertex == 0 )
         {
-            {pthread_mutex_lock(&(global->free_elemvertex_lock));};
-            if ( MAX_ELEMVERTICES - global->free_elemvertex
-                < N_ELEMVERTEX_ALLOCATE )
-                {
-                    fprintf( stderr, "Fatal:Ran out of ElemVertex buffer\n" ) ;
-                    {pthread_mutex_unlock(&(global->free_elemvertex_lock));};
-                    exit(1) ;
-                }
-            sobj_struct[process_id].n_local_free_elemvertex = N_ELEMVERTEX_ALLOCATE ;
-            sobj_struct[process_id].local_free_elemvertex
-                = &global->elemvertex_buf[ global->free_elemvertex ] ;
-            global->free_elemvertex += N_ELEMVERTEX_ALLOCATE ;
-            {pthread_mutex_unlock(&(global->free_elemvertex_lock));};
+            {
+            
+            ret3 =(int)(uintptr_t)(liblock_execute_operation(&(global->free_elemvertex_lock),
+                                      (void *)(uintptr_t)(process_id), &function15));
+            }
+            if (ret3) {
+                if (ret3 == 0 + 1)
+                    {
+                        exit(1);
+                    }
+                
+            }
         }
 
     ev = sobj_struct[process_id].local_free_elemvertex++ ;
@@ -1454,7 +1486,7 @@ ElemVertex *get_elemvertex(long process_
     ev->col.b  = 0.0 ;
     ev->weight = 0.0 ;
 
-    return( ev ) ;
+    return(( ev )) ;
 }
 
 
@@ -1473,7 +1505,8 @@ void init_elemvertex(long process_id)
     long ev_cnt ;
 
     /* Initialize global free list */
-    pthread_mutex_init(&(global->free_elemvertex_lock), NULL);;
+    liblock_lock_init(TYPE_NOINFO, ARG_NOINFO,
+                      &(global->free_elemvertex_lock), NULL);;
     global->free_elemvertex = 0 ;
 
     /* Allocate locks */
@@ -1512,8 +1545,10 @@ void foreach_leaf_edge(Edge *edge, long 
 {
     Edge *first, *second ;
 
-    if( edge == 0 )
-        return ;
+    if( edge == 0 ) {
+        
+            return;
+        }
 
     if( (edge->ea == 0) && (edge->eb == 0) )
         func( edge, reverse, arg1, arg2, process_id ) ;
@@ -1552,10 +1587,52 @@ Edge *create_edge(ElemVertex *v1, ElemVe
     enew = get_edge(process_id) ;
     enew->pa = v1 ;
     enew->pb = v2 ;
-    return( enew ) ;
+    return(( enew )) ;
 }
 
 
+union instance21 {struct input19{Edge *e;float a_ratio;long process_id;} input19;};
+void * function22(void *ctx20);
+void *function22(void *ctx20) {
+    {
+        struct input19 *incontext17=&(((union instance21 *)ctx20)->input19);
+        ElemVertex *ev_middle;
+        Edge *e_am;
+        Edge *enew;
+        float b_ratio;
+        int ret5;
+        Edge *e=incontext17->e;
+        float a_ratio=incontext17->a_ratio;
+        long process_id=incontext17->process_id;
+        {
+            ret5 = 0;
+            if (!_LEAF_EDGE(e)) {
+                ret5 = 1 + 1;
+                goto done6;
+            }
+            b_ratio = (float)1.0 - a_ratio;
+            ev_middle = get_elemvertex(process_id);
+            ev_middle->p.x = a_ratio * e->pa->p.x + b_ratio * e->pb->p.x;
+            ev_middle->p.y = a_ratio * e->pa->p.y + b_ratio * e->pb->p.y;
+            ev_middle->p.z = a_ratio * e->pa->p.z + b_ratio * e->pb->p.z;
+            enew = get_edge(process_id);
+            e_am = enew;
+            enew->pa = e->pa;
+            enew->pb = ev_middle;
+            enew = get_edge(process_id);
+            enew->pa = ev_middle;
+            enew->pb = e->pb;
+            e->eb = enew;
+            e->ea = e_am;
+            done6:
+            {
+                
+            }
+        }
+        return (void *)(uintptr_t)ret5;
+    }
+}
+
 /***************************************************************************
 *
 *    subdivide_edge()
@@ -1566,47 +1643,56 @@ Edge *create_edge(ElemVertex *v1, ElemVe
 
 void subdivide_edge(Edge *e, float a_ratio, long process_id)
 {
+    int ret5;
     Edge *enew, *e_am ;
     ElemVertex *ev_middle ;
     float b_ratio ;
 
     /* Lock the element before checking the value */
-    {pthread_mutex_lock(&(e->edge_lock->lock));};
-
-    /* Check if the element already has children */
-    if( ! _LEAF_EDGE(e) )
+    { union instance21 instance21 = {
         {
-            {pthread_mutex_unlock(&(e->edge_lock->lock));};
-            return ;
-        }
-
-    /* Create the subdivision point */
-    b_ratio = (float)1.0 - a_ratio ;
-    ev_middle = get_elemvertex(process_id) ;
-    ev_middle->p.x = a_ratio * e->pa->p.x + b_ratio * e->pb->p.x ;
-    ev_middle->p.y = a_ratio * e->pa->p.y + b_ratio * e->pb->p.y ;
-    ev_middle->p.z = a_ratio * e->pa->p.z + b_ratio * e->pb->p.z ;
-
-    /* (1) Create edge(A-middle) */
-    enew = get_edge(process_id) ;
-    e_am = enew ;
-    enew->pa = e->pa ;
-    enew->pb = ev_middle ;
-
-    /* (2) Create edge(middle-B) */
-    enew = get_edge(process_id) ;
-    enew->pa = ev_middle ;
-    enew->pb = e->pb ;
-    e->eb = enew ;
+            e,
+            a_ratio,
+            process_id,
+        },
+    };
+    
+    ret5 =(int)(uintptr_t)(liblock_execute_operation(&(e->edge_lock->lock), (void *)(uintptr_t)(&instance21), &function22));
+    }
+    if (ret5) {
+        if (ret5 == 1 + 1)
+            {
+                return;
+            }
+        
+    }
+}
 
-    /* Finally, set e->ea */
-    e->ea = e_am ;
 
-    /* Unlock the element */
-    {pthread_mutex_unlock(&(e->edge_lock->lock));};
+void * function29(void *ctx27);
+void *function29(void *ctx27) {
+    {
+        int ret7;
+        long process_id=(long)(uintptr_t)ctx27;
+        {
+            ret7 = 0;
+            if (MAX_EDGES - global->free_edge < N_EDGE_ALLOCATE) {
+                fprintf(stderr, "Fatal:Ran out of Edge buffer\n");
+                ret7 = 2 + 1;
+                goto done8;
+            }
+            sobj_struct[process_id].n_local_free_edge = N_EDGE_ALLOCATE;
+            sobj_struct[process_id].local_free_edge = &global->edge_buf[global->free_edge];
+            global->free_edge += N_EDGE_ALLOCATE;
+            done8:
+            {
+                
+            }
+        }
+        return (void *)(uintptr_t)ret7;
+    }
 }
 
-
 /***************************************************************************
 *
 *    get_edge
@@ -1619,22 +1705,23 @@ void subdivide_edge(Edge *e, float a_rat
 
 Edge *get_edge(long process_id)
 {
+    int ret7;
     Edge *edge ;
 
     if( sobj_struct[process_id].n_local_free_edge == 0 )
         {
-            {pthread_mutex_lock(&(global->free_edge_lock));};
-            if ( MAX_EDGES - global->free_edge < N_EDGE_ALLOCATE )
-                {
-                    fprintf( stderr, "Fatal:Ran out of Edge buffer\n" ) ;
-                    {pthread_mutex_unlock(&(global->free_edge_lock));};
-                    exit(1) ;
-                }
-            sobj_struct[process_id].n_local_free_edge = N_EDGE_ALLOCATE ;
-            sobj_struct[process_id].local_free_edge
-                = &global->edge_buf[ global->free_edge ] ;
-            global->free_edge += N_EDGE_ALLOCATE ;
-            {pthread_mutex_unlock(&(global->free_edge_lock));};
+            {
+            
+            ret7 =(int)(uintptr_t)(liblock_execute_operation(&(global->free_edge_lock), (void *)(uintptr_t)(process_id),
+                                      &function29));
+            }
+            if (ret7) {
+                if (ret7 == 2 + 1)
+                    {
+                        exit(1);
+                    }
+                
+            }
         }
 
     edge = sobj_struct[process_id].local_free_edge++ ;
@@ -1647,7 +1734,7 @@ Edge *get_edge(long process_id)
     edge->ea = 0 ;
     edge->eb = 0 ;
 
-    return( edge ) ;
+    return(( edge )) ;
 }
 
 
@@ -1666,7 +1753,8 @@ void init_edge(long process_id)
     long edge_cnt ;
 
     /* Initialize global free list */
-    pthread_mutex_init(&(global->free_edge_lock), NULL);;
+    liblock_lock_init(TYPE_NOINFO, ARG_NOINFO,
+                      &(global->free_edge_lock), NULL);;
     global->free_edge = 0 ;
 
     /* Allocate locks */
@@ -1707,7 +1795,8 @@ void init_sharedlock(long process_id)
 
     for( i = 0 ; i < MAX_SHARED_LOCK ; i++ )
         {
-            pthread_mutex_init(&(global->sh_lock[i].lock), NULL);;
+            liblock_lock_init(TYPE_NOINFO, ARG_NOINFO,
+                              &(global->sh_lock[i].lock), NULL);;
         }
 
     sobj_struct[process_id].lock_alloc_counter = 0 ;
@@ -1734,11 +1823,11 @@ Shared_Lock *get_sharedlock(long segment
         {
         case SHARED_LOCK_SEG0:
             effective_lock_ctr = sobj_struct[process_id].lock_alloc_counter % SHARED_LOCK_SEG_SIZE ;
-            break ;
+            break;
         case SHARED_LOCK_SEG1:
             effective_lock_ctr = sobj_struct[process_id].lock_alloc_counter % SHARED_LOCK_SEG_SIZE
                 + SHARED_LOCK_SEG_SIZE ;
-            break ;
+            break;
         default:
             effective_lock_ctr = sobj_struct[process_id].lock_alloc_counter ;
         }
@@ -1752,6 +1841,6 @@ Shared_Lock *get_sharedlock(long segment
     if( sobj_struct[process_id].lock_alloc_counter >= MAX_SHARED_LOCK )
         sobj_struct[process_id].lock_alloc_counter = 0 ;
 
-    return( pshl ) ;
+    return(( pshl )) ;
 }
 
diff -u -p a/codes/apps/radiosity/modelman.c b/codes/apps/radiosity/modelman.c
--- a/codes/apps/radiosity/modelman.c
+++ b/codes/apps/radiosity/modelman.c
@@ -29,9 +29,17 @@
 
 
 #include <pthread.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <sys/time.h>
 #include <unistd.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <malloc.h>
 extern pthread_t PThreadTable[];
 ;
@@ -102,7 +110,7 @@ of the program, as well as lobal data st
 
 typedef struct
 {
-    pthread_mutex_t lock;
+    liblock_lock_t lock;
 } Shared_Lock ;
 
 #define SHARED_LOCK_SEG_SIZE (MAX_SHARED_LOCK / 2)
@@ -653,10 +661,10 @@ typedef struct _task {
 typedef struct {
     char pad1[PAGE_SIZE];	 	/* padding to avoid false-sharing
     and allow page-placement */
-    pthread_mutex_t q_lock;
+    liblock_lock_t q_lock;
     Task  *top, *tail ;
     long   n_tasks ;
-    pthread_mutex_t f_lock;
+    liblock_lock_t f_lock;
     long   n_free ;
     Task  *free ;
     char pad2[PAGE_SIZE];	 	/* padding to avoid false-sharing
@@ -924,16 +932,16 @@ typedef struct
 
     /* Task queue */
     /* ***** */ long index;
-    /* ***** */	pthread_mutex_t index_lock;
+    /* ***** */	liblock_lock_t index_lock;
     Task_Queue task_queue[ MAX_TASKQUEUES ] ;
     Task task_buf[ MAX_TASKS ] ;
 
     /* BSP tree root */
-    pthread_mutex_t bsp_tree_lock;
+    liblock_lock_t bsp_tree_lock;
     Patch *bsp_root ;
 
     /* Average radiosity value */
-    pthread_mutex_t avg_radiosity_lock;
+    liblock_lock_t avg_radiosity_lock;
     long   converged ;
     Rgb   prev_total_energy ;
     Rgb   total_energy ;
@@ -941,7 +949,7 @@ typedef struct
     long   iteration_count ;
 
     /* Computation cost estimate */
-    pthread_mutex_t cost_sum_lock;
+    liblock_lock_t cost_sum_lock;
     long cost_sum ;
     long cost_estimate_sum ;
     Patch_Cost patch_cost[ MAX_PATCHES ] ;
@@ -953,34 +961,34 @@ pthread_barrier_t	(barrier);
 
     /* Private varrier */
     long pbar_count ;
-    pthread_mutex_t pbar_lock;
+    liblock_lock_t pbar_lock;
 
     /* Task initializer counter */
     long task_counter ;
-    pthread_mutex_t task_counter_lock;
+    liblock_lock_t task_counter_lock;
 
     /* Resource buffers */
-    pthread_mutex_t free_patch_lock;
+    liblock_lock_t free_patch_lock;
     Patch *free_patch ;
     long   n_total_patches ;
     long   n_free_patches ;
     Patch patch_buf[ MAX_PATCHES ] ;
 
-    pthread_mutex_t free_element_lock;
+    liblock_lock_t free_element_lock;
     Element *free_element ;
     long     n_free_elements ;
     Element element_buf[ MAX_ELEMENTS ] ;
 
-    pthread_mutex_t free_interaction_lock;
+    liblock_lock_t free_interaction_lock;
     Interaction *free_interaction ;
     long         n_free_interactions ;
     Interaction interaction_buf[ MAX_INTERACTIONS ] ;
 
-    pthread_mutex_t free_elemvertex_lock;
+    liblock_lock_t free_elemvertex_lock;
     long         free_elemvertex ;
     ElemVertex  elemvertex_buf[ MAX_ELEMVERTICES ] ;
 
-    pthread_mutex_t free_edge_lock;
+    liblock_lock_t free_edge_lock;
     long   free_edge ;
     Edge  edge_buf[ MAX_EDGES ] ;
 
diff -u -p a/codes/apps/radiosity/visible.c b/codes/apps/radiosity/visible.c
--- a/codes/apps/radiosity/visible.c
+++ b/codes/apps/radiosity/visible.c
@@ -27,9 +27,17 @@
 
 
 #include <pthread.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <sys/time.h>
 #include <unistd.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <malloc.h>
 extern pthread_t PThreadTable[];
 ;
@@ -100,7 +108,7 @@ of the program, as well as lobal data st
 
 typedef struct
 {
-    pthread_mutex_t lock;
+    liblock_lock_t lock;
 } Shared_Lock ;
 
 #define SHARED_LOCK_SEG_SIZE (MAX_SHARED_LOCK / 2)
@@ -651,10 +659,10 @@ typedef struct _task {
 typedef struct {
     char pad1[PAGE_SIZE];	 	/* padding to avoid false-sharing
     and allow page-placement */
-    pthread_mutex_t q_lock;
+    liblock_lock_t q_lock;
     Task  *top, *tail ;
     long   n_tasks ;
-    pthread_mutex_t f_lock;
+    liblock_lock_t f_lock;
     long   n_free ;
     Task  *free ;
     char pad2[PAGE_SIZE];	 	/* padding to avoid false-sharing
@@ -922,16 +930,16 @@ typedef struct
 
     /* Task queue */
     /* ***** */ long index;
-    /* ***** */	pthread_mutex_t index_lock;
+    /* ***** */	liblock_lock_t index_lock;
     Task_Queue task_queue[ MAX_TASKQUEUES ] ;
     Task task_buf[ MAX_TASKS ] ;
 
     /* BSP tree root */
-    pthread_mutex_t bsp_tree_lock;
+    liblock_lock_t bsp_tree_lock;
     Patch *bsp_root ;
 
     /* Average radiosity value */
-    pthread_mutex_t avg_radiosity_lock;
+    liblock_lock_t avg_radiosity_lock;
     long   converged ;
     Rgb   prev_total_energy ;
     Rgb   total_energy ;
@@ -939,7 +947,7 @@ typedef struct
     long   iteration_count ;
 
     /* Computation cost estimate */
-    pthread_mutex_t cost_sum_lock;
+    liblock_lock_t cost_sum_lock;
     long cost_sum ;
     long cost_estimate_sum ;
     Patch_Cost patch_cost[ MAX_PATCHES ] ;
@@ -951,34 +959,34 @@ pthread_barrier_t	(barrier);
 
     /* Private varrier */
     long pbar_count ;
-    pthread_mutex_t pbar_lock;
+    liblock_lock_t pbar_lock;
 
     /* Task initializer counter */
     long task_counter ;
-    pthread_mutex_t task_counter_lock;
+    liblock_lock_t task_counter_lock;
 
     /* Resource buffers */
-    pthread_mutex_t free_patch_lock;
+    liblock_lock_t free_patch_lock;
     Patch *free_patch ;
     long   n_total_patches ;
     long   n_free_patches ;
     Patch patch_buf[ MAX_PATCHES ] ;
 
-    pthread_mutex_t free_element_lock;
+    liblock_lock_t free_element_lock;
     Element *free_element ;
     long     n_free_elements ;
     Element element_buf[ MAX_ELEMENTS ] ;
 
-    pthread_mutex_t free_interaction_lock;
+    liblock_lock_t free_interaction_lock;
     Interaction *free_interaction ;
     long         n_free_interactions ;
     Interaction interaction_buf[ MAX_INTERACTIONS ] ;
 
-    pthread_mutex_t free_elemvertex_lock;
+    liblock_lock_t free_elemvertex_lock;
     long         free_elemvertex ;
     ElemVertex  elemvertex_buf[ MAX_ELEMVERTICES ] ;
 
-    pthread_mutex_t free_edge_lock;
+    liblock_lock_t free_edge_lock;
     long   free_edge ;
     Edge  edge_buf[ MAX_EDGES ] ;
 
@@ -1401,10 +1409,12 @@ long v_intersect(Patch *patch, Vertex *p
         sh = nsh;
     }
 
-    if ((nc % 2) == 0)
-        return(0);
+    if ((nc % 2) == 0) {
+        
+            return((0));
+        }
     else {
-        return(1);
+        return((1));
     }
 
 }
@@ -1452,12 +1462,16 @@ long traverse_bsp(Patch *src_node, Verte
 
 
     /* (1) Check patch cache */
-    if( check_patch_cache( p, ray, r_min, r_max, process_id ) )
-        return( 1 ) ;
+    if( check_patch_cache( p, ray, r_min, r_max, process_id ) ) {
+        
+            return(( 1 )) ;
+        }
 
     /* (2) Check S+(src_node) */
-    if( traverse_subtree( src_node->bsp_positive, p, ray, r_min, r_max, process_id ) )
-        return( 1 ) ;
+    if( traverse_subtree( src_node->bsp_positive, p, ray, r_min, r_max, process_id ) ) {
+        
+            return(( 1 )) ;
+        }
 
     /* (3) Continue in-order traversal till root is encountered */
     for( parent = src_node->bsp_parent, visited_child = src_node ;
@@ -1468,8 +1482,10 @@ long traverse_bsp(Patch *src_node, Verte
             advice = intersection_type( parent, p, ray, &t, r_min, r_max ) ;
             if( (advice != POSITIVE_SUBTREE_ONLY) && (advice != NEGATIVE_SUBTREE_ONLY) )
                 {
-                    if( test_intersection( parent, p, ray, t, process_id ) )
-                        return( 1 ) ;
+                    if( test_intersection( parent, p, ray, t, process_id ) ) {
+                        
+                            return(( 1 )) ;
+                        }
 
                     r_min = t - VIS_RANGE_MARGIN ;
                 }
@@ -1477,17 +1493,21 @@ long traverse_bsp(Patch *src_node, Verte
             /* Traverse unvisited subtree of the node */
             if(   (parent->bsp_positive == visited_child) && (advice != POSITIVE_SUBTREE_ONLY) )
                 {
-                    if( traverse_subtree( parent->bsp_negative, p, ray, r_min, r_max, process_id ) )
-                        return( 1 ) ;
+                    if( traverse_subtree( parent->bsp_negative, p, ray, r_min, r_max, process_id ) ) {
+                        
+                            return(( 1 )) ;
+                        }
                 }
             else if( (parent->bsp_positive != visited_child) && (advice != NEGATIVE_SUBTREE_ONLY) )
                 {
-                    if( traverse_subtree( parent->bsp_positive, p, ray, r_min, r_max, process_id ) )
-                        return( 1 ) ;
+                    if( traverse_subtree( parent->bsp_positive, p, ray, r_min, r_max, process_id ) ) {
+                        
+                            return(( 1 )) ;
+                        }
                 }
         }
 
-    return( 0 ) ;
+    return(( 0 )) ;
 }
 
 
@@ -1511,44 +1531,60 @@ long traverse_subtree(Patch *node, Verte
     long advice ;
 
 
-    if( node == 0 )
-        return( 0 ) ;
+    if( node == 0 ) {
+        
+            return(( 0 )) ;
+        }
 
     advice = intersection_type( node, p, ray, &t, r_min, r_max ) ;
     if( advice == POSITIVE_SIDE_FIRST )
         {
             /* The ray is approaching from the positive side of the patch */
             if( traverse_subtree( node->bsp_positive, p, ray,
-                                 r_min, t + VIS_RANGE_MARGIN, process_id ) )
-                return( 1 ) ;
+                                 r_min, t + VIS_RANGE_MARGIN, process_id ) ) {
+                
+                    return(( 1 )) ;
+                }
 
-            if( test_intersection( node, p, ray, t, process_id ) )
-                return( 1 ) ;
-            return( traverse_subtree( node->bsp_negative, p, ray,
-                                     t - VIS_RANGE_MARGIN, r_max, process_id ) ) ;
+            if( test_intersection( node, p, ray, t, process_id ) ) {
+                
+                    return(( 1 )) ;
+                }
+            return(( traverse_subtree( node->bsp_negative, p, ray,
+                                     t - VIS_RANGE_MARGIN, r_max, process_id ) )) ;
         }
     else if( advice == NEGATIVE_SIDE_FIRST )
         {
             /* The ray is approaching from the negative side of the patch */
             if( traverse_subtree( node->bsp_negative, p, ray,
-                                 r_min, t + VIS_RANGE_MARGIN, process_id ) )
-                return( 1 ) ;
-            if( test_intersection( node, p, ray, t, process_id ) )
-                return( 1 ) ;
-
-            return( traverse_subtree( node->bsp_positive, p, ray,
-                                     t - VIS_RANGE_MARGIN, r_max, process_id ) ) ;
+                                 r_min, t + VIS_RANGE_MARGIN, process_id ) ) {
+                
+                    return(( 1 )) ;
+                }
+            if( test_intersection( node, p, ray, t, process_id ) ) {
+                
+                    return(( 1 )) ;
+                }
+
+            return(( traverse_subtree( node->bsp_positive, p, ray,
+                                     t - VIS_RANGE_MARGIN, r_max, process_id ) )) ;
         }
 
-    else if( advice == POSITIVE_SUBTREE_ONLY )
-        return( traverse_subtree( node->bsp_positive, p, ray,
-                                 r_min, r_max, process_id ) ) ;
-    else if( advice == NEGATIVE_SUBTREE_ONLY )
-        return( traverse_subtree( node->bsp_negative, p, ray,
-                                 r_min, r_max, process_id ) ) ;
+    else if( advice == POSITIVE_SUBTREE_ONLY ) {
+        
+            return(( traverse_subtree( node->bsp_positive, p, ray,
+                                 r_min, r_max, process_id ) )) ;
+        }
+    else if( advice == NEGATIVE_SUBTREE_ONLY ) {
+        
+            return(( traverse_subtree( node->bsp_negative, p, ray,
+                                 r_min, r_max, process_id ) )) ;
+        }
     else
         /* On the plane */
-        return( 1 ) ;
+        {
+            return(( 1 )) ;
+        }
 }
 
 
@@ -1593,12 +1629,16 @@ long intersection_type(Patch  *patch, Ve
 
     if( (-(float)F_ZERO < r_dot_n) && (r_dot_n < (float)F_ZERO) )
         {
-            if( dist > (float)F_COPLANAR )
-                return( POSITIVE_SUBTREE_ONLY ) ;
-            else if( dist < -F_COPLANAR )
-                return( NEGATIVE_SUBTREE_ONLY ) ;
+            if( dist > (float)F_COPLANAR ) {
+                
+                    return(( POSITIVE_SUBTREE_ONLY )) ;
+                }
+            else if( dist < -F_COPLANAR ) {
+                
+                    return(( NEGATIVE_SUBTREE_ONLY )) ;
+                }
 
-            return( ON_THE_PLANE ) ;
+            return(( ON_THE_PLANE )) ;
         }
 
     t = -dist / r_dot_n ;
@@ -1606,24 +1646,36 @@ long intersection_type(Patch  *patch, Ve
 
     if( t < range_min )
         {
-            if( r_dot_n >= 0 )
-                return( POSITIVE_SUBTREE_ONLY ) ;
+            if( r_dot_n >= 0 ) {
+                
+                    return(( POSITIVE_SUBTREE_ONLY )) ;
+                }
             else
-                return( NEGATIVE_SUBTREE_ONLY ) ;
+                {
+                    return(( NEGATIVE_SUBTREE_ONLY )) ;
+                }
         }
     else if ( t > range_max )
         {
-            if( r_dot_n >= 0 )
-                return( NEGATIVE_SUBTREE_ONLY ) ;
+            if( r_dot_n >= 0 ) {
+                
+                    return(( NEGATIVE_SUBTREE_ONLY )) ;
+                }
             else
-                return( POSITIVE_SUBTREE_ONLY ) ;
+                {
+                    return(( POSITIVE_SUBTREE_ONLY )) ;
+                }
         }
     else
         {
-            if( r_dot_n >= 0 )
-                return( NEGATIVE_SIDE_FIRST ) ;
+            if( r_dot_n >= 0 ) {
+                
+                    return(( NEGATIVE_SIDE_FIRST )) ;
+                }
             else
-                return( POSITIVE_SIDE_FIRST ) ;
+                {
+                    return(( POSITIVE_SIDE_FIRST )) ;
+                }
         }
 }
 
@@ -1642,20 +1694,22 @@ long test_intersection(Patch *patch, Ver
     if( patch == vis_struct[process_id].v_dest_patch )
         {
             vis_struct[process_id].pool_dst_hits++ ;
-            return( 1 ) ;
+            return(( 1 )) ;
         }
 
-    if( patch_tested( patch, process_id ) )
-        return( 0 ) ;
+    if( patch_tested( patch, process_id ) ) {
+        
+            return(( 0 )) ;
+        }
 
     if( v_intersect( patch, p, ray, tval ) )
         {
             /* Store it in the patch-cache */
             update_patch_cache( patch, process_id ) ;
-            return( 1 ) ;
+            return(( 1 )) ;
         }
 
-    return( 0 ) ;
+    return(( 0 )) ;
 }
 
 
@@ -1725,12 +1779,12 @@ long check_patch_cache(Vertex *p, Ray *r
                             vis_struct[process_id].patch_cache[ i ] = temp ;
                         }
 
-                    return( 1 ) ;
+                    return(( 1 )) ;
                 }
         }
 
 
-    return( 0 ) ;
+    return(( 0 )) ;
 }
 
 
@@ -1750,11 +1804,13 @@ long patch_tested(Patch *p, long process
 
     for( i = 0 ; i < PATCH_CACHE_SIZE ; i++ )
         {
-            if( p == vis_struct[process_id].patch_cache[i] )
-                return( 1 ) ;
+            if( p == vis_struct[process_id].patch_cache[i] ) {
+                
+                    return(( 1 )) ;
+                }
         }
 
-    return( 0 ) ;
+    return(( 0 )) ;
 }
 
 
@@ -1821,7 +1877,7 @@ float visibility(Element *e1, Element *e
         vis_struct[process_id].pool_dst_hits = 1 ;
     }
 
-    return( (float)vis_struct[process_id].pool_dst_hits / (float)n_rays ) ;
+    return(( (float)vis_struct[process_id].pool_dst_hits / (float)n_rays )) ;
 }
 
 
@@ -1852,6 +1908,36 @@ void compute_visibility_values(Element *
 }
 
 
+union instance42 {struct input40{Patch_Cost *pc;long process_id;} input40;};
+union instance35 {struct input33{Element *elem;long n_inter;} input33;};
+void * function43(void *ctx41);
+void *function43(void *ctx41) {
+{
+struct input40 *incontext38=&(((union instance42 *)ctx41)->input40);
+Patch_Cost *pc=incontext38->pc;
+long process_id=incontext38->process_id;
+{
+pc->n_bsp_node += vis_struct[process_id].total_bsp_nodes_visited;
+}
+return NULL;
+}
+}
+
+void * function36(void *ctx34);
+void *function36(void *ctx34) {
+{
+struct input33 *incontext31=&(((union instance35 *)ctx34)->input33);
+long new_vis_undef_count;
+Element *elem=incontext31->elem;
+long n_inter=incontext31->n_inter;
+{
+elem->n_vis_undef_inter -= n_inter;
+new_vis_undef_count = elem->n_vis_undef_inter;
+}
+return (void *)(uintptr_t)new_vis_undef_count;
+}
+}
+
 /*****************************************************************
  *
  *    visibility_task()
@@ -1873,16 +1959,28 @@ void visibility_task(Element *elem, Inte
     compute_visibility_values( elem, inter, n_inter, process_id ) ;
 
     /* Change visibility undef count */
-    {pthread_mutex_lock(&(elem->elem_lock->lock));};
-    elem->n_vis_undef_inter -= n_inter ;
-    new_vis_undef_count = elem->n_vis_undef_inter ;
-    {pthread_mutex_unlock(&(elem->elem_lock->lock));};
+    { union instance35 instance35 = {
+    {
+    elem,
+    n_inter,
+    },
+    };
+    
+    new_vis_undef_count =(long)(uintptr_t)(liblock_execute_operation(&(elem->elem_lock->lock), (void *)(uintptr_t)(&instance35),
+			      &function36));
+    }
 
 #if PATCH_ASSIGNMENT == PATCH_ASSIGNMENT_COSTBASED
     pc = &global->patch_cost[ elem->patch->seq_no ] ;
-    {pthread_mutex_lock(&(pc->cost_lock->lock));};
-    pc->n_bsp_node += vis_struct[process_id].total_bsp_nodes_visited ;
-    {pthread_mutex_unlock(&(pc->cost_lock->lock));};
+    { union instance42 instance42 = {
+    {
+    pc,
+    process_id,
+    },
+    };
+    
+    liblock_execute_operation(&(pc->cost_lock->lock), (void *)(uintptr_t)(&instance42),
+			      &function43); }
 #endif
 
     /* Call continuation if this is the last task finished. */
diff -u -p a/codes/apps/radiosity/display.c b/codes/apps/radiosity/display.c
--- a/codes/apps/radiosity/display.c
+++ b/codes/apps/radiosity/display.c
@@ -19,9 +19,17 @@
 
 
 #include <pthread.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <sys/time.h>
 #include <unistd.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <malloc.h>
 extern pthread_t PThreadTable[];
 ;
@@ -92,7 +100,7 @@ of the program, as well as lobal data st
 
 typedef struct
 {
-    pthread_mutex_t lock;
+    liblock_lock_t lock;
 } Shared_Lock ;
 
 #define SHARED_LOCK_SEG_SIZE (MAX_SHARED_LOCK / 2)
@@ -643,10 +651,10 @@ typedef struct _task {
 typedef struct {
     char pad1[PAGE_SIZE];	 	/* padding to avoid false-sharing
     and allow page-placement */
-    pthread_mutex_t q_lock;
+    liblock_lock_t q_lock;
     Task  *top, *tail ;
     long   n_tasks ;
-    pthread_mutex_t f_lock;
+    liblock_lock_t f_lock;
     long   n_free ;
     Task  *free ;
     char pad2[PAGE_SIZE];	 	/* padding to avoid false-sharing
@@ -914,16 +922,16 @@ typedef struct
 
     /* Task queue */
     /* ***** */ long index;
-    /* ***** */	pthread_mutex_t index_lock;
+    /* ***** */	liblock_lock_t index_lock;
     Task_Queue task_queue[ MAX_TASKQUEUES ] ;
     Task task_buf[ MAX_TASKS ] ;
 
     /* BSP tree root */
-    pthread_mutex_t bsp_tree_lock;
+    liblock_lock_t bsp_tree_lock;
     Patch *bsp_root ;
 
     /* Average radiosity value */
-    pthread_mutex_t avg_radiosity_lock;
+    liblock_lock_t avg_radiosity_lock;
     long   converged ;
     Rgb   prev_total_energy ;
     Rgb   total_energy ;
@@ -931,7 +939,7 @@ typedef struct
     long   iteration_count ;
 
     /* Computation cost estimate */
-    pthread_mutex_t cost_sum_lock;
+    liblock_lock_t cost_sum_lock;
     long cost_sum ;
     long cost_estimate_sum ;
     Patch_Cost patch_cost[ MAX_PATCHES ] ;
@@ -943,34 +951,34 @@ pthread_barrier_t	(barrier);
 
     /* Private varrier */
     long pbar_count ;
-    pthread_mutex_t pbar_lock;
+    liblock_lock_t pbar_lock;
 
     /* Task initializer counter */
     long task_counter ;
-    pthread_mutex_t task_counter_lock;
+    liblock_lock_t task_counter_lock;
 
     /* Resource buffers */
-    pthread_mutex_t free_patch_lock;
+    liblock_lock_t free_patch_lock;
     Patch *free_patch ;
     long   n_total_patches ;
     long   n_free_patches ;
     Patch patch_buf[ MAX_PATCHES ] ;
 
-    pthread_mutex_t free_element_lock;
+    liblock_lock_t free_element_lock;
     Element *free_element ;
     long     n_free_elements ;
     Element element_buf[ MAX_ELEMENTS ] ;
 
-    pthread_mutex_t free_interaction_lock;
+    liblock_lock_t free_interaction_lock;
     Interaction *free_interaction ;
     long         n_free_interactions ;
     Interaction interaction_buf[ MAX_INTERACTIONS ] ;
 
-    pthread_mutex_t free_elemvertex_lock;
+    liblock_lock_t free_elemvertex_lock;
     long         free_elemvertex ;
     ElemVertex  elemvertex_buf[ MAX_ELEMVERTICES ] ;
 
-    pthread_mutex_t free_edge_lock;
+    liblock_lock_t free_edge_lock;
     long   free_edge ;
     Edge  edge_buf[ MAX_EDGES ] ;
 
@@ -1147,6 +1155,60 @@ static void _display_shaded_triangle(Ele
 static void _disp_interactions(Element *elem, Interaction *inter, long mode, long process_id);
 static void _ps_disp_interactions(Element *elem, Interaction *inter, long mode, long process_id);
 
+void * function64(void *ctx62);
+void *function64(void *ctx62) {
+    {
+        float inv_weight;
+        Element *elem=(Element *)(uintptr_t)ctx62;
+        {
+            if (elem->ev3->weight != 1.0) {
+                inv_weight = (float)1.0 / elem->ev3->weight;
+                elem->ev3->col.r *= inv_weight;
+                elem->ev3->col.g *= inv_weight;
+                elem->ev3->col.b *= inv_weight;
+                elem->ev3->weight = 1.0;
+            }
+        }
+        return NULL;
+    }
+}
+
+void * function57(void *ctx55);
+void *function57(void *ctx55) {
+    {
+        float inv_weight;
+        Element *elem=(Element *)(uintptr_t)ctx55;
+        {
+            if (elem->ev2->weight != 1.0) {
+                inv_weight = (float)1.0 / elem->ev2->weight;
+                elem->ev2->col.r *= inv_weight;
+                elem->ev2->col.g *= inv_weight;
+                elem->ev2->col.b *= inv_weight;
+                elem->ev2->weight = 1.0;
+            }
+        }
+        return NULL;
+    }
+}
+
+void * function50(void *ctx48);
+void *function50(void *ctx48) {
+    {
+        float inv_weight;
+        Element *elem=(Element *)(uintptr_t)ctx48;
+        {
+            if (elem->ev1->weight != 1.0) {
+                inv_weight = (float)1.0 / elem->ev1->weight;
+                elem->ev1->col.r *= inv_weight;
+                elem->ev1->col.g *= inv_weight;
+                elem->ev1->col.b *= inv_weight;
+                elem->ev1->weight = 1.0;
+            }
+        }
+        return NULL;
+    }
+}
+
 /************************************************************************
  *
  *    radiosity_averaging
@@ -1165,7 +1227,7 @@ void radiosity_averaging(Element *elem, 
             create_radavg_task( elem->top,    mode, process_id ) ;
             create_radavg_task( elem->right,  mode, process_id ) ;
             create_radavg_task( elem->left,   mode, process_id ) ;
-            return ;
+            return;
         }
 
     else if( mode == RAD_AVERAGING_MODE )
@@ -1183,39 +1245,39 @@ void radiosity_averaging(Element *elem, 
     else
         {
             /* Normalize it */
-            {pthread_mutex_lock(&(elem->ev1->ev_lock->lock));};
-            if( elem->ev1->weight != 1.0 )
-                {
-                    inv_weight = (float)1.0 / elem->ev1->weight  ;
-                    elem->ev1->col.r *= inv_weight ;
-                    elem->ev1->col.g *= inv_weight ;
-                    elem->ev1->col.b *= inv_weight ;
-                    elem->ev1->weight = 1.0 ;
-                }
-            {pthread_mutex_unlock(&(elem->ev1->ev_lock->lock));};
-
-            {pthread_mutex_lock(&(elem->ev2->ev_lock->lock));};
-            if( elem->ev2->weight != 1.0 )
-                {
-                    inv_weight = (float)1.0 / elem->ev2->weight  ;
-                    elem->ev2->col.r *= inv_weight ;
-                    elem->ev2->col.g *= inv_weight ;
-                    elem->ev2->col.b *= inv_weight ;
-                    elem->ev2->weight = 1.0 ;
-                }
-            {pthread_mutex_unlock(&(elem->ev2->ev_lock->lock));};
+            {
+            
+            liblock_execute_operation(&(elem->ev1->ev_lock->lock),
+                                      (void *)(uintptr_t)(elem), &function50); }
+
+            {
+            
+            liblock_execute_operation(&(elem->ev2->ev_lock->lock),
+                                      (void *)(uintptr_t)(elem), &function57); }
+
+            {
+            
+            liblock_execute_operation(&(elem->ev3->ev_lock->lock),
+                                      (void *)(uintptr_t)(elem), &function64); }
+        }
+}
 
-            {pthread_mutex_lock(&(elem->ev3->ev_lock->lock));};
-            if( elem->ev3->weight != 1.0 )
-                {
-                    inv_weight = (float)1.0 / elem->ev3->weight  ;
-                    elem->ev3->col.r *= inv_weight ;
-                    elem->ev3->col.g *= inv_weight ;
-                    elem->ev3->col.b *= inv_weight ;
-                    elem->ev3->weight = 1.0 ;
-                }
-            {pthread_mutex_unlock(&(elem->ev3->ev_lock->lock));};
+union instance70 {struct input68{Element *elem;ElemVertex *ev;float weight;} input68;};
+void * function71(void *ctx69);
+void *function71(void *ctx69) {
+    {
+        struct input68 *incontext66=&(((union instance70 *)ctx69)->input68);
+        Element *elem=incontext66->elem;
+        ElemVertex *ev=incontext66->ev;
+        float weight=incontext66->weight;
+        {
+            ev->col.r += (elem->rad.r * weight);
+            ev->col.g += (elem->rad.g * weight);
+            ev->col.b += (elem->rad.b * weight);
+            ev->weight += weight;
         }
+        return NULL;
+    }
 }
 
 static void add_radiosity_to_vertex(Edge *edge, long reverse, Element *elem, Vertex *p_c, long process_id)
@@ -1231,12 +1293,15 @@ static void add_radiosity_to_vertex(Edge
     weight = (float)1.0 / distance( &ev->p, p_c ) ;
     weight = 1.0 ;
     weight = elem->area ;
-    {pthread_mutex_lock(&(ev->ev_lock->lock));};
-    ev->col.r += (elem->rad.r * weight) ;
-    ev->col.g += (elem->rad.g * weight) ;
-    ev->col.b += (elem->rad.b * weight) ;
-    ev->weight += weight ;
-    {pthread_mutex_unlock(&(ev->ev_lock->lock));};
+    { union instance70 instance70 = {
+        {
+            elem,
+            ev,
+            weight,
+        },
+    };
+    
+    liblock_execute_operation(&(ev->ev_lock->lock), (void *)(uintptr_t)(&instance70), &function71); }
 }
 
 
@@ -1342,8 +1407,10 @@ void display_patch(Patch *patch, long mo
 
     if( mode == DISPLAY_SHADED )
         {
-            if( inner_product( &patch->plane_equ.n, &view_vec ) < F_ZERO )
-                return ;
+            if( inner_product( &patch->plane_equ.n, &view_vec ) < F_ZERO ) {
+                
+                    return;
+                }
 
             p_buf[0] = patch->p1 ;
             p_buf[1] = patch->p2 ;
@@ -1356,8 +1423,10 @@ void display_patch(Patch *patch, long mo
         }
     else if( mode == DISPLAY_FILLED )
         {
-            if( inner_product( &patch->plane_equ.n, &view_vec ) < F_ZERO )
-                return ;
+            if( inner_product( &patch->plane_equ.n, &view_vec ) < F_ZERO ) {
+                
+                    return;
+                }
 
             p_buf[0] = patch->p1 ;
             p_buf[1] = patch->p2 ;
@@ -1397,8 +1466,10 @@ void display_element(Element *element, l
 {
     Vertex p_buf[4] ;
 
-    if( inner_product( &element->patch->plane_equ.n, &view_vec ) < F_ZERO )
-        return ;
+    if( inner_product( &element->patch->plane_equ.n, &view_vec ) < F_ZERO ) {
+        
+            return;
+        }
 
     if( mode == DISPLAY_SHADED )
         {
@@ -1484,8 +1555,10 @@ static void _disp_interactions(Element *
 
     /* Display interactions only with a particular patch */
     if(   (mode == DISPLAY_HALF_INTERACTIONS)
-       && (inter->destination->patch->seq_no >= elem->patch->seq_no ) )
-        return ;
+       && (inter->destination->patch->seq_no >= elem->patch->seq_no ) ) {
+        
+            return;
+        }
 
     /* Compute mid point of the element */
     edst = inter->destination ;
@@ -1578,8 +1651,10 @@ void ps_display_patch(Patch *patch, long
 
     if( mode == DISPLAY_SHADED )
         {
-            if( inner_product( &patch->plane_equ.n, &view_vec ) < F_ZERO )
-                return ;
+            if( inner_product( &patch->plane_equ.n, &view_vec ) < F_ZERO ) {
+                
+                    return;
+                }
             p_buf[0] = patch->p1 ;
             p_buf[1] = patch->p2 ;
             p_buf[2] = patch->p3 ;
@@ -1591,8 +1666,10 @@ void ps_display_patch(Patch *patch, long
         }
     else if( mode == DISPLAY_FILLED )
         {
-            if( inner_product( &patch->plane_equ.n, &view_vec ) < F_ZERO )
-                return ;
+            if( inner_product( &patch->plane_equ.n, &view_vec ) < F_ZERO ) {
+                
+                    return;
+                }
             p_buf[0] = patch->p1 ;
             p_buf[1] = patch->p2 ;
             p_buf[2] = patch->p3 ;
@@ -1637,8 +1714,10 @@ void ps_display_element(Element *element
     if( mode == DISPLAY_SHADED )
         {
             if( inner_product( &element->patch->plane_equ.n, &view_vec )
-               < F_ZERO )
-                return ;
+               < F_ZERO ) {
+                
+                    return;
+                }
             p_buf[0] = element->ev1->p ;
             p_buf[1] = element->ev2->p ;
             p_buf[2] = element->ev3->p ;
@@ -1651,8 +1730,10 @@ void ps_display_element(Element *element
     else if( mode == DISPLAY_FILLED )
         {
             if( inner_product( &element->patch->plane_equ.n, &view_vec )
-               < F_ZERO )
-                return ;
+               < F_ZERO ) {
+                
+                    return;
+                }
             p_buf[0] = element->ev1->p ;
             p_buf[1] = element->ev2->p ;
             p_buf[2] = element->ev3->p ;
@@ -1712,8 +1793,10 @@ static void _ps_disp_interactions(Elemen
 
     /* Display interactions only with a particular patch */
     if(   (mode == DISPLAY_HALF_INTERACTIONS)
-       && (inter->destination->patch->seq_no >= elem->patch->seq_no ) )
-        return ;
+       && (inter->destination->patch->seq_no >= elem->patch->seq_no ) ) {
+        
+            return;
+        }
 
     /* Compute mid point of the element */
     edst = inter->destination ;
diff -u -p a/codes/apps/radiosity/patchman.c b/codes/apps/radiosity/patchman.c
--- a/codes/apps/radiosity/patchman.c
+++ b/codes/apps/radiosity/patchman.c
@@ -29,9 +29,17 @@
 
 
 #include <pthread.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <sys/time.h>
 #include <unistd.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <malloc.h>
 extern pthread_t PThreadTable[];
 ;
@@ -102,7 +110,7 @@ of the program, as well as lobal data st
 
 typedef struct
 {
-    pthread_mutex_t lock;
+    liblock_lock_t lock;
 } Shared_Lock ;
 
 #define SHARED_LOCK_SEG_SIZE (MAX_SHARED_LOCK / 2)
@@ -653,10 +661,10 @@ typedef struct _task {
 typedef struct {
     char pad1[PAGE_SIZE];	 	/* padding to avoid false-sharing
     and allow page-placement */
-    pthread_mutex_t q_lock;
+    liblock_lock_t q_lock;
     Task  *top, *tail ;
     long   n_tasks ;
-    pthread_mutex_t f_lock;
+    liblock_lock_t f_lock;
     long   n_free ;
     Task  *free ;
     char pad2[PAGE_SIZE];	 	/* padding to avoid false-sharing
@@ -924,16 +932,16 @@ typedef struct
 
     /* Task queue */
     /* ***** */ long index;
-    /* ***** */	pthread_mutex_t index_lock;
+    /* ***** */	liblock_lock_t index_lock;
     Task_Queue task_queue[ MAX_TASKQUEUES ] ;
     Task task_buf[ MAX_TASKS ] ;
 
     /* BSP tree root */
-    pthread_mutex_t bsp_tree_lock;
+    liblock_lock_t bsp_tree_lock;
     Patch *bsp_root ;
 
     /* Average radiosity value */
-    pthread_mutex_t avg_radiosity_lock;
+    liblock_lock_t avg_radiosity_lock;
     long   converged ;
     Rgb   prev_total_energy ;
     Rgb   total_energy ;
@@ -941,7 +949,7 @@ typedef struct
     long   iteration_count ;
 
     /* Computation cost estimate */
-    pthread_mutex_t cost_sum_lock;
+    liblock_lock_t cost_sum_lock;
     long cost_sum ;
     long cost_estimate_sum ;
     Patch_Cost patch_cost[ MAX_PATCHES ] ;
@@ -953,34 +961,34 @@ pthread_barrier_t	(barrier);
 
     /* Private varrier */
     long pbar_count ;
-    pthread_mutex_t pbar_lock;
+    liblock_lock_t pbar_lock;
 
     /* Task initializer counter */
     long task_counter ;
-    pthread_mutex_t task_counter_lock;
+    liblock_lock_t task_counter_lock;
 
     /* Resource buffers */
-    pthread_mutex_t free_patch_lock;
+    liblock_lock_t free_patch_lock;
     Patch *free_patch ;
     long   n_total_patches ;
     long   n_free_patches ;
     Patch patch_buf[ MAX_PATCHES ] ;
 
-    pthread_mutex_t free_element_lock;
+    liblock_lock_t free_element_lock;
     Element *free_element ;
     long     n_free_elements ;
     Element element_buf[ MAX_ELEMENTS ] ;
 
-    pthread_mutex_t free_interaction_lock;
+    liblock_lock_t free_interaction_lock;
     Interaction *free_interaction ;
     long         n_free_interactions ;
     Interaction interaction_buf[ MAX_INTERACTIONS ] ;
 
-    pthread_mutex_t free_elemvertex_lock;
+    liblock_lock_t free_elemvertex_lock;
     long         free_elemvertex ;
     ElemVertex  elemvertex_buf[ MAX_ELEMVERTICES ] ;
 
-    pthread_mutex_t free_edge_lock;
+    liblock_lock_t free_edge_lock;
     long   free_edge ;
     Edge  edge_buf[ MAX_EDGES ] ;
 
@@ -1182,8 +1190,10 @@ void foreach_patch_in_bsp(void (*func)()
 
 static void _foreach_patch(Patch *node, void (*func)(), long   arg1, long process_id)
 {
-    if( node == 0 )
-        return ;
+    if( node == 0 ) {
+        
+            return;
+        }
 
     /* Process subtree(-) */
     if( node->bsp_negative )
@@ -1221,8 +1231,10 @@ static void _foreach_d_s_patch(Vertex *s
 {
     float sign ;
 
-    if( node == 0 )
-        return ;
+    if( node == 0 ) {
+        
+            return;
+        }
 
     /* Compute inner product */
     sign = inner_product( svec, &node->plane_equ.n ) ;
@@ -1260,6 +1272,71 @@ static void _foreach_d_s_patch(Vertex *s
 
 
 
+union instance86 {struct input84{Patch *patch;Patch *parent;long xing_code;long process_id;} input84;
+struct output83{Patch *parent;long xing_code;} output83;};
+void * function87(void *ctx85);
+void *function87(void *ctx85) {
+    {
+        struct output83 *outcontext81=&(((union instance86 *)ctx85)->output83);
+        struct input84 *incontext82=&(((union instance86 *)ctx85)->input84);
+        int ret77;
+        Patch *patch=incontext82->patch;
+        Patch *parent=incontext82->parent;
+        long xing_code=incontext82->xing_code;
+        long process_id=incontext82->process_id;
+        parent = parent;
+        xing_code = xing_code;
+        {
+            ret77 = 0;
+            if (parent == 0) {
+                if (global->bsp_root == 0) {
+                    global->bsp_root = patch;
+                    patch->bsp_positive = 0;
+                    patch->bsp_negative = 0;
+                    patch->bsp_parent = 0;
+                    attach_element(patch, process_id);
+                    ret77 = 72 + 1;
+                    goto done78;
+                }else
+                    parent = global->bsp_root;
+            }
+            while (1) {
+                xing_code = patch_intersection(&parent->plane_equ, &patch->p1, &patch->p2, &patch->p3, process_id);
+                if (POSITIVE_SIDE(xing_code)) {
+                    if (parent->bsp_positive == 0) {
+                        parent->bsp_positive = patch;
+                        patch->bsp_parent = parent;
+                        attach_element(patch, process_id);
+                        ret77 = 73 + 1;
+                        goto done78;
+                    }else
+                        parent = parent->bsp_positive;
+                }else
+                    if (NEGATIVE_SIDE(xing_code)) {
+                        if (parent->bsp_negative == 0) {
+                            parent->bsp_negative = patch;
+                            patch->bsp_parent = parent;
+                            attach_element(patch, process_id);
+                            ret77 = 75 + 1;
+                            goto done78;
+                        }else
+                            parent = parent->bsp_negative;
+                    }else {
+                        ret77 = 74 + 1;
+                        goto done78;
+                    }
+            }
+            done78:
+            {
+                
+            }
+        }
+        outcontext81->parent = parent;
+        outcontext81->xing_code = xing_code;
+        return (void *)(uintptr_t)ret77;
+    }
+}
+
 /***************************************************************************
  *
  *    define_patch()
@@ -1270,85 +1347,47 @@ static void _foreach_d_s_patch(Vertex *s
 
 void define_patch(Patch *patch, Patch *root, long process_id)
 {
+    int ret77;
     Patch *parent = root ;
     long xing_code ;
 
     /* Lock the BSP tree */
-    {pthread_mutex_lock(&(global->bsp_tree_lock));};
-
-    /* If this is the first patch, link directly */
-    if( parent == 0 )
+    { union instance86 instance86 = {
         {
-            if( global->bsp_root == 0 )
-                {
-                    /* This is really the first patch */
-                    global->bsp_root = patch ;
-                    patch->bsp_positive = 0 ;
-                    patch->bsp_negative = 0 ;
-                    patch->bsp_parent   = 0 ;
-                    attach_element( patch, process_id ) ;
-                    {pthread_mutex_unlock(&(global->bsp_tree_lock));};
-
-                    return ;
-                }
-            else
-                /* Race condition. The root was NULL when the task was
-                   created */
-                parent = global->bsp_root ;
-        }
-
-    /* Traverse the BSP tree and get to the leaf node */
-    while( 1 )
-        {
-            /* Check the sign */
-            xing_code = patch_intersection( &parent->plane_equ, &patch->p1,
-                                           &patch->p2, &patch->p3, process_id ) ;
-
-            /* Traverse down the tree according to the sign */
-            if( POSITIVE_SIDE( xing_code ) )
-                {
-                    if( parent->bsp_positive == 0 )
-                        {
-                            /* Insert the patch */
-                            parent->bsp_positive = patch ;
-                            patch->bsp_parent = parent ;
-                            attach_element( patch, process_id ) ;
-                            {pthread_mutex_unlock(&(global->bsp_tree_lock));};
-
-                            foreach_patch_in_bsp( refine_newpatch, (long)patch, process_id ) ;
-                            return ;
-                        }
-                    else
-                        /* Traverse down to the subtree(+) */
-                        parent = parent->bsp_positive ;
-                }
-            else if( NEGATIVE_SIDE( xing_code ) )
-                {
-                    if( parent->bsp_negative == 0 )
-                        {
-                            /* Insert the patch */
-                            parent->bsp_negative = patch ;
-                            patch->bsp_parent = parent ;
-                            attach_element( patch, process_id ) ;
-                            {pthread_mutex_unlock(&(global->bsp_tree_lock));};
-
-                            foreach_patch_in_bsp( refine_newpatch, (long)patch, process_id ) ;
-                            return ;
-                        }
-                    else
-                        /* Traverse down to the subtree(-) */
-                        parent = parent->bsp_negative ;
-                }
-            else
-                {
-                    /* The patch must be split. Insertion is taken care of by
-                       split_patch(). */
-                    {pthread_mutex_unlock(&(global->bsp_tree_lock));};
-                    split_patch( patch, parent, xing_code, process_id ) ;
-                    return ;
-                }
-        }
-	{pthread_mutex_unlock(&(global->bsp_tree_lock));};
+            patch,
+            parent,
+            xing_code,
+            process_id,
+        },
+    };
+    
+	ret77 =(int)(uintptr_t)(liblock_execute_operation(&(global->bsp_tree_lock), (void *)(uintptr_t)(&instance86),
+                                  &function87));
+	parent = instance86.output83.parent;
+	xing_code = instance86.output83.xing_code;
+	}
+	if (ret77) {
+	    if (ret77 == 72 + 1)
+    	    {
+        	    return;
+        	}
+    	if (ret77 == 73 + 1)
+    	    {
+        	    foreach_patch_in_bsp(refine_newpatch, (long)patch, process_id);
+            	return;
+        	}
+    	if (ret77 == 75 + 1)
+    	    {
+        	    foreach_patch_in_bsp(refine_newpatch, (long)patch, process_id);
+            	return;
+        	}
+    	if (ret77 == 74 + 1)
+    	    {
+        	    split_patch(patch, parent, xing_code, process_id);
+            	return;
+        	}
+	    
+	}
 }
 
 
@@ -1613,26 +1652,60 @@ void refine_newpatch(Patch *patch, long 
     /* Check sequence number */
     if( patch->seq_no >= new_patch->seq_no )
         /* Racing condition due to multiprocessing */
-        return ;
+        {
+            return;
+        }
 
     /* Check visibility */
     cc = patch_intersection( &patch->plane_equ,
                             &new_patch->p1, &new_patch->p2, &new_patch->p3, process_id ) ;
     if( NEGATIVE_SIDE(cc) )
         /* If negative or on the plane, then do nothing */
-        return ;
+        {
+            return;
+        }
 
     cc = patch_intersection( &new_patch->plane_equ,
                             &patch->p1, &patch->p2, &patch->p3, process_id ) ;
     if( NEGATIVE_SIDE(cc) )
         /* If negative or on the plane, then do nothing */
-        return ;
+        {
+            return;
+        }
 
     /* Create a new task or do it by itself */
     create_ff_refine_task( patch->el_root, new_patch->el_root, 0, process_id ) ;
 }
 
 
+union instance93 {struct output90{Patch *p;} output90;};
+void * function94(void *ctx92);
+void *function94(void *ctx92) {
+    {
+        struct output90 *outcontext88=&(((union instance93 *)ctx92)->output90);
+        Patch *p;
+        int ret79;
+        {
+            ret79 = 0;
+            if (global->free_patch == 0) {
+                printf("Fatal: Ran out of patch buffer\n");
+                ret79 = 76 + 1;
+                goto done80;
+            }
+            p = global->free_patch;
+            global->free_patch = p->bsp_positive;
+            global->n_total_patches++;
+            global->n_free_patches--;
+            done80:
+            {
+                
+            }
+        }
+        outcontext88->p = p;
+        return (void *)(uintptr_t)ret79;
+    }
+}
+
 /***************************************************************************
  *
  *    get_patch()
@@ -1643,27 +1716,23 @@ void refine_newpatch(Patch *patch, long 
 
 Patch *get_patch(long process_id)
 {
+    int ret79;
     Patch *p ;
 
     /* {pthread_mutex_lock(&());} the free list */
-    {pthread_mutex_lock(&(global->free_patch_lock));};
-
-    /* Test pointer */
-    if( global->free_patch == 0 )
-        {
-            printf( "Fatal: Ran out of patch buffer\n" ) ;
-            {pthread_mutex_unlock(&(global->free_patch_lock));};
-            exit( 1 ) ;
-        }
-
-    /* Get a patch data structure */
-    p = global->free_patch ;
-    global->free_patch = p->bsp_positive ;
-    global->n_total_patches++ ;
-    global->n_free_patches-- ;
-
-    /* Unlock the list */
-    {pthread_mutex_unlock(&(global->free_patch_lock));};
+    { union instance93 instance93;
+    
+    ret79 =(int)(uintptr_t)(liblock_execute_operation(&(global->free_patch_lock), (void *)(uintptr_t)(&instance93),
+                              &function94));
+    p = instance93.output90.p;
+    }
+    if (ret79) {
+        if (ret79 == 76 + 1)
+            {
+                exit(1);
+            }
+        
+    }
 
     /* Clear pointers just in case.. */
     p->el_root = 0 ;
@@ -1671,7 +1740,7 @@ Patch *get_patch(long process_id)
     p->bsp_negative = 0 ;
     p->bsp_parent   = 0 ;
 
-    return( p ) ;
+    return(( p )) ;
 }
 
 
@@ -1700,7 +1769,8 @@ void init_patchlist(long process_id)
     global->free_patch = global->patch_buf ;
     global->n_total_patches = 0 ;
     global->n_free_patches  = MAX_PATCHES ;
-    pthread_mutex_init(&(global->free_patch_lock), NULL); ;
+    liblock_lock_init(TYPE_NOINFO, ARG_NOINFO,
+                      &(global->free_patch_lock), NULL); ;
 
 #if PATCH_ASSIGNMENT == PATCH_ASSIGNMENT_COSTBASED
     /* Initialize Patch_Cost structure */
@@ -1785,7 +1855,7 @@ float plane_equ(PlaneEqu *plane, Vertex 
         + point->y * plane->n.y
             + point->z * plane->n.z ;
 
-    return( h ) ;
+    return(( h )) ;
 }
 
 /***************************************************************************
@@ -1806,7 +1876,7 @@ float comp_plane_equ(PlaneEqu *pln, Vert
     /* Calculate constant factor */
     pln->c = -inner_product( &pln->n, p1 ) ;
 
-    return( length ) ;
+    return(( length )) ;
 }
 
 
@@ -1838,7 +1908,7 @@ long point_intersection(PlaneEqu *plane,
     if( h > F_COPLANAR )
         result_code |= POINT_POSITIVE_SIDE ;
 
-    return( result_code ) ;
+    return(( result_code )) ;
 }
 
 
@@ -1851,7 +1921,7 @@ long patch_intersection(PlaneEqu *plane,
     c2 = point_intersection( plane, p2, process_id ) ;
     c3 = point_intersection( plane, p3, process_id ) ;
 
-    return( (c3 << 4) | (c2 << 2) | c1 ) ;
+    return(( (c3 << 4) | (c2 << 2) | c1 )) ;
 }
 
 
diff -u -p a/codes/apps/radiosity/rad_main.c b/codes/apps/radiosity/rad_main.c
--- a/codes/apps/radiosity/rad_main.c
+++ b/codes/apps/radiosity/rad_main.c
@@ -36,9 +36,17 @@
 
 
 #include <pthread.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <sys/time.h>
 #include <unistd.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <malloc.h>
 /** +EDIT */
 //#define MAX_THREADS 32
@@ -113,7 +121,7 @@ of the program, as well as lobal data st
 
 typedef struct
 {
-    pthread_mutex_t lock;
+    liblock_lock_t lock;
 } Shared_Lock ;
 
 #define SHARED_LOCK_SEG_SIZE (MAX_SHARED_LOCK / 2)
@@ -664,10 +672,10 @@ typedef struct _task {
 typedef struct {
     char pad1[PAGE_SIZE];	 	/* padding to avoid false-sharing
     and allow page-placement */
-    pthread_mutex_t q_lock;
+    liblock_lock_t q_lock;
     Task  *top, *tail ;
     long   n_tasks ;
-    pthread_mutex_t f_lock;
+    liblock_lock_t f_lock;
     long   n_free ;
     Task  *free ;
     char pad2[PAGE_SIZE];	 	/* padding to avoid false-sharing
@@ -935,16 +943,16 @@ typedef struct
 
     /* Task queue */
     /* ***** */ long index;
-    /* ***** */	pthread_mutex_t index_lock;
+    /* ***** */	liblock_lock_t index_lock;
     Task_Queue task_queue[ MAX_TASKQUEUES ] ;
     Task task_buf[ MAX_TASKS ] ;
 
     /* BSP tree root */
-    pthread_mutex_t bsp_tree_lock;
+    liblock_lock_t bsp_tree_lock;
     Patch *bsp_root ;
 
     /* Average radiosity value */
-    pthread_mutex_t avg_radiosity_lock;
+    liblock_lock_t avg_radiosity_lock;
     long   converged ;
     Rgb   prev_total_energy ;
     Rgb   total_energy ;
@@ -952,7 +960,7 @@ typedef struct
     long   iteration_count ;
 
     /* Computation cost estimate */
-    pthread_mutex_t cost_sum_lock;
+    liblock_lock_t cost_sum_lock;
     long cost_sum ;
     long cost_estimate_sum ;
     Patch_Cost patch_cost[ MAX_PATCHES ] ;
@@ -964,34 +972,34 @@ pthread_barrier_t	(barrier);
 
     /* Private varrier */
     long pbar_count ;
-    pthread_mutex_t pbar_lock;
+    liblock_lock_t pbar_lock;
 
     /* Task initializer counter */
     long task_counter ;
-    pthread_mutex_t task_counter_lock;
+    liblock_lock_t task_counter_lock;
 
     /* Resource buffers */
-    pthread_mutex_t free_patch_lock;
+    liblock_lock_t free_patch_lock;
     Patch *free_patch ;
     long   n_total_patches ;
     long   n_free_patches ;
     Patch patch_buf[ MAX_PATCHES ] ;
 
-    pthread_mutex_t free_element_lock;
+    liblock_lock_t free_element_lock;
     Element *free_element ;
     long     n_free_elements ;
     Element element_buf[ MAX_ELEMENTS ] ;
 
-    pthread_mutex_t free_interaction_lock;
+    liblock_lock_t free_interaction_lock;
     Interaction *free_interaction ;
     long         n_free_interactions ;
     Interaction interaction_buf[ MAX_INTERACTIONS ] ;
 
-    pthread_mutex_t free_elemvertex_lock;
+    liblock_lock_t free_elemvertex_lock;
     long         free_elemvertex ;
     ElemVertex  elemvertex_buf[ MAX_ELEMVERTICES ] ;
 
-    pthread_mutex_t free_edge_lock;
+    liblock_lock_t free_edge_lock;
     long   free_edge ;
     Edge  edge_buf[ MAX_EDGES ] ;
 
@@ -1354,7 +1362,7 @@ int main(int argc, char *argv[])
 	long	i, Error;
 
 	for (i = 0; i < (n_processors) - 1; i++) {
-		Error = pthread_create(&PThreadTable[i], NULL, (void * (*)(void *))(radiosity), NULL);
+		Error = liblock_thread_create(&PThreadTable[i], NULL, (void * (*)(void *))(radiosity), NULL);
 		if (Error != 0) {
 			printf("Error in pthread_create().\n");
 			exit(-1);
@@ -1506,7 +1514,7 @@ void start_radiosity(long val)
             if( state == -1 )
                 {
                     printf( "Please reset first\007\n" ) ;
-                    return ;
+                    return;
                 }
 
             /* Time stamp */
@@ -1531,7 +1539,7 @@ void start_radiosity(long val)
 	long	i, Error;
 
 	for (i = 0; i < (n_processors) - 1; i++) {
-		Error = pthread_create(&PThreadTable[i], NULL, (void * (*)(void *))(radiosity), NULL);
+		Error = liblock_thread_create(&PThreadTable[i], NULL, (void * (*)(void *))(radiosity), NULL);
 		if (Error != 0) {
 			printf("Error in pthread_create().\n");
 			exit(-1);
@@ -1639,7 +1647,7 @@ void start_radiosity(long val)
             if( state == -1 )
                 {
                     printf( "Please reset first\007\n" ) ;
-                    return ;
+                    return;
                 }
 
             /* Step execution */
@@ -1659,7 +1667,7 @@ void start_radiosity(long val)
 	long	i, Error;
 
 	for (i = 0; i < (n_processors/* - 1*/) - 1; i++) {
-		Error = pthread_create(&PThreadTable[i], NULL, (void * (*)(void *))(radiosity), NULL);
+		Error = liblock_thread_create(&PThreadTable[i], NULL, (void * (*)(void *))(radiosity), NULL);
 		if (Error != 0) {
 			printf("Error in pthread_create().\n");
 			exit(-1);
@@ -1675,7 +1683,7 @@ void start_radiosity(long val)
                     init_modeling_tasks(0) ;
                     process_tasks(0) ;
                     state ++ ;
-                    break ;
+                    break;
 
                 case 1:
                     if( init_ray_tasks(0) )
@@ -1687,7 +1695,7 @@ void start_radiosity(long val)
                         }
                     else
                         state++ ;
-                    break ;
+                    break;
                 default:
                     {
 	pthread_barrier_wait(&(global->barrier));
@@ -1752,21 +1760,21 @@ void change_display(long val)
         {
         case CHOICE_DISP_RADIOSITY:
             disp_fill_switch = (! disp_fill_switch) ;
-            break ;
+            break;
         case CHOICE_DISP_SHADED:
             disp_shade_switch = (! disp_shade_switch) ;
-            break ;
+            break;
         case CHOICE_DISP_PATCH:
             disp_patch_switch = (! disp_patch_switch) ;
-            break ;
+            break;
         case CHOICE_DISP_MESH:
             disp_mesh_switch = (! disp_mesh_switch) ;
-            break ;
+            break;
         case CHOICE_DISP_INTERACTION:
             disp_interaction_switch = (! disp_interaction_switch) ;
-            break ;
+            break;
         default:
-            return ;
+            return;
         }
 
     if( disp_fill_switch == 0 )
@@ -1903,13 +1911,13 @@ void select_model(long val)
         {
         case MODEL_TEST_DATA:
             model_selector = MODEL_TEST_DATA ;
-            break ;
+            break;
         case MODEL_ROOM_DATA:
             model_selector = MODEL_ROOM_DATA ;
-            break ;
+            break;
         case MODEL_LARGEROOM_DATA:
             model_selector = MODEL_LARGEROOM_DATA ;
-            break ;
+            break;
         }
 }
 
@@ -1951,19 +1959,19 @@ void utility_tools(long val)
 
             /* Close */
             ps_close() ;
-            break ;
+            break;
         case CHOICE_UTIL_STAT_CRT:
             print_statistics( stdout, 0 ) ;
-            break ;
+            break;
         case CHOICE_UTIL_STAT_FILE:
             if( (fd = fopen( "radiosity_stat", "w" )) == 0 )
                 {
                     perror( "radiosity_stat" ) ;
-                    break ;
+                    break;
                 }
             print_statistics( fd, 0 ) ;
             fclose( fd ) ;
-            break ;
+            break;
         case CHOICE_UTIL_CLEAR_RAD:
             clear_radiosity(0) ;
         }
@@ -1984,6 +1992,17 @@ static void expose_callback()
 }
 
 
+void * function104(void *ctx102);
+void *function104(void *ctx102) {
+    {
+        long process_id;
+        {
+            process_id = global->index++;
+        }
+        return (void *)(uintptr_t)process_id;
+    }
+}
+
 /***************************************
  *
  *    radiosity()  Radiosity task main
@@ -1996,9 +2015,11 @@ void radiosity()
     long process_id;
     long rad_start, refine_done, vertex_start, vertex_done;
 
-    {pthread_mutex_lock(&(global->index_lock));};
-    process_id = global->index++;
-    {pthread_mutex_unlock(&(global->index_lock));};
+    {
+    
+    process_id =(long)(uintptr_t)(liblock_execute_operation(&(global->index_lock), (void *)(uintptr_t)(NULL),
+                              &function104));
+    }
     process_id = process_id % n_processors;
 
     {;};
@@ -2107,37 +2128,70 @@ static void _init_ray_tasks_cost2(Patch 
 
 
 
+union instance110 {struct input108{long process_id;} input108;
+struct output107{long conv;} output107;};
+void * function111(void *ctx109);
+void *function111(void *ctx109) {
+    {
+        struct output107 *outcontext105=&(((union instance110 *)ctx109)->output107);
+        struct input108 *incontext106=&(((union instance110 *)ctx109)->input108);
+        long conv;
+        int ret96;
+        long process_id=incontext106->process_id;
+        {
+            ret96 = 0;
+            if (!check_task_counter()) {
+                conv = global->converged;
+                ret96 = 95 + 1;
+                goto done97;
+            }
+            conv = radiosity_converged(process_id);
+            global->converged = conv;
+            global->prev_total_energy = global->total_energy;
+            global->total_energy.r = 0.0;
+            global->total_energy.g = 0.0;
+            global->total_energy.b = 0.0;
+            global->total_patch_area = 0.0;
+            global->iteration_count++;
+            done97:
+            {
+                
+            }
+        }
+        outcontext105->conv = conv;
+        return (void *)(uintptr_t)ret96;
+    }
+}
+
 long init_ray_tasks(long process_id)
 {
+    int ret96;
     long conv ;
 
     /* If this is not the first process to initialize, then return */
-    {pthread_mutex_lock(&(global->avg_radiosity_lock));};
-    if( ! check_task_counter() )
+    { union instance110 instance110 = {
         {
-            conv = global->converged ;
-            {pthread_mutex_unlock(&(global->avg_radiosity_lock));};
-            return( conv == 0 ) ;
-        }
-
-    /* Check radiosity convergence */
-    conv = radiosity_converged(process_id) ;
-    global->converged = conv ;
-
-    /* Reset total energy variable */
-    global->prev_total_energy = global->total_energy ;
-    global->total_energy.r = 0.0 ;
-    global->total_energy.g = 0.0 ;
-    global->total_energy.b = 0.0 ;
-    global->total_patch_area = 0.0 ;
-
-    /* Increment iteration counter */
-    global->iteration_count++ ;
-    {pthread_mutex_unlock(&(global->avg_radiosity_lock));};
+            process_id,
+        },
+    };
+    
+    ret96 =(int)(uintptr_t)(liblock_execute_operation(&(global->avg_radiosity_lock), (void *)(uintptr_t)(&instance110),
+                              &function111));
+    conv = instance110.output107.conv;
+    }
+    if (ret96) {
+        if (ret96 == 95 + 1)
+            {
+                return((conv == 0));
+            }
+        
+    }
 
     /* If radiosity converged, then return 0 */
-    if( conv )
-        return( 0 ) ;
+    if( conv ) {
+        
+            return(( 0 )) ;
+        }
 
 
 #if PATCH_ASSIGNMENT == PATCH_ASSIGNMENT_COSTBASED
@@ -2164,7 +2218,7 @@ long init_ray_tasks(long process_id)
     /* Create BF refinement tasks */
     foreach_patch_in_bsp( _INIT_RAY_TASK, 0, process_id ) ;
 
-    return( 1 ) ;
+    return(( 1 )) ;
 }
 
 
@@ -2193,10 +2247,14 @@ static void _init_ray_tasks_cost2(Patch 
 
     if( c_est < 0 )
         /* Already processed */
-        return ;
+        {
+            return;
+        }
 
-    if( c_est < avg_cost_of_patch * layer )
-        return ;
+    if( c_est < avg_cost_of_patch * layer ) {
+        
+            return;
+        }
 
     /* Find the first available queue */
     min_cost_q = 0 ;
@@ -2204,7 +2262,7 @@ static void _init_ray_tasks_cost2(Patch 
     for( qid = 0 ; qid < n_taskqueues ; qid++ )
         {
             if( (c_est + queue_cost[ qid ]) <= avg_cost_of_q )
-                break ;
+                break;
 
             if( min_cost > queue_cost[ qid ] )
                 {
@@ -2252,8 +2310,10 @@ void init_radavg_tasks(long mode, long p
 {
 
     /* If this is not the first process to initialize, then return */
-    if( ! check_task_counter() )
-        return ;
+    if( ! check_task_counter() ) {
+        
+        return;
+        }
 
     /* Create RadAvg tasks */
     foreach_patch_in_bsp( _init_radavg_tasks, mode, process_id ) ;
@@ -2279,11 +2339,12 @@ void init_global(long process_id)
     /* Clear BSP root pointer */
     global->index = 1;  /* ****** */
     global->bsp_root = 0 ;
-    pthread_mutex_init(&(global->index_lock), NULL);;
-    pthread_mutex_init(&(global->bsp_tree_lock), NULL);;
+    liblock_lock_init(TYPE_NOINFO, ARG_NOINFO, &(global->index_lock), NULL);;
+    liblock_lock_init(TYPE_NOINFO, ARG_NOINFO, &(global->bsp_tree_lock), NULL);;
 
     /* Initialize radiosity statistics variables */
-    pthread_mutex_init(&(global->avg_radiosity_lock), NULL);;
+    liblock_lock_init(TYPE_RADIOSITY_2, ARG_RADIOSITY_2,
+                      &(global->avg_radiosity_lock), NULL);;
     global->converged = 0 ;
     global->prev_total_energy.r = 0.0 ;
     global->prev_total_energy.g = 0.0 ;
@@ -2295,18 +2356,20 @@ void init_global(long process_id)
     global->iteration_count = -1 ;     /* init_ray_task() increments to 0 */
 
     /* Initialize the cost sum */
-    pthread_mutex_init(&(global->cost_sum_lock), NULL);;
+    liblock_lock_init(TYPE_NOINFO, ARG_NOINFO, &(global->cost_sum_lock), NULL);;
     global->cost_sum = 0 ;
     global->cost_estimate_sum = 0 ;
 
     /* Initialize the barrier */
     {pthread_barrier_init(&(global->barrier), NULL, n_processors);};
-    pthread_mutex_init(&(global->pbar_lock), NULL);;
+    liblock_lock_init(TYPE_RADIOSITY_3, ARG_RADIOSITY_3,
+                      &(global->pbar_lock), NULL);;
     global->pbar_count = 0 ;
 
     /* Initialize task counter */
     global->task_counter = 0 ;
-    pthread_mutex_init(&(global->task_counter_lock), NULL);;
+    liblock_lock_init(TYPE_NOINFO, ARG_NOINFO,
+                      &(global->task_counter_lock), NULL);;
 
     /* Initialize task queue */
     init_taskq(process_id) ;
diff -u -p a/codes/apps/radiosity/task.h b/codes/apps/radiosity/task.h
--- a/codes/apps/radiosity/task.h
+++ b/codes/apps/radiosity/task.h
@@ -125,10 +125,10 @@ typedef struct _task {
 typedef struct {
     char pad1[PAGE_SIZE];	 	/* padding to avoid false-sharing
     and allow page-placement */
-    pthread_mutex_t q_lock;
+    liblock_lock_t q_lock;
     Task  *top, *tail ;
     long   n_tasks ;
-    pthread_mutex_t f_lock;
+    liblock_lock_t f_lock;
     long   n_free ;
     Task  *free ;
     char pad2[PAGE_SIZE];	 	/* padding to avoid false-sharing
diff -u -p a/codes/apps/radiosity/radiosity.h b/codes/apps/radiosity/radiosity.h
--- a/codes/apps/radiosity/radiosity.h
+++ b/codes/apps/radiosity/radiosity.h
@@ -64,7 +64,7 @@ of the program, as well as lobal data st
 
 typedef struct
 {
-    pthread_mutex_t lock;
+    liblock_lock_t lock;
 } Shared_Lock ;
 
 #define SHARED_LOCK_SEG_SIZE (MAX_SHARED_LOCK / 2)
@@ -615,10 +615,10 @@ typedef struct _task {
 typedef struct {
     char pad1[PAGE_SIZE];	 	/* padding to avoid false-sharing
     and allow page-placement */
-    pthread_mutex_t q_lock;
+    liblock_lock_t q_lock;
     Task  *top, *tail ;
     long   n_tasks ;
-    pthread_mutex_t f_lock;
+    liblock_lock_t f_lock;
     long   n_free ;
     Task  *free ;
     char pad2[PAGE_SIZE];	 	/* padding to avoid false-sharing
@@ -886,16 +886,16 @@ typedef struct
 
     /* Task queue */
     /* ***** */ long index;
-    /* ***** */	pthread_mutex_t index_lock;
+    /* ***** */	liblock_lock_t index_lock;
     Task_Queue task_queue[ MAX_TASKQUEUES ] ;
     Task task_buf[ MAX_TASKS ] ;
 
     /* BSP tree root */
-    pthread_mutex_t bsp_tree_lock;
+    liblock_lock_t bsp_tree_lock;
     Patch *bsp_root ;
 
     /* Average radiosity value */
-    pthread_mutex_t avg_radiosity_lock;
+    liblock_lock_t avg_radiosity_lock;
     long   converged ;
     Rgb   prev_total_energy ;
     Rgb   total_energy ;
@@ -903,7 +903,7 @@ typedef struct
     long   iteration_count ;
 
     /* Computation cost estimate */
-    pthread_mutex_t cost_sum_lock;
+    liblock_lock_t cost_sum_lock;
     long cost_sum ;
     long cost_estimate_sum ;
     Patch_Cost patch_cost[ MAX_PATCHES ] ;
@@ -915,34 +915,34 @@ pthread_barrier_t	(barrier);
 
     /* Private varrier */
     long pbar_count ;
-    pthread_mutex_t pbar_lock;
+    liblock_lock_t pbar_lock;
 
     /* Task initializer counter */
     long task_counter ;
-    pthread_mutex_t task_counter_lock;
+    liblock_lock_t task_counter_lock;
 
     /* Resource buffers */
-    pthread_mutex_t free_patch_lock;
+    liblock_lock_t free_patch_lock;
     Patch *free_patch ;
     long   n_total_patches ;
     long   n_free_patches ;
     Patch patch_buf[ MAX_PATCHES ] ;
 
-    pthread_mutex_t free_element_lock;
+    liblock_lock_t free_element_lock;
     Element *free_element ;
     long     n_free_elements ;
     Element element_buf[ MAX_ELEMENTS ] ;
 
-    pthread_mutex_t free_interaction_lock;
+    liblock_lock_t free_interaction_lock;
     Interaction *free_interaction ;
     long         n_free_interactions ;
     Interaction interaction_buf[ MAX_INTERACTIONS ] ;
 
-    pthread_mutex_t free_elemvertex_lock;
+    liblock_lock_t free_elemvertex_lock;
     long         free_elemvertex ;
     ElemVertex  elemvertex_buf[ MAX_ELEMVERTICES ] ;
 
-    pthread_mutex_t free_edge_lock;
+    liblock_lock_t free_edge_lock;
     long   free_edge ;
     Edge  edge_buf[ MAX_EDGES ] ;
 
diff -u -p a/codes/apps/radiosity/rad_tools.c b/codes/apps/radiosity/rad_tools.c
--- a/codes/apps/radiosity/rad_tools.c
+++ b/codes/apps/radiosity/rad_tools.c
@@ -25,9 +25,17 @@
 
 
 #include <pthread.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <sys/time.h>
 #include <unistd.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <malloc.h>
 extern pthread_t PThreadTable[];
 ;
@@ -98,7 +106,7 @@ of the program, as well as lobal data st
 
 typedef struct
 {
-    pthread_mutex_t lock;
+    liblock_lock_t lock;
 } Shared_Lock ;
 
 #define SHARED_LOCK_SEG_SIZE (MAX_SHARED_LOCK / 2)
@@ -649,10 +657,10 @@ typedef struct _task {
 typedef struct {
     char pad1[PAGE_SIZE];	 	/* padding to avoid false-sharing
     and allow page-placement */
-    pthread_mutex_t q_lock;
+    liblock_lock_t q_lock;
     Task  *top, *tail ;
     long   n_tasks ;
-    pthread_mutex_t f_lock;
+    liblock_lock_t f_lock;
     long   n_free ;
     Task  *free ;
     char pad2[PAGE_SIZE];	 	/* padding to avoid false-sharing
@@ -920,16 +928,16 @@ typedef struct
 
     /* Task queue */
     /* ***** */ long index;
-    /* ***** */	pthread_mutex_t index_lock;
+    /* ***** */	liblock_lock_t index_lock;
     Task_Queue task_queue[ MAX_TASKQUEUES ] ;
     Task task_buf[ MAX_TASKS ] ;
 
     /* BSP tree root */
-    pthread_mutex_t bsp_tree_lock;
+    liblock_lock_t bsp_tree_lock;
     Patch *bsp_root ;
 
     /* Average radiosity value */
-    pthread_mutex_t avg_radiosity_lock;
+    liblock_lock_t avg_radiosity_lock;
     long   converged ;
     Rgb   prev_total_energy ;
     Rgb   total_energy ;
@@ -937,7 +945,7 @@ typedef struct
     long   iteration_count ;
 
     /* Computation cost estimate */
-    pthread_mutex_t cost_sum_lock;
+    liblock_lock_t cost_sum_lock;
     long cost_sum ;
     long cost_estimate_sum ;
     Patch_Cost patch_cost[ MAX_PATCHES ] ;
@@ -949,34 +957,34 @@ pthread_barrier_t	(barrier);
 
     /* Private varrier */
     long pbar_count ;
-    pthread_mutex_t pbar_lock;
+    liblock_lock_t pbar_lock;
 
     /* Task initializer counter */
     long task_counter ;
-    pthread_mutex_t task_counter_lock;
+    liblock_lock_t task_counter_lock;
 
     /* Resource buffers */
-    pthread_mutex_t free_patch_lock;
+    liblock_lock_t free_patch_lock;
     Patch *free_patch ;
     long   n_total_patches ;
     long   n_free_patches ;
     Patch patch_buf[ MAX_PATCHES ] ;
 
-    pthread_mutex_t free_element_lock;
+    liblock_lock_t free_element_lock;
     Element *free_element ;
     long     n_free_elements ;
     Element element_buf[ MAX_ELEMENTS ] ;
 
-    pthread_mutex_t free_interaction_lock;
+    liblock_lock_t free_interaction_lock;
     Interaction *free_interaction ;
     long         n_free_interactions ;
     Interaction interaction_buf[ MAX_INTERACTIONS ] ;
 
-    pthread_mutex_t free_elemvertex_lock;
+    liblock_lock_t free_elemvertex_lock;
     long         free_elemvertex ;
     ElemVertex  elemvertex_buf[ MAX_ELEMVERTICES ] ;
 
-    pthread_mutex_t free_edge_lock;
+    liblock_lock_t free_edge_lock;
     long   free_edge ;
     Edge  edge_buf[ MAX_EDGES ] ;
 
diff -u -p a/codes/apps/radiosity/taskman.c b/codes/apps/radiosity/taskman.c
--- a/codes/apps/radiosity/taskman.c
+++ b/codes/apps/radiosity/taskman.c
@@ -29,9 +29,17 @@
 
 
 #include <pthread.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <sys/time.h>
 #include <unistd.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <malloc.h>
 extern pthread_t PThreadTable[];
 ;
@@ -102,7 +110,7 @@ of the program, as well as lobal data st
 
 typedef struct
 {
-    pthread_mutex_t lock;
+    liblock_lock_t lock;
 } Shared_Lock ;
 
 #define SHARED_LOCK_SEG_SIZE (MAX_SHARED_LOCK / 2)
@@ -653,10 +661,10 @@ typedef struct _task {
 typedef struct {
     char pad1[PAGE_SIZE];	 	/* padding to avoid false-sharing
     and allow page-placement */
-    pthread_mutex_t q_lock;
+    liblock_lock_t q_lock;
     Task  *top, *tail ;
     long   n_tasks ;
-    pthread_mutex_t f_lock;
+    liblock_lock_t f_lock;
     long   n_free ;
     Task  *free ;
     char pad2[PAGE_SIZE];	 	/* padding to avoid false-sharing
@@ -924,16 +932,16 @@ typedef struct
 
     /* Task queue */
     /* ***** */ long index;
-    /* ***** */	pthread_mutex_t index_lock;
+    /* ***** */	liblock_lock_t index_lock;
     Task_Queue task_queue[ MAX_TASKQUEUES ] ;
     Task task_buf[ MAX_TASKS ] ;
 
     /* BSP tree root */
-    pthread_mutex_t bsp_tree_lock;
+    liblock_lock_t bsp_tree_lock;
     Patch *bsp_root ;
 
     /* Average radiosity value */
-    pthread_mutex_t avg_radiosity_lock;
+    liblock_lock_t avg_radiosity_lock;
     long   converged ;
     Rgb   prev_total_energy ;
     Rgb   total_energy ;
@@ -941,7 +949,7 @@ typedef struct
     long   iteration_count ;
 
     /* Computation cost estimate */
-    pthread_mutex_t cost_sum_lock;
+    liblock_lock_t cost_sum_lock;
     long cost_sum ;
     long cost_estimate_sum ;
     Patch_Cost patch_cost[ MAX_PATCHES ] ;
@@ -953,34 +961,34 @@ pthread_barrier_t	(barrier);
 
     /* Private varrier */
     long pbar_count ;
-    pthread_mutex_t pbar_lock;
+    liblock_lock_t pbar_lock;
 
     /* Task initializer counter */
     long task_counter ;
-    pthread_mutex_t task_counter_lock;
+    liblock_lock_t task_counter_lock;
 
     /* Resource buffers */
-    pthread_mutex_t free_patch_lock;
+    liblock_lock_t free_patch_lock;
     Patch *free_patch ;
     long   n_total_patches ;
     long   n_free_patches ;
     Patch patch_buf[ MAX_PATCHES ] ;
 
-    pthread_mutex_t free_element_lock;
+    liblock_lock_t free_element_lock;
     Element *free_element ;
     long     n_free_elements ;
     Element element_buf[ MAX_ELEMENTS ] ;
 
-    pthread_mutex_t free_interaction_lock;
+    liblock_lock_t free_interaction_lock;
     Interaction *free_interaction ;
     long         n_free_interactions ;
     Interaction interaction_buf[ MAX_INTERACTIONS ] ;
 
-    pthread_mutex_t free_elemvertex_lock;
+    liblock_lock_t free_elemvertex_lock;
     long         free_elemvertex ;
     ElemVertex  elemvertex_buf[ MAX_ELEMVERTICES ] ;
 
-    pthread_mutex_t free_edge_lock;
+    liblock_lock_t free_edge_lock;
     long   free_edge ;
     Edge  edge_buf[ MAX_EDGES ] ;
 
@@ -1182,6 +1190,28 @@ struct {
 #define QUEUES_VISITED (n_taskqueues)
 #define DEQUEUE_TASK(q,v,p) (dequeue_task((q),(v),p))
 
+void * function128(void *ctx126);
+void *function128(void *ctx126) {
+    {
+        {
+            global->pbar_count--;
+        }
+        return NULL;
+    }
+}
+
+void * function121(void *ctx119);
+void *function121(void *ctx119) {
+    {
+        {
+            if (global->pbar_count >= n_processors)
+                global->pbar_count = 0;
+            global->pbar_count++;
+        }
+        return NULL;
+    }
+}
+
 void process_tasks(long process_id)
 {
     Task *t ;
@@ -1195,23 +1225,23 @@ void process_tasks(long process_id)
                 {
                 case TASK_MODELING:
                     process_model( t->task.model.model, t->task.model.type, process_id ) ;
-                    break ;
+                    break;
                 case TASK_BSP:
                     define_patch( t->task.bsp.patch, t->task.bsp.parent, process_id ) ;
-                    break ;
+                    break;
                 case TASK_FF_REFINEMENT:
                     ff_refine_elements( t->task.ref.e1, t->task.ref.e2, 0, process_id ) ;
-                    break ;
+                    break;
                 case TASK_RAY:
                     process_rays( t->task.ray.e, process_id ) ;
-                    break ;
+                    break;
                 case TASK_VISIBILITY:
                     visibility_task( t->task.vis.e, t->task.vis.inter,
                                     t->task.vis.n_inter, t->task.vis.k, process_id ) ;
-                    break ;
+                    break;
                 case TASK_RAD_AVERAGE:
                     radiosity_averaging( t->task.rad.e, t->task.rad.mode, process_id ) ;
-                    break ;
+                    break;
                 default:
                     fprintf( stderr, "Panic:process_tasks:Illegal task type\n" );
                 }
@@ -1227,21 +1257,17 @@ void process_tasks(long process_id)
     /* Barrier. While waiting for other processors to finish, poll the task
        queues and resume processing if there is any task */
 
-    {pthread_mutex_lock(&(global->pbar_lock));};
-    /* Reset the barrier counter if not initialized */
-    if( global->pbar_count >= n_processors )
-        global->pbar_count = 0 ;
-
-    /* Increment the counter */
-    global->pbar_count++ ;
-    {pthread_mutex_unlock(&(global->pbar_lock));};
+    {
+    
+    liblock_execute_operation(&(global->pbar_lock), (void *)(uintptr_t)(NULL),
+                              &function121); }
 
     /* barrier spin-wait loop */
     while( global->pbar_count < n_processors )
         {
             /* Wait for a while and then retry dequeue */
             if( _process_task_wait_loop() )
-                break ;
+                break;
             
 			/* Waited for a while but other processors are still running.
                Poll the task queue again */
@@ -1249,9 +1275,9 @@ void process_tasks(long process_id)
             if( t )
                 {
                     /* Task found. Exit the barrier and work on it */
-                    {pthread_mutex_lock(&(global->pbar_lock));};
-                    global->pbar_count-- ;
-                    {pthread_mutex_unlock(&(global->pbar_lock));};
+                    {
+                    liblock_execute_operation(&(global->pbar_lock),
+                                              (void *)(uintptr_t)(NULL), &function128); }
                     goto retry_entry ;
                 }
 
@@ -1276,7 +1302,7 @@ long _process_task_wait_loop()
                 finished = 1 ;
         }
 
-    return( finished ) ;
+    return(( finished )) ;
 }
 
 
@@ -1299,7 +1325,7 @@ void create_modeling_task(Model *model, 
        for historical reasons */
 
     process_model( model, type, process_id ) ;
-    return ;
+    return;
 }
 
 
@@ -1307,7 +1333,7 @@ void create_bsp_task(Patch *patch, Patch
 {
     /* Implemented this way (routine just calls another routine) for historical reasons */
     define_patch( patch, parent, process_id ) ;
-    return ;
+    return;
 }
 
 
@@ -1321,7 +1347,7 @@ void create_ff_refine_task(Element *e1, 
         {
             /* Task queue is too long. Solve it immediately */
             ff_refine_elements( e1, e2, level, process_id ) ;
-            return ;
+            return;
         }
 
     /* Create a task */
@@ -1348,7 +1374,7 @@ void create_ray_task(Element *e, long pr
             /* Task size is small, or the queue is too long.
                Solve it immediately */
             process_rays( e, process_id ) ;
-            return ;
+            return;
         }
 
     /* Put in the queue */
@@ -1390,7 +1416,7 @@ void create_visibility_tasks(Element *e,
             /* No process needs to be created. Call the continuation
                immediately */
             (*k)( e, process_id ) ;
-            return ;
+            return;
         }
 
     /* Check existing parallelism */
@@ -1402,7 +1428,7 @@ void create_visibility_tasks(Element *e,
             visibility_task( e, e->vis_undef_inter,
                             e->n_vis_undef_inter, k, process_id ) ;
 
-            return ;
+            return;
         }
 
     /* Create multiple tasks. Hard problems (i.e. where visibility comp is
@@ -1467,7 +1493,7 @@ void create_radavg_task(Element *e, long
             /* Task size is too small or queue is too long.
                Solve it immediately */
             radiosity_averaging( e, mode, process_id ) ;
-            return ;
+            return;
         }
 
     /* Put in the queue */
@@ -1491,6 +1517,35 @@ void enqueue_radavg_task(long qid, Eleme
 
 
 
+union instance134 {struct input132{Task_Queue *tq;Task *task;long mode;} input132;};
+void * function135(void *ctx133);
+void *function135(void *ctx133) {
+    {
+        struct input132 *incontext130=&(((union instance134 *)ctx133)->input132);
+        Task_Queue *tq=incontext130->tq;
+        Task *task=incontext130->task;
+        long mode=incontext130->mode;
+        {
+            if (tq->tail == 0) {
+                tq->tail = task;
+                tq->top = task;
+                tq->n_tasks = 1;
+            }else {
+                if (mode == TASK_APPEND) {
+                    tq->tail->next = task;
+                    tq->tail = task;
+                    tq->n_tasks++;
+                }else {
+                    task->next = tq->top;
+                    tq->top = task;
+                    tq->n_tasks++;
+                }
+            }
+        }
+        return NULL;
+    }
+}
+
 /***************************************************************************
  *
  *    enqueue_task()
@@ -1506,39 +1561,54 @@ void enqueue_task(long qid, Task *task, 
     tq = &global->task_queue[ qid ] ;
 
     /* Lock the task queue */
-    {pthread_mutex_lock(&(tq->q_lock));};
-
-    if( tq->tail == 0 )
+    { union instance134 instance134 = {
         {
-            /* The first task in the queue */
-            tq->tail    = task ;
-            tq->top     = task ;
-            tq->n_tasks = 1 ;
-        }
-    else
-        {
-            /* Usual case */
-            if( mode == TASK_APPEND )
-                {
-                    tq->tail->next = task ;
-                    tq->tail = task ;
-                    tq->n_tasks++ ;
-                }
-            else
-                {
-                    task->next = tq->top ;
-                    tq->top = task ;
-                    tq->n_tasks++ ;
-                }
-        }
-
-    /* Unlock the task queue */
-    {pthread_mutex_unlock(&(tq->q_lock));};
+            tq,
+            task,
+            mode,
+        },
+    };
+    
+    liblock_execute_operation(&(tq->q_lock), (void *)(uintptr_t)(&instance134), &function135); }
 }
 
 
 
 
+union instance141 {struct input139{Task_Queue *tq;Task *t;long process_id;long qid;} input139;};
+void * function142(void *ctx140);
+void *function142(void *ctx140) {
+    {
+        struct input139 *incontext137=&(((union instance141 *)ctx140)->input139);
+        Task *prev;
+        Task_Queue *tq=incontext137->tq;
+        Task *t=incontext137->t;
+        long process_id=incontext137->process_id;
+        long qid=incontext137->qid;
+        t = t;
+        {
+            if (tq->top) {
+                if (qid == taskqueue_id[process_id]) {
+                    t = tq->top;
+                    tq->top = t->next;
+                    if (tq->top == 0)
+                        tq->tail = 0;
+                    tq->n_tasks--;
+                }else {
+                    for (prev = 0, t = tq->top;t->next;prev = t, t = t->next)
+                        ;
+                    if (prev == 0)
+                        tq->top = 0;else
+                        prev->next = 0;
+                    tq->tail = prev;
+                    tq->n_tasks--;
+                }
+            }
+        }
+        return (void *)(uintptr_t)t;
+    }
+}
+
 Task *dequeue_task(long qid, long max_visit, long process_id)
   /*
    *    Attempts to dequeue first from the specified queue (qid), but if no
@@ -1570,34 +1640,19 @@ Task *dequeue_task(long qid, long max_vi
             if( tq->n_tasks > 0 )
                 {
                     /* Lock the task queue */
-                    {pthread_mutex_lock(&(tq->q_lock));};
-                    if( tq->top )
+                    { union instance141 instance141 = {
                         {
-                            if( qid == taskqueue_id[process_id] )
-                                {
-                                    t = tq->top ;
-                                    tq->top = t->next ;
-                                    if( tq->top == 0 )
-                                        tq->tail = 0 ;
-                                    tq->n_tasks-- ;
-                                }
-                            else
-                                {
-                                    /* Get tail */
-                                    for( prev = 0, t = tq->top ; t->next ;
-                                        prev = t, t = t->next ) ;
-
-                                    if( prev == 0 )
-                                        tq->top = 0 ;
-                                    else
-                                        prev->next = 0 ;
-                                    tq->tail = prev ;
-                                    tq->n_tasks-- ;
-                                }
-                        }
-                    /* Unlock the task queue */
-                    {pthread_mutex_unlock(&(tq->q_lock));};
-                    break ;
+                            tq,
+                            t,
+                            process_id,
+                            qid,
+                        },
+                    };
+                    
+                    t =(Task *)(uintptr_t)(liblock_execute_operation(&(tq->q_lock), (void *)(uintptr_t)(&instance141),
+                                              &function142));
+                    }
+                    break;
                 }
 
             /* Update visit count */
@@ -1614,10 +1669,48 @@ Task *dequeue_task(long qid, long max_vi
                 qid -= n_taskqueues ;
         }
 
-    return( t ) ;
+    return(( t )) ;
 }
 
 
+union instance148 {struct input146{Task_Queue *tq;Task *p;long process_id;long i;} input146;
+struct output145{Task *p;long i;} output145;};
+void * function149(void *ctx147);
+void *function149(void *ctx147) {
+    {
+        struct output145 *outcontext143=&(((union instance148 *)ctx147)->output145);
+        struct input146 *incontext144=&(((union instance148 *)ctx147)->input146);
+        int ret113;
+        Task_Queue *tq=incontext144->tq;
+        Task *p=incontext144->p;
+        long process_id=incontext144->process_id;
+        long i=incontext144->i;
+        p = p;
+        i = i;
+        {
+            ret113 = 0;
+            if (tq->free) {
+                for (i = 1, p = tq->free;(i < N_ALLOCATE_LOCAL_TASK) && p->next;i++, p = p->next)
+                    ;
+                task_struct[process_id].local_free_task = tq->free;
+                task_struct[process_id].n_local_free_task = i;
+                tq->free = p->next;
+                tq->n_free -= i;
+                p->next = 0;
+                ret113 = 112 + 1;
+                goto done114;
+            }
+            done114:
+            {
+                
+            }
+        }
+        outcontext143->p = p;
+        outcontext143->i = i;
+        return (void *)(uintptr_t)ret113;
+    }
+}
+
 /***************************************************************************
  *
  *    get_task()    Create a new instance of Task
@@ -1628,6 +1721,7 @@ Task *dequeue_task(long qid, long max_vi
 
 Task *get_task(long process_id)
 {
+    int ret113;
     Task *p ;
     Task_Queue *tq ;
     long i ;
@@ -1646,23 +1740,28 @@ Task *get_task(long process_id)
 
                     if( tq->n_free > 0 )
                         {
-                            {pthread_mutex_lock(&(tq->f_lock));};
-                            if( tq->free )
+                            { union instance148 instance148 = {
                                 {
-                                    /* Scan the free list */
-                                    for( i = 1, p = tq->free ;
-                                        (i < N_ALLOCATE_LOCAL_TASK) && p->next ;
-                                        i++, p = p->next ) ;
-
-                                    task_struct[process_id].local_free_task = tq->free ;
-                                    task_struct[process_id].n_local_free_task = i ;
-                                    tq->free = p->next ;
-                                    tq->n_free -= i ;
-                                    p->next = 0 ;
-                                    {pthread_mutex_unlock(&(tq->f_lock));};
-                                    break ;
-                                }
-                            {pthread_mutex_unlock(&(tq->f_lock));};
+                                    tq,
+                                    p,
+                                    process_id,
+                                    i,
+                                },
+                            };
+                            
+                            ret113 =(int)(uintptr_t)(liblock_execute_operation(&(tq->f_lock),
+                                                      (void *)(uintptr_t)(&instance148),
+                                                      &function149));
+                                                      p = instance148.output145.p;
+                                                      i = instance148.output145.i;
+                                                      }
+                            if (ret113) {
+                                if (ret113 == 112 + 1)
+                                    {
+                                        break;
+                                    }
+                                
+                            }
                         }
 
                     /* Try next task queue */
@@ -1694,11 +1793,29 @@ Task *get_task(long process_id)
     p->next = 0 ;
 
 
-    return( p ) ;
+    return(( p )) ;
 }
 
 
 
+union instance155 {struct input153{Task_Queue *tq;Task *top;Task *p;long i;} input153;};
+void * function156(void *ctx154);
+void *function156(void *ctx154) {
+    {
+        struct input153 *incontext151=&(((union instance155 *)ctx154)->input153);
+        Task_Queue *tq=incontext151->tq;
+        Task *top=incontext151->top;
+        Task *p=incontext151->p;
+        long i=incontext151->i;
+        {
+            p->next = tq->free;
+            tq->free = top;
+            tq->n_free += i;
+        }
+        return NULL;
+    }
+}
+
 void free_task(Task *task, long process_id)
 {
     Task_Queue *tq ;
@@ -1724,11 +1841,17 @@ void free_task(Task *task, long process_
             task_struct[process_id].n_local_free_task -= i ;
 
             /* Insert in the shared list */
-            {pthread_mutex_lock(&(tq->f_lock));};
-            p->next = tq->free ;
-            tq->free = top ;
-            tq->n_free += i ;
-            {pthread_mutex_unlock(&(tq->f_lock));};
+            { union instance155 instance155 = {
+                {
+                    tq,
+                    top,
+                    p,
+                    i,
+                },
+            };
+            
+            liblock_execute_operation(&(tq->f_lock), (void *)(uintptr_t)(&instance155),
+                                      &function156); }
         }
 }
 
@@ -1779,8 +1902,10 @@ void init_taskq(long process_id)
             global->task_queue[ qid ].n_tasks = 0 ;
 
             /* Initialize locks */
-            pthread_mutex_init(&(global->task_queue[ qid ].q_lock), NULL);;
-            pthread_mutex_init(&(global->task_queue[ qid ].f_lock), NULL);;
+            liblock_lock_init(TYPE_RADIOSITY_4, ARG_RADIOSITY_4,
+                              &(global->task_queue[qid].q_lock), NULL);;
+            liblock_lock_init(TYPE_NOINFO, ARG_NOINFO,
+                              &(global->task_queue[qid].f_lock), NULL);;
 
             /* Update index for next queue */
             task_index += n_tasks ;
@@ -1793,6 +1918,22 @@ void init_taskq(long process_id)
 
 
 
+void * function163(void *ctx161);
+void *function163(void *ctx161) {
+    {
+        long flag=(long)(uintptr_t)ctx161;
+        flag = flag;
+        {
+            if (global->task_counter == 0)
+                flag = 1;
+            global->task_counter++;
+            if (global->task_counter >= n_processors)
+                global->task_counter = 0;
+        }
+        return (void *)(uintptr_t)flag;
+    }
+}
+
 /***************************************************************************
  *
  *    check_task_counter()
@@ -1806,19 +1947,13 @@ long check_task_counter()
     long flag = 0 ;
 
 
-    {pthread_mutex_lock(&(global->task_counter_lock));};
-
-    if( global->task_counter == 0 )
-        /* First processor */
-        flag = 1 ;
-
-    global->task_counter++ ;
-    if( global->task_counter >= n_processors )
-        global->task_counter = 0 ;
-
-    {pthread_mutex_unlock(&(global->task_counter_lock));};
+    {
+    
+    flag =(long)(uintptr_t)(liblock_execute_operation(&(global->task_counter_lock), (void *)(uintptr_t)(flag),
+                              &function163));
+    }
 
-    return( flag ) ;
+    return(( flag )) ;
 }
 
 
@@ -1840,7 +1975,7 @@ long assign_taskq(long process_id)
     if( task_struct[process_id].crnt_taskq_id >= n_taskqueues )
         task_struct[process_id].crnt_taskq_id = 0 ;
 
-    return( qid ) ;
+    return(( qid )) ;
 }
 
 
@@ -1858,31 +1993,31 @@ void print_task(Task *task)
     if( task == 0 )
         {
             printf( "Task (NULL)\n" ) ;
-            return ;
+            return;
         }
 
     switch( task->task_type )
         {
         case TASK_MODELING:
             printf( "Task (Model)\n" ) ;
-            break ;
+            break;
         case TASK_BSP:
             printf( "Task (BSP)\n" ) ;
-            break ;
+            break;
         case TASK_FF_REFINEMENT:
             printf( "Task (FF Refinement)\n" ) ;
-            break ;
+            break;
         case TASK_RAY:
             printf( "Task (Ray)  (patch ID %ld)\n",
                    task->task.ray.e->patch->seq_no ) ;
-            break ;
+            break;
         case TASK_VISIBILITY:
             printf( "Task (Visibility)  (patch ID %ld)\n",
                    task->task.vis.e->patch->seq_no ) ;
-            break ;
+            break;
         case TASK_RAD_AVERAGE:
             printf( "Task (RadAvg)\n" ) ;
-            break ;
+            break;
         default:
             fprintf( stderr, "Task(Illegal task type %ld)\n", task->task_type );
         }
diff -u -p a/codes/apps/radiosity/room_model.c b/codes/apps/radiosity/room_model.c
--- a/codes/apps/radiosity/room_model.c
+++ b/codes/apps/radiosity/room_model.c
@@ -29,9 +29,17 @@
 
 
 #include <pthread.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <sys/time.h>
 #include <unistd.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <malloc.h>
 extern pthread_t PThreadTable[];
 ;
@@ -104,7 +112,7 @@ of the program, as well as lobal data st
 
 typedef struct
 {
-    pthread_mutex_t lock;
+    liblock_lock_t lock;
 } Shared_Lock ;
 
 #define SHARED_LOCK_SEG_SIZE (MAX_SHARED_LOCK / 2)
@@ -655,10 +663,10 @@ typedef struct _task {
 typedef struct {
     char pad1[PAGE_SIZE];	 	/* padding to avoid false-sharing
     and allow page-placement */
-    pthread_mutex_t q_lock;
+    liblock_lock_t q_lock;
     Task  *top, *tail ;
     long   n_tasks ;
-    pthread_mutex_t f_lock;
+    liblock_lock_t f_lock;
     long   n_free ;
     Task  *free ;
     char pad2[PAGE_SIZE];	 	/* padding to avoid false-sharing
@@ -926,16 +934,16 @@ typedef struct
 
     /* Task queue */
     /* ***** */ long index;
-    /* ***** */	pthread_mutex_t index_lock;
+    /* ***** */	liblock_lock_t index_lock;
     Task_Queue task_queue[ MAX_TASKQUEUES ] ;
     Task task_buf[ MAX_TASKS ] ;
 
     /* BSP tree root */
-    pthread_mutex_t bsp_tree_lock;
+    liblock_lock_t bsp_tree_lock;
     Patch *bsp_root ;
 
     /* Average radiosity value */
-    pthread_mutex_t avg_radiosity_lock;
+    liblock_lock_t avg_radiosity_lock;
     long   converged ;
     Rgb   prev_total_energy ;
     Rgb   total_energy ;
@@ -943,7 +951,7 @@ typedef struct
     long   iteration_count ;
 
     /* Computation cost estimate */
-    pthread_mutex_t cost_sum_lock;
+    liblock_lock_t cost_sum_lock;
     long cost_sum ;
     long cost_estimate_sum ;
     Patch_Cost patch_cost[ MAX_PATCHES ] ;
@@ -955,34 +963,34 @@ pthread_barrier_t	(barrier);
 
     /* Private varrier */
     long pbar_count ;
-    pthread_mutex_t pbar_lock;
+    liblock_lock_t pbar_lock;
 
     /* Task initializer counter */
     long task_counter ;
-    pthread_mutex_t task_counter_lock;
+    liblock_lock_t task_counter_lock;
 
     /* Resource buffers */
-    pthread_mutex_t free_patch_lock;
+    liblock_lock_t free_patch_lock;
     Patch *free_patch ;
     long   n_total_patches ;
     long   n_free_patches ;
     Patch patch_buf[ MAX_PATCHES ] ;
 
-    pthread_mutex_t free_element_lock;
+    liblock_lock_t free_element_lock;
     Element *free_element ;
     long     n_free_elements ;
     Element element_buf[ MAX_ELEMENTS ] ;
 
-    pthread_mutex_t free_interaction_lock;
+    liblock_lock_t free_interaction_lock;
     Interaction *free_interaction ;
     long         n_free_interactions ;
     Interaction interaction_buf[ MAX_INTERACTIONS ] ;
 
-    pthread_mutex_t free_elemvertex_lock;
+    liblock_lock_t free_elemvertex_lock;
     long         free_elemvertex ;
     ElemVertex  elemvertex_buf[ MAX_ELEMVERTICES ] ;
 
-    pthread_mutex_t free_edge_lock;
+    liblock_lock_t free_edge_lock;
     long   free_edge ;
     Edge  edge_buf[ MAX_EDGES ] ;
 
diff -u -p a/codes/apps/radiosity/parallel.h b/codes/apps/radiosity/parallel.h
--- a/codes/apps/radiosity/parallel.h
+++ b/codes/apps/radiosity/parallel.h
@@ -39,7 +39,7 @@
 
 typedef struct
 {
-    pthread_mutex_t lock;
+    liblock_lock_t lock;
 } Shared_Lock ;
 
 #define SHARED_LOCK_SEG_SIZE (MAX_SHARED_LOCK / 2)
diff -u -p a/codes/apps/radiosity/elemman.c b/codes/apps/radiosity/elemman.c
--- a/codes/apps/radiosity/elemman.c
+++ b/codes/apps/radiosity/elemman.c
@@ -28,9 +28,17 @@
 
 
 #include <pthread.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <sys/time.h>
 #include <unistd.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <malloc.h>
 extern pthread_t PThreadTable[];
 ;
@@ -101,7 +109,7 @@ of the program, as well as lobal data st
 
 typedef struct
 {
-    pthread_mutex_t lock;
+    liblock_lock_t lock;
 } Shared_Lock ;
 
 #define SHARED_LOCK_SEG_SIZE (MAX_SHARED_LOCK / 2)
@@ -652,10 +660,10 @@ typedef struct _task {
 typedef struct {
     char pad1[PAGE_SIZE];	 	/* padding to avoid false-sharing
     and allow page-placement */
-    pthread_mutex_t q_lock;
+    liblock_lock_t q_lock;
     Task  *top, *tail ;
     long   n_tasks ;
-    pthread_mutex_t f_lock;
+    liblock_lock_t f_lock;
     long   n_free ;
     Task  *free ;
     char pad2[PAGE_SIZE];	 	/* padding to avoid false-sharing
@@ -923,16 +931,16 @@ typedef struct
 
     /* Task queue */
     /* ***** */ long index;
-    /* ***** */	pthread_mutex_t index_lock;
+    /* ***** */	liblock_lock_t index_lock;
     Task_Queue task_queue[ MAX_TASKQUEUES ] ;
     Task task_buf[ MAX_TASKS ] ;
 
     /* BSP tree root */
-    pthread_mutex_t bsp_tree_lock;
+    liblock_lock_t bsp_tree_lock;
     Patch *bsp_root ;
 
     /* Average radiosity value */
-    pthread_mutex_t avg_radiosity_lock;
+    liblock_lock_t avg_radiosity_lock;
     long   converged ;
     Rgb   prev_total_energy ;
     Rgb   total_energy ;
@@ -940,7 +948,7 @@ typedef struct
     long   iteration_count ;
 
     /* Computation cost estimate */
-    pthread_mutex_t cost_sum_lock;
+    liblock_lock_t cost_sum_lock;
     long cost_sum ;
     long cost_estimate_sum ;
     Patch_Cost patch_cost[ MAX_PATCHES ] ;
@@ -952,34 +960,34 @@ pthread_barrier_t	(barrier);
 
     /* Private varrier */
     long pbar_count ;
-    pthread_mutex_t pbar_lock;
+    liblock_lock_t pbar_lock;
 
     /* Task initializer counter */
     long task_counter ;
-    pthread_mutex_t task_counter_lock;
+    liblock_lock_t task_counter_lock;
 
     /* Resource buffers */
-    pthread_mutex_t free_patch_lock;
+    liblock_lock_t free_patch_lock;
     Patch *free_patch ;
     long   n_total_patches ;
     long   n_free_patches ;
     Patch patch_buf[ MAX_PATCHES ] ;
 
-    pthread_mutex_t free_element_lock;
+    liblock_lock_t free_element_lock;
     Element *free_element ;
     long     n_free_elements ;
     Element element_buf[ MAX_ELEMENTS ] ;
 
-    pthread_mutex_t free_interaction_lock;
+    liblock_lock_t free_interaction_lock;
     Interaction *free_interaction ;
     long         n_free_interactions ;
     Interaction interaction_buf[ MAX_INTERACTIONS ] ;
 
-    pthread_mutex_t free_elemvertex_lock;
+    liblock_lock_t free_elemvertex_lock;
     long         free_elemvertex ;
     ElemVertex  elemvertex_buf[ MAX_ELEMVERTICES ] ;
 
-    pthread_mutex_t free_edge_lock;
+    liblock_lock_t free_edge_lock;
     long   free_edge ;
     Edge  edge_buf[ MAX_EDGES ] ;
 
@@ -1187,8 +1195,10 @@ void foreach_element_in_patch(Patch *pat
 
 static void _foreach_element(Element *elem, void (*func)(), long   arg1, long process_id)
 {
-    if( elem == 0 )
-        return ;
+    if( elem == 0 ) {
+        
+            return;
+        }
 
     /* Process children */
     if( ! LEAF_ELEMENT( elem ) )
@@ -1212,8 +1222,10 @@ void foreach_leaf_element_in_patch(Patch
 
 static void _foreach_leaf_element(Element *elem, void (*func)(), long arg1, long process_id )
 {
-    if( elem == 0 )
-        return ;
+    if( elem == 0 ) {
+        
+            return;
+        }
 
     /* Process children */
     if( LEAF_ELEMENT( elem ) )
@@ -1229,6 +1241,27 @@ static void _foreach_leaf_element(Elemen
 
 
 
+union instance178 {struct input176{volatile Patch_Cost *pc2;volatile Patch_Cost *pc1;long cost2;long cost1;} input176;};
+void * function179(void *ctx177);
+void *function179(void *ctx177) {
+    {
+        struct input176 *incontext174=&(((union instance178 *)ctx177)->input176);
+        volatile Patch_Cost *pc2=incontext174->pc2;
+        volatile Patch_Cost *pc1=incontext174->pc1;
+        long cost2=incontext174->cost2;
+        long cost1=incontext174->cost1;
+        {
+            pc1->cost_estimate += cost1;
+            pc1->n_total_inter++;
+            pc2->cost_estimate += cost2;
+            pc2->n_total_inter++;
+            global->cost_estimate_sum += (cost1 + cost2);
+            global->cost_sum += (cost1 + cost2);
+        }
+        return NULL;
+    }
+}
+
 /***************************************************************************
  *
  *    ff_refine_elements()
@@ -1265,7 +1298,9 @@ void ff_refine_elements(Element *e1, Ele
     /* Execute subdivision procedure */
     if( NO_INTERACTION(subdiv_advice) )
         /* Two elements are mutually invisible. Do nothing */
-        return ;
+        {
+            return;
+        }
 
     else if( NO_REFINEMENT_NECESSARY(subdiv_advice) )
         {
@@ -1294,14 +1329,17 @@ void ff_refine_elements(Element *e1, Ele
             else
                 cost2 = 1 ;
 
-            {pthread_mutex_lock(&(global->cost_sum_lock));};
-            pc1->cost_estimate += cost1 ;
-            pc1->n_total_inter++ ;
-            pc2->cost_estimate += cost2 ;
-            pc2->n_total_inter++ ;
-            global->cost_estimate_sum += (cost1 + cost2) ;
-            global->cost_sum += (cost1 + cost2) ;
-            {pthread_mutex_unlock(&(global->cost_sum_lock));};
+            { union instance178 instance178 = {
+                {
+                    pc2,
+                    pc1,
+                    cost2,
+                    cost1,
+                },
+            };
+            
+            liblock_execute_operation(&(global->cost_sum_lock), (void *)(uintptr_t)(&instance178),
+                                      &function179); }
 #endif
         }
 
@@ -1348,15 +1386,19 @@ long error_analysis(Element *e1, Element
                             &e2->ev1->p, &e2->ev2->p, &e2->ev3->p, process_id ) ;
     if( NEGATIVE_SIDE(cc) )
         /* If negative or on the plane, then do nothing */
-        return( _NO_INTERACTION ) ;
+        {
+            return(( _NO_INTERACTION )) ;
+        }
 
     cc = patch_intersection( &e2->patch->plane_equ,
                             &e1->ev1->p, &e1->ev2->p, &e1->ev3->p, process_id ) ;
     if( NEGATIVE_SIDE(cc) )
         /* If negative or on the plane, then do nothing */
-        return( _NO_INTERACTION ) ;
+        {
+            return(( _NO_INTERACTION )) ;
+        }
 
-    return( _NO_REFINEMENT_NECESSARY ) ;
+    return(( _NO_REFINEMENT_NECESSARY )) ;
 }
 
 
@@ -1467,12 +1509,44 @@ static long  bf_refine_element(long subd
                 }
         }
 
-    return( new_inter ) ;
+    return(( new_inter )) ;
 }
 
 
 
 
+union instance192 {struct input190{Patch_Cost *pc;long delta_n_inter;} input190;};
+union instance185 {struct input183{Interaction *i_list;Interaction *prev;Element *elem;long i_len;} input183;};
+void * function193(void *ctx191);
+void *function193(void *ctx191) {
+    {
+        struct input190 *incontext188=&(((union instance192 *)ctx191)->input190);
+        Patch_Cost *pc=incontext188->pc;
+        long delta_n_inter=incontext188->delta_n_inter;
+        {
+            pc->n_total_inter += delta_n_inter;
+        }
+        return NULL;
+    }
+}
+
+void * function186(void *ctx184);
+void *function186(void *ctx184) {
+    {
+        struct input183 *incontext181=&(((union instance185 *)ctx184)->input183);
+        Interaction *i_list=incontext181->i_list;
+        Interaction *prev=incontext181->prev;
+        Element *elem=incontext181->elem;
+        long i_len=incontext181->i_len;
+        {
+            prev->next = elem->interactions;
+            elem->interactions = i_list;
+            elem->n_interactions += i_len;
+        }
+        return NULL;
+    }
+}
+
 /***************************************************************************
  *
  *    bf_error_analysis_list()
@@ -1529,11 +1603,17 @@ void bf_error_analysis_list(Element *ele
     /* Link good interactions to elem->intearctions */
     if( i_len > 0 )
         {
-            {pthread_mutex_lock(&(elem->elem_lock->lock));};
-            prev->next = elem->interactions ;
-            elem->interactions = i_list ;
-            elem->n_interactions += i_len ;
-            {pthread_mutex_unlock(&(elem->elem_lock->lock));};
+            { union instance185 instance185 = {
+                {
+                    i_list,
+                    prev,
+                    elem,
+                    i_len,
+                },
+            };
+            
+            liblock_execute_operation(&(elem->elem_lock->lock), (void *)(uintptr_t)(&instance185),
+                                      &function186); }
         }
 
 #if PATCH_ASSIGNMENT == PATCH_ASSIGNMENT_COSTBASED
@@ -1543,9 +1623,15 @@ void bf_error_analysis_list(Element *ele
             Patch_Cost *pc ;
 
             pc = &global->patch_cost[ elem->patch->seq_no ] ;
-            {pthread_mutex_lock(&(pc->cost_lock->lock));};
-            pc->n_total_inter += delta_n_inter ;
-            {pthread_mutex_unlock(&(pc->cost_lock->lock));};
+            { union instance192 instance192 = {
+                {
+                    pc,
+                    delta_n_inter,
+                },
+            };
+            
+            liblock_execute_operation(&(pc->cost_lock->lock), (void *)(uintptr_t)(&instance192),
+                                      &function193); }
         }
 #endif
 }
@@ -1589,27 +1675,35 @@ long bf_error_analysis(Element *elem, In
                    + visibility_error * inter->formfactor_err) * rad_avg ;
 
     /* If BF is smaller than the threshold, then not subdivide */
-    if( (total_error <= BFepsilon) && (elem->n_interactions <= 10) )
-        return( _NO_REFINEMENT_NECESSARY ) ;
-    else if( total_error <= BFepsilon * 0.5 )
-        return( _NO_REFINEMENT_NECESSARY ) ;
+    if( (total_error <= BFepsilon) && (elem->n_interactions <= 10) ) {
+        
+            return(( _NO_REFINEMENT_NECESSARY )) ;
+        }
+    else if( total_error <= BFepsilon * 0.5 ) {
+        
+            return(( _NO_REFINEMENT_NECESSARY )) ;
+        }
 
     /* Subdivide light source or receiver whichever is larger */
     if( elem->area > inter->destination->area )
         {
             if( elem->area > Area_epsilon )
                 /* Subdivide this element (receiver) */
-                return( _REFINE_PATCH_1 | vis_code ) ;
+                {
+                    return(( _REFINE_PATCH_1 | vis_code )) ;
+                }
         }
     else
         {
             if( inter->destination->area > Area_epsilon )
 
                 /* Subdivide source element */
-                return( _REFINE_PATCH_2 | vis_code ) ;
+                {
+                    return(( _REFINE_PATCH_2 | vis_code )) ;
+                }
         }
 
-    return( _NO_REFINEMENT_NECESSARY ) ;
+    return(( _NO_REFINEMENT_NECESSARY )) ;
 }
 
 
@@ -1653,13 +1747,114 @@ long radiosity_converged(long process_id
             printf( "Difference %.2f%%\n", difference * 100.0 ) ;
         }
 
-    if( difference <=  Energy_epsilon )
-        return( 1 ) ;
+    if( difference <=  Energy_epsilon ) {
+        
+            return(( 1 )) ;
+        }
     else
-        return( 0 ) ;
+        {
+            return(( 0 )) ;
+        }
 }
 
 
+union instance199 {struct input197{Element *e;long process_id;} input197;};
+void * function200(void *ctx198);
+void *function200(void *ctx198) {
+    {
+        struct input197 *incontext195=&(((union instance199 *)ctx198)->input197);
+        Element *ecenter;
+        Element *enew;
+        ElemVertex *ev_31;
+        ElemVertex *ev_23;
+        ElemVertex *ev_12;
+        Edge *e_31_12;
+        Edge *e_23_31;
+        Edge *e_12_23;
+        float quarter_area;
+        long rev_31;
+        long rev_23;
+        long rev_12;
+        int ret167;
+        Element *e=incontext195->e;
+        long process_id=incontext195->process_id;
+        {
+            ret167 = 0;
+            if (!_LEAF_ELEMENT(e)) {
+                ret167 = 164 + 1;
+                goto done168;
+            }
+            subdivide_edge(e->e12, (float)0.5, process_id);
+            subdivide_edge(e->e23, (float)0.5, process_id);
+            subdivide_edge(e->e31, (float)0.5, process_id);
+            ev_12 = e->e12->ea->pb;
+            ev_23 = e->e23->ea->pb;
+            ev_31 = e->e31->ea->pb;
+            e_12_23 = create_edge(ev_12, ev_23, process_id);
+            e_23_31 = create_edge(ev_23, ev_31, process_id);
+            e_31_12 = create_edge(ev_31, ev_12, process_id);
+            quarter_area = e->area * (float)0.25;
+            enew = get_element(process_id);
+            ecenter = enew;
+            enew->parent = e;
+            enew->patch = e->patch;
+            enew->ev1 = ev_23;
+            enew->ev2 = ev_31;
+            enew->ev3 = ev_12;
+            enew->e12 = e_23_31;
+            enew->e23 = e_31_12;
+            enew->e31 = e_12_23;
+            enew->area = quarter_area;
+            enew->rad = e->rad;
+            rev_12 = EDGE_REVERSE(e->e12, e->ev1, e->ev2);
+            rev_23 = EDGE_REVERSE(e->e23, e->ev2, e->ev3);
+            rev_31 = EDGE_REVERSE(e->e31, e->ev3, e->ev1);
+            enew = get_element(process_id);
+            e->top = enew;
+            enew->parent = e;
+            enew->patch = e->patch;
+            enew->ev1 = e->ev1;
+            enew->ev2 = ev_12;
+            enew->ev3 = ev_31;
+            enew->e12 = (!rev_12) ? e->e12->ea : e->e12->eb;
+            enew->e23 = e_31_12;
+            enew->e31 = (!rev_31) ? e->e31->eb : e->e31->ea;
+            enew->area = quarter_area;
+            enew->rad = e->rad;
+            enew = get_element(process_id);
+            e->left = enew;
+            enew->parent = e;
+            enew->patch = e->patch;
+            enew->ev1 = ev_12;
+            enew->ev2 = e->ev2;
+            enew->ev3 = ev_23;
+            enew->e12 = (!rev_12) ? e->e12->eb : e->e12->ea;
+            enew->e23 = (!rev_23) ? e->e23->ea : e->e23->eb;
+            enew->e31 = e_12_23;
+            enew->area = quarter_area;
+            enew->rad = e->rad;
+            enew = get_element(process_id);
+            e->right = enew;
+            enew->parent = e;
+            enew->patch = e->patch;
+            enew->ev1 = ev_31;
+            enew->ev2 = ev_23;
+            enew->ev3 = e->ev3;
+            enew->e12 = e_23_31;
+            enew->e23 = (!rev_23) ? e->e23->eb : e->e23->ea;
+            enew->e31 = (!rev_31) ? e->e31->ea : e->e31->eb;
+            enew->area = quarter_area;
+            enew->rad = e->rad;
+            e->center = ecenter;
+            done168:
+            {
+                
+            }
+        }
+        return (void *)(uintptr_t)ret167;
+    }
+}
+
 /***************************************************************************
  *
  *    subdivide_element()
@@ -1670,6 +1865,7 @@ long radiosity_converged(long process_id
 
 void subdivide_element(Element *e, long process_id)
 {
+    int ret167;
     float quarter_area ;
     ElemVertex *ev_12, *ev_23, *ev_31 ;
     Edge *e_12_23, *e_23_31, *e_31_12 ;
@@ -1677,99 +1873,40 @@ void subdivide_element(Element *e, long 
     long rev_12, rev_23, rev_31 ;
 
     /* Lock the element before checking the value */
-    {pthread_mutex_lock(&(e->elem_lock->lock));};
-
-    /* Check if the element already has children */
-    if( ! _LEAF_ELEMENT(e) )
+    { union instance199 instance199 = {
         {
-            {pthread_mutex_unlock(&(e->elem_lock->lock));};
-            return ;
-        }
-
-    /* Subdivide edge structures */
-    subdivide_edge( e->e12, (float)0.5, process_id ) ;
-    subdivide_edge( e->e23, (float)0.5, process_id ) ;
-    subdivide_edge( e->e31, (float)0.5, process_id ) ;
-    ev_12 = e->e12->ea->pb ;
-    ev_23 = e->e23->ea->pb ;
-    ev_31 = e->e31->ea->pb ;
-
-    /* Then create new edges */
-    e_12_23 = create_edge( ev_12, ev_23, process_id ) ;
-    e_23_31 = create_edge( ev_23, ev_31, process_id ) ;
-    e_31_12 = create_edge( ev_31, ev_12, process_id ) ;
-
-    /* Area parameters */
-    quarter_area = e->area * (float)0.25 ;
-
-    /* (1) Create the center patch */
-    enew = get_element(process_id) ;
-    ecenter = enew ;
-    enew->parent= e ;
-    enew->patch = e->patch ;
-    enew->ev1   = ev_23 ;
-    enew->ev2   = ev_31 ;
-    enew->ev3   = ev_12 ;
-    enew->e12   = e_23_31 ;
-    enew->e23   = e_31_12 ;
-    enew->e31   = e_12_23 ;
-    enew->area  = quarter_area ;
-    enew->rad   = e->rad ;
-
-    /* (2) Create the top patch */
-    rev_12 = EDGE_REVERSE( e->e12, e->ev1, e->ev2 ) ;
-    rev_23 = EDGE_REVERSE( e->e23, e->ev2, e->ev3 ) ;
-    rev_31 = EDGE_REVERSE( e->e31, e->ev3, e->ev1 ) ;
-
-    enew = get_element(process_id) ;
-    e->top = enew ;
-    enew->parent= e ;
-    enew->patch = e->patch ;
-    enew->ev1   = e->ev1 ;
-    enew->ev2   = ev_12 ;
-    enew->ev3   = ev_31 ;
-    enew->e12   = (!rev_12)? e->e12->ea : e->e12->eb ;
-    enew->e23   = e_31_12 ;
-    enew->e31   = (!rev_31)? e->e31->eb : e->e31->ea ;
-    enew->area  = quarter_area ;
-    enew->rad   = e->rad ;
-
-    /* (3) Create the left patch */
-    enew = get_element(process_id) ;
-    e->left = enew ;
-    enew->parent= e ;
-    enew->patch = e->patch ;
-    enew->ev1   = ev_12 ;
-    enew->ev2   = e->ev2 ;
-    enew->ev3   = ev_23 ;
-    enew->e12   = (!rev_12)? e->e12->eb : e->e12->ea ;
-    enew->e23   = (!rev_23)? e->e23->ea : e->e23->eb ;
-    enew->e31   = e_12_23 ;
-    enew->area  = quarter_area ;
-    enew->rad   = e->rad ;
-
-    /* (4) Create the right patch */
-    enew = get_element(process_id) ;
-    e->right = enew ;
-    enew->parent= e ;
-    enew->patch = e->patch ;
-    enew->ev1   = ev_31 ;
-    enew->ev2   = ev_23 ;
-    enew->ev3   = e->ev3 ;
-    enew->e12   = e_23_31 ;
-    enew->e23   = (!rev_23)? e->e23->eb : e->e23->ea ;
-    enew->e31   = (!rev_31)? e->e31->ea : e->e31->eb ;
-    enew->area  = quarter_area ;
-    enew->rad   = e->rad ;
+            e,
+            process_id,
+        },
+    };
+    
+    ret167 =(int)(uintptr_t)(liblock_execute_operation(&(e->elem_lock->lock), (void *)(uintptr_t)(&instance199),
+                              &function200));
+    }
+    if (ret167) {
+        if (ret167 == 164 + 1)
+            {
+                return;
+            }
+        
+    }
+}
 
-    /* Finally, set e->center */
-    e->center = ecenter ;
 
-    /* Unlock the element */
-    {pthread_mutex_unlock(&(e->elem_lock->lock));};
+void * function207(void *ctx205);
+void *function207(void *ctx205) {
+    {
+        Interaction *i_list;
+        Element *e=(Element *)(uintptr_t)ctx205;
+        {
+            i_list = e->interactions;
+            e->interactions = (Interaction *)0;
+            e->n_interactions = 0;
+        }
+        return (void *)(uintptr_t)i_list;
+    }
 }
 
-
 /***************************************************************************
  *
  *    process_rays()
@@ -1823,11 +1960,11 @@ void process_rays(Element *e, long proce
     Interaction *i_list ;
 
     /* Detach interactions from the list */
-    {pthread_mutex_lock(&(e->elem_lock->lock));};
-    i_list = e->interactions ;
-    e->interactions = (Interaction *)0 ;
-    e->n_interactions = 0 ;
-    {pthread_mutex_unlock(&(e->elem_lock->lock));};
+    {
+    
+    i_list =(Interaction *)(uintptr_t)(liblock_execute_operation(&(e->elem_lock->lock), (void *)(uintptr_t)(e),
+                              &function207));
+    }
 
     /* For each interaction, do BF-error-analysis */
     bf_error_analysis_list( e, i_list, process_id ) ;
@@ -1843,17 +1980,31 @@ void process_rays(Element *e, long proce
 
 
 
+void * function214(void *ctx212);
+void *function214(void *ctx212) {
+    {
+        Interaction *i_list;
+        Element *e=(Element *)(uintptr_t)ctx212;
+        {
+            i_list = e->vis_undef_inter;
+            e->vis_undef_inter = (Interaction *)0;
+            e->n_vis_undef_inter = 0;
+        }
+        return (void *)(uintptr_t)i_list;
+    }
+}
+
 static void process_rays2(Element *e, long process_id)
 {
     Interaction *i_list ;
 
     /* Detach interactions from the vis-undef-list. They now have their
        visibility computed */
-    {pthread_mutex_lock(&(e->elem_lock->lock));};
-    i_list = e->vis_undef_inter ;
-    e->vis_undef_inter = (Interaction *)0 ;
-    e->n_vis_undef_inter = 0 ;
-    {pthread_mutex_unlock(&(e->elem_lock->lock));};
+    {
+    
+    i_list =(Interaction *)(uintptr_t)(liblock_execute_operation(&(e->elem_lock->lock), (void *)(uintptr_t)(e),
+                              &function214));
+    }
 
     /* For each interaction, do BF-error-analysis */
     bf_error_analysis_list( e, i_list, process_id ) ;
@@ -1919,6 +2070,51 @@ static void process_rays3(Element *e, lo
 
 
 
+union instance220 {struct input218{Element *ec;Element *e;} input218;};
+void * function235(void *ctx233);
+void *function235(void *ctx233) {
+    {
+        Patch_Cost *pc=(Patch_Cost *)(uintptr_t)ctx233;
+        {
+            global->cost_sum += pc->cost_history[0];
+            global->cost_estimate_sum += pc->cost_estimate;
+        }
+        return NULL;
+    }
+}
+
+void * function228(void *ctx226);
+void *function228(void *ctx226) {
+    {
+        Element *ec=(Element *)(uintptr_t)ctx226;
+        {
+            global->total_energy.r += ec->rad.r * ec->area;
+            global->total_energy.g += ec->rad.g * ec->area;
+            global->total_energy.b += ec->rad.b * ec->area;
+            global->total_patch_area += ec->area;
+        }
+        return NULL;
+    }
+}
+
+void * function221(void *ctx219);
+void *function221(void *ctx219) {
+    {
+        struct input218 *incontext216=&(((union instance220 *)ctx219)->input218);
+        long join_flag;
+        Element *ec=incontext216->ec;
+        Element *e=incontext216->e;
+        {
+            e->rad_subtree.r += ec->rad_subtree.r * (float)0.25;
+            e->rad_subtree.g += ec->rad_subtree.g * (float)0.25;
+            e->rad_subtree.b += ec->rad_subtree.b * (float)0.25;
+            e->join_counter--;
+            join_flag = (e->join_counter == 0);
+        }
+        return (void *)(uintptr_t)join_flag;
+    }
+}
+
 /***************************************************************************
  *
  *    elem_join_operation()
@@ -1947,17 +2143,22 @@ static void elem_join_operation(Element 
     while( e != 0 )
         {
             /* Get radiosity of the child and add to my radiosity */
-            {pthread_mutex_lock(&(e->elem_lock->lock));};
-            e->rad_subtree.r += ec->rad_subtree.r * (float)0.25 ;
-            e->rad_subtree.g += ec->rad_subtree.g * (float)0.25 ;
-            e->rad_subtree.b += ec->rad_subtree.b * (float)0.25 ;
-            e->join_counter-- ;
-            join_flag = (e->join_counter == 0) ;
-            {pthread_mutex_unlock(&(e->elem_lock->lock));};
+            { union instance220 instance220 = {
+                {
+                    ec,
+                    e,
+                },
+            };
+            
+            join_flag =(long)(uintptr_t)(liblock_execute_operation(&(e->elem_lock->lock), (void *)(uintptr_t)(&instance220),
+                                      &function221));
+            }
 
             if( join_flag == 0 )
                 /* Other children are not finished. Return. */
-                return ;
+                {
+                    return;
+                }
 
             /* This is the continuation called by the last (4th) subprocess.
                Perform JOIN at this level */
@@ -1972,12 +2173,10 @@ static void elem_join_operation(Element 
         }
 
     /* Process RAY root level finished. Update energy variable */
-    {pthread_mutex_lock(&(global->avg_radiosity_lock));};
-    global->total_energy.r += ec->rad.r * ec->area ;
-    global->total_energy.g += ec->rad.g * ec->area ;
-    global->total_energy.b += ec->rad.b * ec->area ;
-    global->total_patch_area += ec->area ;
-    {pthread_mutex_unlock(&(global->avg_radiosity_lock));};
+    {
+    
+    liblock_execute_operation(&(global->avg_radiosity_lock), (void *)(uintptr_t)(ec),
+                              &function228); }
 
 #if PATCH_ASSIGNMENT == PATCH_ASSIGNMENT_COSTBASED
     /* Then update the cost variable of the patch */
@@ -1989,10 +2188,10 @@ static void elem_join_operation(Element 
     pc->cost_estimate   = PATCH_COST_ESTIMATE( pc ) ;
 
     /* Also, update the global cost variable */
-    {pthread_mutex_lock(&(global->cost_sum_lock));};
-    global->cost_sum          += pc->cost_history[0] ;
-    global->cost_estimate_sum += pc->cost_estimate ;
-    {pthread_mutex_unlock(&(global->cost_sum_lock));};
+    {
+    
+    liblock_execute_operation(&(global->cost_sum_lock), (void *)(uintptr_t)(pc),
+                              &function235); }
 #endif
 
 }
@@ -2019,7 +2218,7 @@ static void gather_rays(Element *elem, l
             elem->rad_subtree.r = 0.0 ;
             elem->rad_subtree.g = 0.0 ;
             elem->rad_subtree.b = 0.0 ;
-            return ;
+            return;
         }
 
 
@@ -2075,18 +2274,49 @@ long element_completely_invisible(Elemen
                             &e2->ev1->p, &e2->ev2->p, &e2->ev3->p, process_id ) ;
     if( NEGATIVE_SIDE(cc) )
         /* If negative or on the plane, then do nothing */
-        return( 1 ) ;
+        {
+            return(( 1 )) ;
+        }
 
     cc = patch_intersection( &e2->patch->plane_equ,
                             &e1->ev1->p, &e1->ev2->p, &e1->ev3->p, process_id ) ;
     if( NEGATIVE_SIDE(cc) )
         /* If negative or on the plane, then do nothing */
-        return( 1 ) ;
+        {
+            return(( 1 )) ;
+        }
 
-    return( 0 ) ;
+    return(( 0 )) ;
 }
 
 
+union instance241 {struct output238{Element *p;} output238;};
+void * function242(void *ctx240);
+void *function242(void *ctx240) {
+    {
+        struct output238 *outcontext236=&(((union instance241 *)ctx240)->output238);
+        Element *p;
+        int ret169;
+        {
+            ret169 = 0;
+            if (global->free_element == 0) {
+                printf("Fatal: Ran out of element buffer\n");
+                ret169 = 165 + 1;
+                goto done170;
+            }
+            p = global->free_element;
+            global->free_element = p->center;
+            global->n_free_elements--;
+            done170:
+            {
+                
+            }
+        }
+        outcontext236->p = p;
+        return (void *)(uintptr_t)ret169;
+    }
+}
+
 /***************************************************************************
  *
  *    get_element()
@@ -2097,26 +2327,23 @@ long element_completely_invisible(Elemen
 
 Element *get_element(long process_id)
 {
+    int ret169;
     Element *p ;
 
     /* Lock the free list */
-    {pthread_mutex_lock(&(global->free_element_lock));};
-
-    /* Test pointer */
-    if( global->free_element == 0 )
-        {
-            printf( "Fatal: Ran out of element buffer\n" ) ;
-            {pthread_mutex_unlock(&(global->free_element_lock));};
-            exit( 1 ) ;
-        }
-
-    /* Get an element data structure */
-    p = global->free_element ;
-    global->free_element = p->center ;
-    global->n_free_elements-- ;
-
-    /* Unlock the list */
-    {pthread_mutex_unlock(&(global->free_element_lock));};
+    { union instance241 instance241;
+    
+    ret169 =(int)(uintptr_t)(liblock_execute_operation(&(global->free_element_lock), (void *)(uintptr_t)(&instance241),
+                              &function242));
+    p = instance241.output238.p;
+    }
+    if (ret169) {
+        if (ret169 == 165 + 1)
+            {
+                exit(1);
+            }
+        
+    }
 
     /* Clear pointers just in case.. */
     p->parent             = 0 ;
@@ -2129,11 +2356,23 @@ Element *get_element(long process_id)
     p->vis_undef_inter    = 0 ;
     p->n_vis_undef_inter  = 0 ;
 
-    return( p ) ;
+    return(( p )) ;
 }
 
 
 
+void * function249(void *ctx247);
+void *function249(void *ctx247) {
+    {
+        long leaf;
+        Element *elem=(Element *)(uintptr_t)ctx247;
+        {
+            leaf = _LEAF_ELEMENT(elem);
+        }
+        return (void *)(uintptr_t)leaf;
+    }
+}
+
 /***************************************************************************
  *
  *    leaf_element()
@@ -2150,11 +2389,13 @@ long leaf_element(Element *elem, long pr
 {
     long leaf ;
 
-    {pthread_mutex_lock(&(elem->elem_lock->lock));};
-    leaf  = _LEAF_ELEMENT(elem) ;
-    {pthread_mutex_unlock(&(elem->elem_lock->lock));};
+    {
+    
+    leaf =(long)(uintptr_t)(liblock_execute_operation(&(elem->elem_lock->lock), (void *)(uintptr_t)(elem),
+                              &function249));
+    }
 
-    return( leaf ) ;
+    return(( leaf )) ;
 }
 
 
@@ -2184,7 +2425,8 @@ void init_elemlist(long process_id)
 
     global->free_element = global->element_buf ;
     global->n_free_elements = MAX_ELEMENTS ;
-    pthread_mutex_init(&(global->free_element_lock), NULL);;
+    liblock_lock_init(TYPE_NOINFO, ARG_NOINFO,
+                      &(global->free_element_lock), NULL);;
 }
 
 /***************************************************************************
@@ -2232,8 +2474,10 @@ void foreach_interaction_in_element(Elem
 {
     Interaction *inter ;
 
-    if( elem == 0 )
-        return ;
+    if( elem == 0 ) {
+        
+            return;
+        }
 
     for( inter = elem->interactions ; inter ; inter = inter->next )
         func( elem, inter, arg1, process_id ) ;
@@ -2342,7 +2586,7 @@ static float _diff_disc_formfactor(Verte
     angle_factor = cos_s * cos_d ;
 
     /* Return the form factor */
-    return( fnorm * angle_factor ) ;
+    return(( fnorm * angle_factor )) ;
 }
 
 
@@ -2371,7 +2615,7 @@ static float compute_diff_disc_formfacto
     if( ff_c2 < 0 ) ff_c2 = 0 ;
     if( ff_c3 < 0 ) ff_c3 = 0 ;
 
-    return( ff_c + ff_c1 + ff_c2 + ff_c3 ) ;
+    return(( ff_c + ff_c1 + ff_c2 + ff_c3 )) ;
 }
 
 
@@ -2390,6 +2634,22 @@ void compute_interaction(Element *e_src,
 
 
 
+union instance255 {struct input253{Interaction *inter;Element *elem;} input253;};
+void * function256(void *ctx254);
+void *function256(void *ctx254) {
+    {
+        struct input253 *incontext251=&(((union instance255 *)ctx254)->input253);
+        Interaction *inter=incontext251->inter;
+        Element *elem=incontext251->elem;
+        {
+            inter->next = elem->interactions;
+            elem->interactions = inter;
+            elem->n_interactions++;
+        }
+        return NULL;
+    }
+}
+
 /***************************************************************************
  *
  *    insert_interaction()
@@ -2405,25 +2665,50 @@ void compute_interaction(Element *e_src,
 void insert_interaction(Element *elem, Interaction *inter, long process_id)
 {
     /* Link from patch 1 to patch 2 */
-    {pthread_mutex_lock(&(elem->elem_lock->lock));};
-    inter->next = elem->interactions ;
-    elem->interactions = inter ;
-    elem->n_interactions++ ;
-    {pthread_mutex_unlock(&(elem->elem_lock->lock));};
+    { union instance255 instance255 = {
+        {
+            inter,
+            elem,
+        },
+    };
+    
+    liblock_execute_operation(&(elem->elem_lock->lock), (void *)(uintptr_t)(&instance255),
+                              &function256); }
 }
 
 
 
+union instance262 {struct input260{Interaction *inter;Interaction *prev;Element *elem;} input260;};
+void * function263(void *ctx261);
+void *function263(void *ctx261) {
+    {
+        struct input260 *incontext258=&(((union instance262 *)ctx261)->input260);
+        Interaction *inter=incontext258->inter;
+        Interaction *prev=incontext258->prev;
+        Element *elem=incontext258->elem;
+        {
+            if (prev == 0)
+                elem->interactions = inter->next;else
+                prev->next = inter->next;
+            elem->n_interactions--;
+        }
+        return NULL;
+    }
+}
+
 void delete_interaction(Element *elem, Interaction *prev, Interaction *inter, long process_id)
 {
     /* Remove from the list */
-    {pthread_mutex_lock(&(elem->elem_lock->lock));};
-    if( prev == 0 )
-        elem->interactions = inter->next ;
-    else
-        prev->next = inter->next ;
-    elem->n_interactions-- ;
-    {pthread_mutex_unlock(&(elem->elem_lock->lock));};
+    { union instance262 instance262 = {
+        {
+            inter,
+            prev,
+            elem,
+        },
+    };
+    
+    liblock_execute_operation(&(elem->elem_lock->lock), (void *)(uintptr_t)(&instance262),
+                              &function263); }
 
     /* Return to the free list */
     free_interaction( inter, process_id ) ;
@@ -2431,29 +2716,97 @@ void delete_interaction(Element *elem, I
 
 
 
+union instance269 {struct input267{Interaction *inter;Element *elem;} input267;};
+void * function270(void *ctx268);
+void *function270(void *ctx268) {
+    {
+        struct input267 *incontext265=&(((union instance269 *)ctx268)->input267);
+        Interaction *inter=incontext265->inter;
+        Element *elem=incontext265->elem;
+        {
+            inter->next = elem->vis_undef_inter;
+            elem->vis_undef_inter = inter;
+            elem->n_vis_undef_inter++;
+        }
+        return NULL;
+    }
+}
+
 void insert_vis_undef_interaction(Element *elem, Interaction *inter, long process_id)
 {
     /* Link from patch 1 to patch 2 */
-    {pthread_mutex_lock(&(elem->elem_lock->lock));};
-    inter->next = elem->vis_undef_inter ;
-    elem->vis_undef_inter = inter ;
-    elem->n_vis_undef_inter++ ;
-    {pthread_mutex_unlock(&(elem->elem_lock->lock));};
+    { union instance269 instance269 = {
+        {
+            inter,
+            elem,
+        },
+    };
+    
+    liblock_execute_operation(&(elem->elem_lock->lock), (void *)(uintptr_t)(&instance269),
+                              &function270); }
+}
+
+union instance276 {struct input274{Interaction *inter;Interaction *prev;Element *elem;} input274;};
+void * function277(void *ctx275);
+void *function277(void *ctx275) {
+    {
+        struct input274 *incontext272=&(((union instance276 *)ctx275)->input274);
+        Interaction *inter=incontext272->inter;
+        Interaction *prev=incontext272->prev;
+        Element *elem=incontext272->elem;
+        {
+            if (prev == 0)
+                elem->vis_undef_inter = inter->next;else
+                prev->next = inter->next;
+            elem->n_vis_undef_inter--;
+        }
+        return NULL;
+    }
 }
 
 void delete_vis_undef_interaction(Element *elem, Interaction *prev, Interaction *inter, long process_id)
 {
     /* Remove from the list */
-    {pthread_mutex_lock(&(elem->elem_lock->lock));};
-    if( prev == 0 )
-        elem->vis_undef_inter = inter->next ;
-    else
-        prev->next = inter->next ;
-    elem->n_vis_undef_inter-- ;
-    {pthread_mutex_unlock(&(elem->elem_lock->lock));};
+    { union instance276 instance276 = {
+        {
+            inter,
+            prev,
+            elem,
+        },
+    };
+    
+    liblock_execute_operation(&(elem->elem_lock->lock), (void *)(uintptr_t)(&instance276),
+                              &function277); }
 }
 
 
+union instance283 {struct output280{Interaction *p;} output280;};
+void * function284(void *ctx282);
+void *function284(void *ctx282) {
+    {
+        struct output280 *outcontext278=&(((union instance283 *)ctx282)->output280);
+        Interaction *p;
+        int ret171;
+        {
+            ret171 = 0;
+            if (global->free_interaction == 0) {
+                printf("Fatal: Ran out of interaction buffer\n");
+                ret171 = 166 + 1;
+                goto done172;
+            }
+            p = global->free_interaction;
+            global->free_interaction = p->next;
+            global->n_free_interactions--;
+            done172:
+            {
+                
+            }
+        }
+        outcontext278->p = p;
+        return (void *)(uintptr_t)ret171;
+    }
+}
+
 /***************************************************************************
  *
  *    get_interaction()
@@ -2465,49 +2818,54 @@ void delete_vis_undef_interaction(Elemen
 
 Interaction *get_interaction(long process_id)
 {
+    int ret171;
     Interaction *p ;
 
     /* Lock the free list */
-    {pthread_mutex_lock(&(global->free_interaction_lock));};
-
-    /* Test pointer */
-    if( global->free_interaction == 0 )
-        {
-            printf( "Fatal: Ran out of interaction buffer\n" ) ;
-            {pthread_mutex_unlock(&(global->free_interaction_lock));};
-            exit( 1 ) ;
-        }
-
-    /* Get an element data structure */
-    p = global->free_interaction ;
-    global->free_interaction = p->next ;
-    global->n_free_interactions-- ;
-
-    /* Unlock the list */
-    {pthread_mutex_unlock(&(global->free_interaction_lock));};
+    { union instance283 instance283;
+    
+    ret171 =(int)(uintptr_t)(liblock_execute_operation(&(global->free_interaction_lock), (void *)(uintptr_t)(&instance283),
+                              &function284));
+    p = instance283.output280.p;
+    }
+    if (ret171) {
+        if (ret171 == 166 + 1)
+            {
+                exit(1);
+            }
+        
+    }
 
     /* Clear pointers just in case.. */
     p->next   = 0 ;
     p->destination = 0 ;
 
 
-    return( p ) ;
+    return(( p )) ;
 }
 
 
 
+void * function291(void *ctx289);
+void *function291(void *ctx289) {
+    {
+        Interaction *interaction=(Interaction *)(uintptr_t)ctx289;
+        {
+            interaction->next = global->free_interaction;
+            global->free_interaction = interaction;
+            global->n_free_interactions++;
+        }
+        return NULL;
+    }
+}
+
 void free_interaction(Interaction *interaction, long process_id)
 {
     /* Lock the free list */
-    {pthread_mutex_lock(&(global->free_interaction_lock));};
-
-    /* Get a task data structure */
-    interaction->next = global->free_interaction ;
-    global->free_interaction = interaction ;
-    global->n_free_interactions++ ;
-
-    /* Unlock the list */
-    {pthread_mutex_unlock(&(global->free_interaction_lock));};
+    {
+    
+    liblock_execute_operation(&(global->free_interaction_lock), (void *)(uintptr_t)(interaction),
+                              &function291); }
 }
 
 
@@ -2529,7 +2887,8 @@ void init_interactionlist(long process_i
     global->interaction_buf[ MAX_INTERACTIONS-1 ].next = 0 ;
     global->free_interaction = global->interaction_buf ;
     global->n_free_interactions = MAX_INTERACTIONS ;
-    pthread_mutex_init(&(global->free_interaction_lock), NULL);;
+    liblock_lock_init(TYPE_RADIOSITY_1, ARG_RADIOSITY_1,
+                      &(global->free_interaction_lock), NULL);;
 }
 
 
diff -u -p a/codes/apps/raytrace/rt.h b/codes/apps/raytrace/rt.h
--- a/codes/apps/raytrace/rt.h
+++ b/codes/apps/raytrace/rt.h
@@ -37,9 +37,17 @@
 #ifdef	MAIN
 
 #include <pthread.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <sys/time.h>
 #include <unistd.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <malloc.h>
 /** +EDIT */
 //#define MAX_THREADS 32
@@ -50,9 +58,17 @@ pthread_t PThreadTable[MAX_THREADS];
 #else
 
 #include <pthread.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <sys/time.h>
 #include <unistd.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <malloc.h>
 extern pthread_t PThreadTable[];
 
@@ -674,10 +690,10 @@ typedef struct	gmem
 	
 pthread_barrier_t	(start);
 			/* Barrier for startup sync.	     */
-	pthread_mutex_t pidlock;		/* Lock to increment pid.	     */
-	pthread_mutex_t ridlock;		/* Lock to increment rid.	     */
-	pthread_mutex_t memlock;		/* Lock for memory manager.	     */
-	pthread_mutex_t wplock[MAX_PROCS];	/* Locks for shared work pools.      */
+	liblock_lock_t pidlock;		/* Lock to increment pid.	     */
+	liblock_lock_t ridlock;		/* Lock to increment rid.	     */
+	liblock_lock_t memlock;		/* Lock for memory manager.	     */
+	liblock_lock_t wplock[MAX_PROCS];	/* Locks for shared work pools.      */
     UINT par_start_time;
     UINT partime[MAX_PROCS];
 	}
diff -u -p a/codes/apps/raytrace/shade.c b/codes/apps/raytrace/shade.c
--- a/codes/apps/raytrace/shade.c
+++ b/codes/apps/raytrace/shade.c
@@ -117,12 +117,47 @@ BOOL	TransmissionDirection(POINT T, POIN
 		VecNorm(T);
 		}
 	else
-		return (FALSE);
+		{
+			return( (FALSE));
+		}
+
+	return( (TRUE));
+	}
+
 
-	return (TRUE);
+
+void * function20(void *ctx18);
+void *function20(void *ctx18) {
+	{
+		RAY *secondary_ray=(RAY *)(uintptr_t)ctx18;
+		{
+			(*secondary_ray).id = gm->rid++;
+		}
+		return NULL;
 	}
+}
 
+void * function13(void *ctx11);
+void *function13(void *ctx11) {
+	{
+		RAY *secondary_ray=(RAY *)(uintptr_t)ctx11;
+		{
+			(*secondary_ray).id = gm->rid++;
+		}
+		return NULL;
+	}
+}
 
+void * function6(void *ctx4);
+void *function6(void *ctx4) {
+	{
+		RAY *shad_ray=(RAY *)(uintptr_t)ctx4;
+		{
+			(*shad_ray).id = gm->rid++;
+		}
+		return NULL;
+	}
+}
 
 /*
  * NAME
@@ -187,9 +222,10 @@ VOID	Shade(VEC3 iP, VEC3 N, RAY *ray, IR
 		VecNorm(Lvec);
 		VecCopy(shad_ray.D, Lvec);
 
-		{pthread_mutex_lock(&(gm->ridlock));};
-		shad_ray.id = gm->rid++;
-		{pthread_mutex_unlock(&(gm->ridlock));};
+		{
+		
+		liblock_execute_operation(&(gm->ridlock), (void *)(uintptr_t)(&shad_ray),
+					  &function6); }
 
 		NdotL = VecDot(N, Lvec);
 
@@ -266,9 +302,10 @@ VOID	Shade(VEC3 iP, VEC3 N, RAY *ray, IR
 			SpecularDirection(secondary_ray.D, N, ray->D);
 			secondary_ray.level = ray->level + 1;
 
-			{pthread_mutex_lock(&(gm->ridlock));};
-			secondary_ray.id = gm->rid++;
-			{pthread_mutex_unlock(&(gm->ridlock));};
+			{
+			
+			liblock_execute_operation(&(gm->ridlock),
+						  (void *)(uintptr_t)(&secondary_ray), &function13); }
 
 			secondary_ray.x = ray->x;
 			secondary_ray.y = ray->y;
@@ -286,9 +323,11 @@ VOID	Shade(VEC3 iP, VEC3 N, RAY *ray, IR
 				{
 				secondary_ray.level = ray->level + 1;
 
-				{pthread_mutex_lock(&(gm->ridlock));};
-				secondary_ray.id = gm->rid++;
-				{pthread_mutex_unlock(&(gm->ridlock));};
+				{
+				
+				liblock_execute_operation(&(gm->ridlock),
+							  (void *)(uintptr_t)(&secondary_ray),
+							  &function20); }
 
 				secondary_ray.x = ray->x;
 				secondary_ray.y = ray->y;
diff -u -p a/codes/apps/raytrace/memory.c b/codes/apps/raytrace/memory.c
--- a/codes/apps/raytrace/memory.c
+++ b/codes/apps/raytrace/memory.c
@@ -112,7 +112,7 @@ VOID	*LocalMalloc(UINT n, CHAR *msg)
 		exit(-1);
 		}
 
-	return (p);
+	return( (p));
 	}
 
 
@@ -143,6 +143,28 @@ VOID	LocalFree(VOID *p)
 
 
 
+void * function31(void *ctx29);
+void *function31(void *ctx29) {
+	{
+		NODE huge *curr;
+		{
+			curr = begmem;
+			printf("freelist ->\t0x%08lX\n\n", (U32)gm->freelist);
+			printf("node addr \tnode->next\tnode->size\tnode->free\tnode->cksm\n");
+			printf("==========\t==========\t==========\t==========\t==========\n");
+			while (curr < endmem) {
+				printf("0x%08lX\t0x%08lX\t%10ld\t%s\t\t0x%08lX\n", (U32)curr, (U32)curr->next, curr->size, (curr->free ? "FREE" : "    "), curr->cksm);
+				if (curr->cksm != CKSM) {
+					fprintf(stderr, "GlobalHeapWalk: Invalid checksum in node.\n");
+					exit(1);
+				}
+				curr = NODE_ADD(curr, curr->size + nodesize);
+			}
+		}
+		return NULL;
+	}
+}
+
 /*
  * NAME
  *	GlobalHeapWalk - walk the global heap and print info
@@ -161,30 +183,9 @@ VOID	GlobalHeapWalk()
 	{
 	NODE	huge	*curr;
 
-	{pthread_mutex_lock(&(gm->memlock));}
-	curr = begmem;
-
-	printf("freelist ->\t0x%08lX\n\n", (U32)gm->freelist);
-
-	printf("node addr \tnode->next\tnode->size\tnode->free\tnode->cksm\n");
-	printf("==========\t==========\t==========\t==========\t==========\n");
-
-	while (curr < endmem)
-		{
-		printf("0x%08lX\t0x%08lX\t%10ld\t%s\t\t0x%08lX\n",
-			(U32)curr, (U32)curr->next, curr->size,
-			(curr->free ? "FREE" : "    "), curr->cksm);
-
-		if (curr->cksm != CKSM)
-			{
-			fprintf(stderr, "GlobalHeapWalk: Invalid checksum in node.\n");
-			exit(1);
-			}
-
-		curr = NODE_ADD(curr, curr->size + nodesize);
-		}
-
-	{pthread_mutex_unlock(&(gm->memlock));}
+	{
+	
+	liblock_execute_operation(&(gm->memlock), (void *)(uintptr_t)(NULL), &function31); }
 	}
 
 
@@ -218,8 +219,10 @@ BOOL	GlobalHeapInit(UINT size)
 	size	     = ROUND_UP(size);
 	gm->freelist = (NODE huge *)valloc(size);;
 
-	if (!gm->freelist)
-		return (FALSE);
+	if (!gm->freelist) {
+		
+			return( (FALSE));
+		}
 
 	nodesize = sizeof(NODE);
 	begmem	 = gm->freelist;
@@ -233,11 +236,58 @@ BOOL	GlobalHeapInit(UINT size)
 /* NOTE TO USERS: Here's where one can allocate the memory segment from
 	begmem to endmem round-robin among memories or however one desires */
 
-	return (TRUE);
+	return( (TRUE));
 	}
 
 
 
+union instance37 {struct input35{UINT size;CHAR *msg;} input35;};
+void * function38(void *ctx36);
+void *function38(void *ctx36) {
+	{
+		struct input35 *incontext33=&(((union instance37 *)ctx36)->input35);
+		NODE huge *next;
+		NODE huge *curr;
+		NODE huge *prev;
+		UINT size=incontext33->size;
+		CHAR *msg=incontext33->msg;
+		{
+			prev = NULL;
+			curr = gm->freelist;
+			size = ROUND_UP(size);
+			while (curr && curr->size < size) {
+				if (curr->cksm != CKSM) {
+					fprintf(stderr, "GlobalMalloc: Invalid checksum in node.\n");
+					exit(1);
+				}
+				if (curr->free != TRUE) {
+					fprintf(stderr, "GlobalMalloc: Node in free list not marked as free.\n");
+					exit(1);
+				}
+				prev = curr;
+				curr = curr->next;
+			}
+			if (!curr) {
+				fprintf(stderr, "%s: %s cannot allocate global memory.\n", ProgName, msg);
+				exit(-1);
+			}
+			if (curr->size - size > THRESHOLD) {
+				next = NODE_ADD(curr, nodesize + size);
+				next->size = curr->size - nodesize - size;
+				next->next = curr->next;
+				next->free = TRUE;
+				next->cksm = CKSM;
+				curr->size = size;
+			}else
+				next = curr->next;
+			if (!prev)
+				gm->freelist = next;else
+				prev->next = next;
+		}
+		return (void *)(uintptr_t)curr;
+	}
+}
+
 /*
  * NAME
  *	GlobalMalloc - allocate a node of given size from global memory
@@ -272,75 +322,25 @@ VOID	*GlobalMalloc(UINT size, CHAR *msg)
 	NODE	huge   *curr;
 	NODE	huge   *next;
 
-	if (!size)
-		return (NULL);
-
-	{pthread_mutex_lock(&(gm->memlock));}
-
-	prev = NULL;
-	curr = gm->freelist;
-	size = ROUND_UP(size);
-
-	/*
-	 *	Scan through list for large enough node (first fit).
-	 */
-
-	while (curr && curr->size < size)
-		{
-		if (curr->cksm != CKSM)
-			{
-			fprintf(stderr, "GlobalMalloc: Invalid checksum in node.\n");
-			exit(1);
-			}
-
-		if (curr->free != TRUE)
-			{
-			fprintf(stderr, "GlobalMalloc: Node in free list not marked as free.\n");
-			exit(1);
-			}
-
-		prev = curr;
-		curr = curr->next;
+	if (!size) {
+		
+			return( (NULL));
 		}
 
-
-	if (!curr)
-		{
-		fprintf(stderr, "%s: %s cannot allocate global memory.\n", ProgName, msg);
-		exit(-1);
-		}
-
-
-	/*
-	 *	If node is larger than needed, free extra space at end
-	 *	by inserting remaining space into free list.
-	 */
-
-	if (curr->size - size > THRESHOLD)
-		{
-		next	    = NODE_ADD(curr, nodesize + size);
-		next->size  = curr->size - nodesize - size;
-		next->next  = curr->next;
-		next->free  = TRUE;
-		next->cksm  = CKSM;
-		curr->size  = size;
-		}
-	else
-		next = curr->next;
-
-
-	if (!prev)
-		gm->freelist = next;
-	else
-		prev->next   = next;
-
-
-	{pthread_mutex_unlock(&(gm->memlock));}
+	{ union instance37 instance37 = {
+		{
+			size,
+			msg,
+		},
+	};
+	
+	curr =(NODE huge *)(uintptr_t)(liblock_execute_operation(&(gm->memlock), (void *)(uintptr_t)(&instance37), &function38));
+	}
 	curr->next = NULL;
 	curr->free = FALSE;
 	curr	   = NODE_ADD(curr, nodesize);
 
-	return ((VOID *)curr);
+	return( ((VOID *)curr));
 	}
 
 
@@ -381,11 +381,72 @@ VOID	*GlobalCalloc(UINT n, UINT size)
 	while (nbytes--)
 		*p++ = 0;
 
-	return (q);
+	return( (q));
 	}
 
 
 
+union instance44 {struct input42{UINT newsize;UINT totsize;VOID *p;NODE huge *pn;NODE huge *next;} input42;};
+void * function45(void *ctx43);
+void *function45(void *ctx43) {
+		{
+				struct input42 *incontext40=&(((union instance44 *)ctx43)->input42);
+				NODE huge *node;
+				NODE huge *curr;
+				NODE huge *prev;
+				int ret23;
+				UINT newsize=incontext40->newsize;
+				UINT totsize=incontext40->totsize;
+				VOID *p=incontext40->p;
+				NODE huge *pn=incontext40->pn;
+				NODE huge *next=incontext40->next;
+				{
+						ret23 = 0;
+						if (next < endmem && next->free && totsize >= newsize) {
+								prev = NULL;
+								curr = gm->freelist;
+								while (curr && curr < next && curr < endmem) {
+										prev = curr;
+										curr = curr->next;
+								}
+								if (curr != next) {
+										fprintf(stderr, "GlobalRealloc: Could not find next node in free list.\n");
+										exit(1);
+								}
+								if (totsize - newsize < THRESHOLD) {
+										if (!prev)
+												gm->freelist = next->next;else
+												prev->next = next->next;
+										next->next = NULL;
+										next->free = FALSE;
+										pn->size = totsize;
+										ret23 = 21 + 1;
+										goto done24;
+								}else {
+										node = NODE_ADD(p, newsize);
+										node->next = next->next;
+										node->size = totsize - nodesize - newsize;
+										node->free = TRUE;
+										node->cksm = CKSM;
+										if (!prev)
+												gm->freelist = node;else
+												prev->next = node;
+										next->next = NULL;
+										next->free = FALSE;
+										pn->size = newsize;
+										ret23 = 22 + 1;
+										goto done24;
+								}
+						}
+						done24:
+						{
+								
+						}
+				}
+				return (void *)(uintptr_t)ret23;
+		}
+}
+
 /*
  * NAME
  *	GlobalRealloc - reallocate a node to a new size
@@ -444,6 +505,7 @@ VOID	*GlobalCalloc(UINT n, UINT size)
 
 VOID	*GlobalRealloc(VOID *p, UINT size)
 	{
+		int ret23;
 	UINT		oldsize;
 	UINT		newsize;
 	UINT		totsize;
@@ -459,11 +521,13 @@ VOID	*GlobalRealloc(VOID *p, UINT size)
 	if (!size)
 		{
 		GlobalFree(p);
-		return (NULL);
+		return( (NULL));
 		}
 
-	if (!p)
-		return (GlobalMalloc(size, "GlobalRealloc"));
+	if (!p) {
+		
+			return( (GlobalMalloc(size, "GlobalRealloc")));
+		}
 
 
 	pn = NODE_ADD(p, -nodesize);		/* Adjust ptr back to arena. */
@@ -492,8 +556,10 @@ VOID	*GlobalRealloc(VOID *p, UINT size)
 
 	if (newsize <= oldsize)
 		{
-		if (oldsize - newsize < THRESHOLD)
-			return (p);
+		if (oldsize - newsize < THRESHOLD) {
+			
+				return( (p));
+			}
 
 		pn->size    = newsize;
 
@@ -505,7 +571,7 @@ VOID	*GlobalRealloc(VOID *p, UINT size)
 		next	    = NODE_ADD(next, nodesize);
 
 		GlobalFree(next);
-		return (p);
+		return( (p));
 		}
 
 
@@ -517,78 +583,35 @@ VOID	*GlobalRealloc(VOID *p, UINT size)
 	next	= NODE_ADD(p, oldsize);
 	totsize = oldsize + nodesize + next->size;
 
-	{pthread_mutex_lock(&(gm->memlock));}
-	if (next < endmem && next->free && totsize >= newsize)
-		{
-		/* Find next in free list. */
-
-		prev = NULL;
-		curr = gm->freelist;
-
-		while (curr && curr < next && curr < endmem)
-			{
-			prev = curr;
-			curr = curr->next;
-			}
-
-		if (curr != next)
-			{
-			fprintf(stderr, "GlobalRealloc: Could not find next node in free list.\n");
-			exit(1);
-			}
-
-		if (totsize - newsize < THRESHOLD)
-			{
-			/* Just remove next from free list. */
-
-			if (!prev)
-				gm->freelist = next->next;
-			else
-				prev->next   = next->next;
-
-			next->next = NULL;
-			next->free = FALSE;
-			pn->size   = totsize;
-
-			{pthread_mutex_unlock(&(gm->memlock));}
-			return (p);
-			}
-		else
+	{ union instance44 instance44 = {
 			{
-			/* Remove next from free list while adding node. */
-
-			node	   = NODE_ADD(p, newsize);
-			node->next = next->next;
-			node->size = totsize - nodesize - newsize;
-			node->free = TRUE;
-			node->cksm = CKSM;
-
-			if (!prev)
-				gm->freelist = node;
-			else
-				prev->next   = node;
-
-			next->next = NULL;
-			next->free = FALSE;
-			pn->size   = newsize;
-
-			{pthread_mutex_unlock(&(gm->memlock));}
-			return (p);
-			}
-		}
-
-
-	/*
-	 *	New size is bigger than current node, but next node in list
-	 *	could not be expanded.	Try to allocate new node and move data
-	 *	to new location.
-	 */
-
-	{pthread_mutex_unlock(&(gm->memlock));}
+					newsize,
+					totsize,
+					p,
+					pn,
+					next,
+			},
+	};
+	
+	ret23 =(int)(uintptr_t)(liblock_execute_operation(&(gm->memlock), (void *)(uintptr_t)(&instance44), &function45));
+	}
+	if (ret23) {
+			if (ret23 == 21 + 1)
+					{
+							return((p));
+					}
+			if (ret23 == 22 + 1)
+					{
+							return((p));
+					}
+		
+	}
 
 	s = q = GlobalMalloc(newsize, "GlobalRealloc");
-	if (!q)
-		return (NULL);
+	if (!q) {
+		
+			return( (NULL));
+		}
 
 	r = (UINT huge *)p;
 	oldsize >>= 2;
@@ -597,11 +620,103 @@ VOID	*GlobalRealloc(VOID *p, UINT size)
 		*s++ = *r++;
 
 	GlobalFree(p);
-	return (q);
+	return( (q));
 	}
 
 
 
+union instance51 {struct input49{BOOL pcom;NODE huge *prev;NODE huge *pn;} input49;};
+void * function52(void *ctx50);
+void *function52(void *ctx50) {
+	{
+		struct input49 *incontext47=&(((union instance51 *)ctx50)->input49);
+		BOOL ncom;
+		NODE huge *next;
+		NODE huge *curr;
+		BOOL pcom=incontext47->pcom;
+		NODE huge *prev=incontext47->prev;
+		NODE huge *pn=incontext47->pn;
+		{
+			if (gm->freelist) {
+				curr = gm->freelist;
+				while (curr < pn && curr < endmem) {
+					if (curr->cksm != CKSM) {
+						fprintf(stderr, "GlobalFree: Invalid checksum in previous node.\n");
+						exit(1);
+					}
+					if (curr->free) {
+						prev = curr;
+						pcom = TRUE;
+					}else
+						pcom = FALSE;
+					curr = NODE_ADD(curr, curr->size + nodesize);
+				}
+				if (curr >= endmem) {
+					fprintf(stdout, "freelist=0x%p, curr=0x%p, size=0x%lu, pn=0x%p, endmem=0x%p\n", gm->freelist, curr, curr->size, pn, endmem);
+					fprintf(stderr, "GlobalFree: Search for previous block fell off end of memory.\n");
+					exit(1);
+				}
+			}
+			ncom = TRUE;
+			next = NULL;
+			curr = NODE_ADD(pn, pn->size + nodesize);
+			while (!next && curr < endmem) {
+				if (curr->cksm != CKSM) {
+					fprintf(stderr, "GlobalFree: Invalid checksum in next node.\n");
+					exit(1);
+				}
+				if (curr->free)
+					next = curr;else
+					ncom = FALSE;
+				curr = NODE_ADD(curr, curr->size + nodesize);
+			}
+			if (!next)
+				ncom = FALSE;
+			curr = pn;
+			curr->free = TRUE;
+			if (next && !ncom && pcom) {
+				prev->next = next;
+				prev->size += curr->size + nodesize;
+			}else
+				if (next && !ncom && prev && !pcom) {
+					prev->next = curr;
+					curr->next = next;
+				}else
+					if (next && !ncom && !prev) {
+						gm->freelist = curr;
+						curr->next = next;
+					}else
+						if (ncom && pcom) {
+							prev->next = next->next;
+							prev->size += curr->size + next->size + 2 * nodesize;
+						}else
+							if (ncom && prev && !pcom) {
+								prev->next = curr;
+								curr->next = next->next;
+								curr->size += next->size + nodesize;
+							}else
+								if (ncom && !prev) {
+									gm->freelist = curr;
+									curr->next = next->next;
+									curr->size += next->size + nodesize;
+								}else
+									if (!next && pcom) {
+										prev->next = NULL;
+										prev->size += curr->size + nodesize;
+									}else
+										if (!next && prev && !pcom) {
+											prev->next = curr;
+											curr->next = NULL;
+										}else
+											if (!next && !prev) {
+												gm->freelist = curr;
+												curr->next = NULL;
+											}
+		}
+		return NULL;
+	}
+}
+
 /*
  * NAME
  *	GlobalFree - return a node to the free list
@@ -629,8 +744,10 @@ VOID	GlobalFree(VOID *p)
 	NODE	huge	*curr;			/* Pointer to this node.     */
 	NODE	huge	*next;			/* Pointer to next node.     */
 
-	if (!begmem)
-		return;
+	if (!begmem) {
+		
+			return;
+		}
 
 
 	pn = NODE_ADD(p, -nodesize);		/* Adjust ptr back to arena. */
@@ -651,147 +768,37 @@ VOID	GlobalFree(VOID *p)
 	pcom = FALSE;
 	prev = NULL;
 
-	{pthread_mutex_lock(&(gm->memlock));}
-	if (gm->freelist)
+	{ union instance51 instance51 = {
 		{
-		/*
-		 *	Search the memory arena blocks for previous free neighbor.
-		 */
-
-		curr = gm->freelist;
-
-		while (curr < pn && curr < endmem)
-			{
-			if (curr->cksm != CKSM)
-				{
-				fprintf(stderr, "GlobalFree: Invalid checksum in previous node.\n");
-				exit(1);
-				}
-
-			if (curr->free)
-				{
-				prev = curr;
-				pcom = TRUE;
-				}
-			else
-				pcom = FALSE;
-
-			curr = NODE_ADD(curr, curr->size + nodesize);
-			}
-
-
-		/*
-		 *	Make sure we found the original node.
-		 */
-
-		if (curr >= endmem)
-			{
-			fprintf(stdout, "freelist=0x%p, curr=0x%p, size=0x%lu, pn=0x%p, endmem=0x%p\n", gm->freelist, curr, curr->size, pn, endmem);
-			fprintf(stderr, "GlobalFree: Search for previous block fell off end of memory.\n");
-			exit(1);
-			}
-		}
-
+			pcom,
+			prev,
+			pn,
+		},
+	};
+	
+	liblock_execute_operation(&(gm->memlock), (void *)(uintptr_t)(&instance51), &function52); }
+	return;
+	}
 
-	/*
-	 *	Search the memory arena blocks for next free neighbor.
-	 */
 
-	ncom = TRUE;
-	next = NULL;
-	curr = NODE_ADD(pn, pn->size + nodesize);
 
-	while (!next && curr < endmem)
+void * function59(void *ctx57);
+void *function59(void *ctx57) {
+	{
+		UINT total;
+		NODE huge *curr;
 		{
-		if (curr->cksm != CKSM)
-			{
-			fprintf(stderr, "GlobalFree: Invalid checksum in next node.\n");
-			exit(1);
+			total = 0;
+			curr = gm->freelist;
+			while (curr) {
+				total += curr->size;
+				curr = curr->next;
 			}
-
-		if (curr->free)
-			next = curr;
-		else
-			ncom = FALSE;
-
-		curr = NODE_ADD(curr, curr->size + nodesize);
+			total = ROUND_DN(total);
 		}
-
-
-	if (!next)				/* Loop may have fallen thru.*/
-		ncom = FALSE;
-
-	curr = pn;
-	curr->free = TRUE;			/* Mark NODE as free.	     */
-
-
-	/*
-	 *	Attempt to combine the three nodes (prev, current, next).
-	 *	There are 9 cases to consider (16 total, but 7 are degenerate).
-	 */
-
-
-	if (next && !ncom && pcom)
-		{
-		prev->next  = next;
-		prev->size += curr->size + nodesize;
-		}
-	else
-	if (next && !ncom && prev && !pcom)
-		{
-		prev->next  = curr;
-		curr->next  = next;
-		}
-	else
-	if (next && !ncom && !prev)
-		{
-		gm->freelist = curr;
-		curr->next   = next;
-		}
-	else
-	if (ncom && pcom)
-		{
-		prev->next  = next->next;
-		prev->size += curr->size + next->size + 2*nodesize;
-		}
-	else
-	if (ncom && prev && !pcom)
-		{
-		prev->next  = curr;
-		curr->next  = next->next;
-		curr->size += next->size + nodesize;
-		}
-	else
-	if (ncom && !prev)
-		{
-		gm->freelist = curr;
-		curr->next   = next->next;
-		curr->size  += next->size + nodesize;
-		}
-	else
-	if (!next && pcom)
-		{
-		prev->next  = NULL;
-		prev->size += curr->size + nodesize;
-		}
-	else
-	if (!next && prev && !pcom)
-		{
-		prev->next  = curr;
-		curr->next  = NULL;
-		}
-	else
-	if (!next && !prev)
-		{
-		gm->freelist = curr;
-		curr->next   = NULL;
-		}
-
-	{pthread_mutex_unlock(&(gm->memlock));}
-	return;
+		return (void *)(uintptr_t)total;
 	}
-
-
+}
 
 /*
  * NAME
@@ -813,23 +820,32 @@ UINT	GlobalMemAvl()
 	UINT	total;
 	NODE	huge	*curr;
 
-	{pthread_mutex_lock(&(gm->memlock));}
-	total = 0;
-	curr  = gm->freelist;
+	{
+	
+	total =(UINT)(uintptr_t)(liblock_execute_operation(&(gm->memlock), (void *)(uintptr_t)(NULL), &function59));
+	}
+	return( (total));
+	}
 
-	while (curr)
-		{
-		total += curr->size;
-		curr   = curr->next;
-		}
 
-	total = ROUND_DN(total);
 
-	{pthread_mutex_unlock(&(gm->memlock));}
-	return (total);
+void * function66(void *ctx64);
+void *function66(void *ctx64) {
+	{
+		UINT max;
+		NODE huge *curr;
+		{
+			max = 0;
+			curr = gm->freelist;
+			while (curr) {
+				max = (curr->size > max ? curr->size : max);
+				curr = curr->next;
+			}
+			max = ROUND_DN(max);
+		}
+		return (void *)(uintptr_t)max;
 	}
-
-
+}
 
 /*
  * NAME
@@ -852,20 +868,11 @@ UINT	GlobalMemMax()
 	UINT	max;
 	NODE	huge	*curr;
 
-	{pthread_mutex_lock(&(gm->memlock));}
-	max  = 0;
-	curr = gm->freelist;
-
-	while (curr)
-		{
-		max  = (curr->size > max ? curr->size : max);
-		curr =	curr->next;
-		}
-
-	max = ROUND_DN(max);
-
-	{pthread_mutex_unlock(&(gm->memlock));}
-	return (max);
+	{
+	
+	max =(UINT)(uintptr_t)(liblock_execute_operation(&(gm->memlock), (void *)(uintptr_t)(NULL), &function66));
+	}
+	return( (max));
 	}
 
 
@@ -969,7 +976,7 @@ VOID	*ObjectMalloc(INT ObjectType, INT c
 			exit(-1);
 		}
 
-	return (p);
+	return( (p));
 	}
 
 
@@ -1060,7 +1067,7 @@ RAYINFO *ma_rayinfo(RAY *r)
 
 	r->ri_indx += 1;
 
-	return (p);
+	return( (p));
 	}
 
 
diff -u -p a/codes/apps/raytrace/workpool.c b/codes/apps/raytrace/workpool.c
--- a/codes/apps/raytrace/workpool.c
+++ b/codes/apps/raytrace/workpool.c
@@ -130,6 +130,35 @@ VOID	PutJob(INT xs, INT ys, INT xe, INT 
 
 
 
+union instance75 {struct input73{INT pid;} input73;
+struct output72{WPJOB *wpentry;} output72;};
+void * function76(void *ctx74);
+void *function76(void *ctx74) {
+		{
+				struct output72 *outcontext70=&(((union instance75 *)ctx74)->output72);
+				struct input73 *incontext71=&(((union instance75 *)ctx74)->input73);
+				WPJOB *wpentry;
+				int ret68;
+				INT pid=incontext71->pid;
+				{
+						ret68 = 0;
+						wpentry = gm->workpool[pid][0];
+						if (!wpentry) {
+								gm->wpstat[pid][0] = WPS_EMPTY;
+								ret68 = 67 + 1;
+								goto done69;
+						}
+						gm->workpool[pid][0] = wpentry->next;
+						done69:
+						{
+								
+						}
+				}
+				outcontext70->wpentry = wpentry;
+				return (void *)(uintptr_t)ret68;
+		}
+}
+
 /*
  * NAME
  *	GetJob - get next job from pid's work pool
@@ -150,20 +179,25 @@ VOID	PutJob(INT xs, INT ys, INT xe, INT 
 
 INT	GetJob(RAYJOB *job, INT pid)
 	{
+		int ret68;
 	WPJOB	*wpentry;			/* Work pool entry.	     */
 
-	{pthread_mutex_lock(&gm->wplock[pid]);}
-	wpentry = gm->workpool[pid][0];
-
-	if (!wpentry)
-		{
-		gm->wpstat[pid][0] = WPS_EMPTY;
-		{pthread_mutex_unlock(&gm->wplock[pid]);}
-		return (WPS_EMPTY);
-		}
-
-	gm->workpool[pid][0] = wpentry->next;
-	{pthread_mutex_unlock(&gm->wplock[pid]);}
+	{ union instance75 instance75 = {
+			{
+					pid,
+			},
+	};
+	
+	ret68 =(int)(uintptr_t)(liblock_execute_operation(&gm->wplock[pid], (void *)(uintptr_t)(&instance75), &function76));
+	wpentry = instance75.output72.wpentry;
+	}
+	if (ret68) {
+			if (ret68 == 67 + 1)
+					{
+							return((WPS_EMPTY));
+					}
+		
+	}
 
 	/* Set up ray job information. */
 
@@ -175,7 +209,7 @@ INT	GetJob(RAYJOB *job, INT pid)
 	job->ylen  = wpentry->ydim;
 
 	GlobalFree(wpentry);
-	return (WPS_VALID);
+	return( (WPS_VALID));
 	}
 
 
@@ -206,7 +240,7 @@ INT	GetJobs(RAYJOB *job, INT pid)
 	if (gm->wpstat[i][0] == WPS_VALID)
 		 if (GetJob(job, i) == WPS_VALID)
 			{
-			return (WPS_VALID);
+			return( (WPS_VALID));
 			}
 
 
@@ -222,13 +256,13 @@ INT	GetJobs(RAYJOB *job, INT pid)
 			if (gm->wpstat[i][0] == WPS_VALID)
 				if (GetJob(job, i) == WPS_VALID)
 					{
-					return (WPS_VALID);
+					return( (WPS_VALID));
 					}
 
 			i = (i + 1) % gm->nprocs;
 			}
 
-	return (WPS_EMPTY);
+	return( (WPS_EMPTY));
 	}
 
 
diff -u -p a/codes/apps/raytrace/trace.c b/codes/apps/raytrace/trace.c
--- a/codes/apps/raytrace/trace.c
+++ b/codes/apps/raytrace/trace.c
@@ -49,7 +49,7 @@ REAL	frand()
 
 	lLastRand = lLastRand*214013L + 2531011L;
 	r  = (REAL)((lLastRand >> 16) & 0x7FFF)/32768.0;
-	return (r);
+	return( (r));
 	}
 
 
@@ -82,7 +82,9 @@ BOOL	GetRayJobFromBundle(RAYJOB *job, IN
 	*y = job->ycurr;
 
 	if ((job->y + job->ylen) == job->ycurr) /* All done?		     */
-		return (FALSE);
+		{
+			return( (FALSE));
+		}
 
 	job->xcurr++;				/* Update to next pixel.     */
 	if ((job->x +job->xlen) == job->xcurr )
@@ -91,11 +93,22 @@ BOOL	GetRayJobFromBundle(RAYJOB *job, IN
 		job->ycurr++;
 		}
 
-	return (TRUE);
+	return( (TRUE));
 	}
 
 
 
+void * function83(void *ctx81);
+void *function83(void *ctx81) {
+	{
+		RAY *ray=(RAY *)(uintptr_t)ctx81;
+		{
+			ray->id = gm->rid++;
+		}
+		return NULL;
+	}
+}
+
 /*
  * NAME
  *	ConvertPrimRayJobToRayMsg - convert primary ray job to the ray message format
@@ -177,9 +190,9 @@ VOID	ConvertPrimRayJobToRayMsg(RAY *ray,
 	ray->level  = 0;
 	ray->weight = 1.0/(REAL)NumSubRays;
 
-	{pthread_mutex_lock(&(gm->ridlock));};
-	ray->id = gm->rid++;
-	{pthread_mutex_unlock(&(gm->ridlock));};
+	{
+	
+	liblock_execute_operation(&(gm->ridlock), (void *)(uintptr_t)(ray), &function83); }
 
 	ray->x = (INT)x;
 	ray->y = (INT)y;
diff -u -p a/codes/apps/raytrace/rltotiff/rltotiff.c b/codes/apps/raytrace/rltotiff/rltotiff.c
--- a/codes/apps/raytrace/rltotiff/rltotiff.c
+++ b/codes/apps/raytrace/rltotiff/rltotiff.c
@@ -19,6 +19,10 @@
 #include <unistd.h>
 #include <malloc.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 
 typedef short SHORT;
 typedef long LONG;
diff -u -p a/codes/apps/raytrace/rltotiff/tiff_rgba_io.c b/codes/apps/raytrace/rltotiff/tiff_rgba_io.c
--- a/codes/apps/raytrace/rltotiff/tiff_rgba_io.c
+++ b/codes/apps/raytrace/rltotiff/tiff_rgba_io.c
@@ -24,6 +24,10 @@ static char sccsid[] = "@(#)savemap.c	1.
 
 #include <stdio.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <tiffio.h>
 #include "tiff_rgba_io.h"
 
diff -u -p a/codes/apps/raytrace/main.c b/codes/apps/raytrace/main.c
--- a/codes/apps/raytrace/main.c
+++ b/codes/apps/raytrace/main.c
@@ -167,6 +167,17 @@ VOID	PrintStatistics()
 
 
 
+void * function90(void *ctx88);
+void *function90(void *ctx88) {
+	{
+		INT pid;
+		{
+			pid = gm->pid++;
+		}
+		return (void *)(uintptr_t)pid;
+	}
+}
+
 /*
  * NAME
  *	StartRayTrace - starting point for all ray tracing proceses
@@ -184,9 +195,10 @@ VOID	StartRayTrace()
 	UINT	begin;
 	UINT	end;
 
-	{pthread_mutex_lock(&(gm->pidlock));}
-	pid = gm->pid++;
-	{pthread_mutex_unlock(&(gm->pidlock));}
+	{
+	
+	pid =(INT)(uintptr_t)(liblock_execute_operation(&(gm->pidlock), (void *)(uintptr_t)(NULL), &function90));
+	}
 
 	{;};
 
@@ -363,15 +375,16 @@ int	main(int argc, CHAR *argv[])
 	gm->rid    = 1;
 
 	{pthread_barrier_init(&(gm->start), NULL, nprocs);}
-	pthread_mutex_init(&(gm->pidlock), NULL);
-	pthread_mutex_init(&(gm->ridlock), NULL);
-	pthread_mutex_init(&(gm->memlock), NULL);
+	liblock_lock_init(TYPE_NOINFO, ARG_NOINFO, &(gm->pidlock), NULL);
+	liblock_lock_init(TYPE_NOINFO, ARG_NOINFO, &(gm->ridlock), NULL);
+	liblock_lock_init(TYPE_NOINFO, ARG_NOINFO, &(gm->memlock), NULL);
 	
 {
 	unsigned long	i, Error;
 
 	for (i = 0; i < nprocs; i++) {
-		Error = pthread_mutex_init(&gm->wplock[i], NULL);
+		Error = liblock_lock_init(TYPE_NOINFO, ARG_NOINFO,
+					  &gm->wplock[i], NULL);
 		if (Error != 0) {
 			printf("Error while initializing array of locks.\n");
 			exit(-1);
@@ -441,7 +454,7 @@ int	main(int argc, CHAR *argv[])
 	long	i, Error;
 
 	for (i = 0; i < (gm->nprocs) - 1; i++) {
-		Error = pthread_create(&PThreadTable[i], NULL, (void * (*)(void *))(StartRayTrace), NULL);
+		Error = liblock_thread_create(&PThreadTable[i], NULL, (void * (*)(void *))(StartRayTrace), NULL);
 		if (Error != 0) {
 			printf("Error in pthread_create().\n");
 			exit(-1);
diff -u -p a/codes/apps/volrend/anl.h b/codes/apps/volrend/anl.h
--- a/codes/apps/volrend/anl.h
+++ b/codes/apps/volrend/anl.h
@@ -33,9 +33,9 @@ pthread_barrier_t	(SlaveBarrier);
   
 pthread_barrier_t	(TimeBarrier);
 
-  pthread_mutex_t IndexLock;
-  pthread_mutex_t CountLock;
-  pthread_mutex_t QLock[MAX_NUMPROC+1];
+  liblock_lock_t IndexLock;
+  liblock_lock_t CountLock;
+  liblock_lock_t QLock[MAX_NUMPROC+1];
   };
 
 
diff -u -p a/codes/apps/volrend/opacity.c b/codes/apps/volrend/opacity.c
--- a/codes/apps/volrend/opacity.c
+++ b/codes/apps/volrend/opacity.c
@@ -43,9 +43,17 @@ OPACITY *opc_address;	        /* Pointer
 
 
 #include <pthread.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <sys/time.h>
 #include <unistd.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <malloc.h>
 extern pthread_t PThreadTable[];
 
@@ -112,6 +120,17 @@ void Allocate_Opacity(address, length)
 }
 
 
+void * function6(void *ctx4);
+void *function6(void *ctx4) {
+  {
+    long my_node;
+    {
+      my_node = Global->Index++;
+    }
+    return (void *)(uintptr_t)my_node;
+  }
+}
+
 void Opacity_Compute()
 {
   long inx,iny,inz;	        /* Voxel location in object space            */
@@ -124,9 +143,10 @@ void Opacity_Compute()
   long xstart,xstop,ystart,ystop;
   long my_node;
 
-  {pthread_mutex_lock(&(Global->IndexLock));};
-  my_node = Global->Index++;
-  {pthread_mutex_unlock(&(Global->IndexLock));};
+  {
+  
+  my_node =(long)(uintptr_t)(liblock_execute_operation(&(Global->IndexLock), (void *)(uintptr_t)(NULL), &function6));
+  }
   my_node = my_node%num_nodes;
 
 /*  POSSIBLE ENHANCEMENT:  Here's where one might bind the process to a
diff -u -p a/codes/apps/volrend/file.c b/codes/apps/volrend/file.c
--- a/codes/apps/volrend/file.c
+++ b/codes/apps/volrend/file.c
@@ -27,9 +27,17 @@
 
 
 #include <pthread.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <sys/time.h>
 #include <unistd.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <malloc.h>
 extern pthread_t PThreadTable[];
 
diff -u -p a/codes/apps/volrend/octree.c b/codes/apps/volrend/octree.c
--- a/codes/apps/volrend/octree.c
+++ b/codes/apps/volrend/octree.c
@@ -68,9 +68,17 @@ BYTE *pyr_address2;		/* Pointer to byte 
 
 
 #include <pthread.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <sys/time.h>
 #include <unistd.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <malloc.h>
 extern pthread_t PThreadTable[];
 
@@ -174,6 +182,17 @@ on all processors, don't do this create.
 }
 
 
+void * function13(void *ctx11);
+void *function13(void *ctx11) {
+  {
+    long my_node;
+    {
+      my_node = Global->Index++;
+    }
+    return (void *)(uintptr_t)my_node;
+  }
+}
+
 void Compute_Base()
 {
   long outx, outy, outz;
@@ -182,9 +201,10 @@ void Compute_Base()
   long xstart,xstop,ystart,ystop;
   long my_node;
 
-  {pthread_mutex_lock(&(Global->IndexLock));};
-  my_node = Global->Index++;
-  {pthread_mutex_unlock(&(Global->IndexLock));};
+  {
+  
+  my_node =(long)(uintptr_t)(liblock_execute_operation(&(Global->IndexLock), (void *)(uintptr_t)(NULL), &function13));
+  }
   my_node = my_node%num_nodes;
 
 /*  POSSIBLE ENHANCEMENT:  Here's where one might bind the process to a
@@ -239,6 +259,17 @@ this barrier either.
 }
 
 
+void * function20(void *ctx18);
+void *function20(void *ctx18) {
+  {
+    long my_node;
+    {
+      my_node = Global->Index++;
+    }
+    return (void *)(uintptr_t)my_node;
+  }
+}
+
 void Or_Neighbors_In_Base()
 {
   long outx,outy,outz;	/* Loop indices in image space               */
@@ -247,9 +278,10 @@ void Or_Neighbors_In_Base()
   long pmap_partition,zstart,zstop;
   long my_node;
 
-  {pthread_mutex_lock(&(Global->IndexLock));};
-  my_node = Global->Index++;
-  {pthread_mutex_unlock(&(Global->IndexLock));};
+  {
+  
+  my_node =(long)(uintptr_t)(liblock_execute_operation(&(Global->IndexLock), (void *)(uintptr_t)(NULL), &function20));
+  }
   my_node = my_node%num_nodes;
 
 /*  POSSIBLE ENHANCEMENT:  Here's where one might bind the process to a
diff -u -p a/codes/apps/volrend/map.c b/codes/apps/volrend/map.c
--- a/codes/apps/volrend/map.c
+++ b/codes/apps/volrend/map.c
@@ -55,9 +55,17 @@ DENSITY *map_address;		/* Pointer to map
 
 
 #include <pthread.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <sys/time.h>
 #include <unistd.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <malloc.h>
 extern pthread_t PThreadTable[];
 
diff -u -p a/codes/apps/volrend/normal.c b/codes/apps/volrend/normal.c
--- a/codes/apps/volrend/normal.c
+++ b/codes/apps/volrend/normal.c
@@ -45,9 +45,17 @@ float nmag_epsilon;
 
 
 #include <pthread.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <sys/time.h>
 #include <unistd.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <malloc.h>
 extern pthread_t PThreadTable[];
 
@@ -113,6 +121,17 @@ void Allocate_Normal(address, length)
 }
 
 
+void * function27(void *ctx25);
+void *function27(void *ctx25) {
+  {
+    long my_node;
+    {
+      my_node = Global->Index++;
+    }
+    return (void *)(uintptr_t)my_node;
+  }
+}
+
 void Normal_Compute()
 {
   long inx,iny,inz;	/* Voxel location in object space            */
@@ -125,9 +144,10 @@ void Normal_Compute()
   long xstart,xstop,ystart,ystop;
   long my_node;
 
-  {pthread_mutex_lock(&(Global->IndexLock));};
-  my_node = Global->Index++;
-  {pthread_mutex_unlock(&(Global->IndexLock));};
+  {
+  
+  my_node =(long)(uintptr_t)(liblock_execute_operation(&(Global->IndexLock), (void *)(uintptr_t)(NULL), &function27));
+  }
   my_node = my_node%num_nodes;
 
 /*  POSSIBLE ENHANCEMENT:  Here's where one might bind the process to a
diff -u -p a/codes/apps/volrend/raytrace.c b/codes/apps/volrend/raytrace.c
--- a/codes/apps/volrend/raytrace.c
+++ b/codes/apps/volrend/raytrace.c
@@ -38,9 +38,17 @@ extern long traversal_time,trilirp_time,
 
 
 #include <pthread.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <sys/time.h>
 #include <unistd.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <malloc.h>
 extern pthread_t PThreadTable[];
 
diff -u -p a/codes/apps/volrend/render.c b/codes/apps/volrend/render.c
--- a/codes/apps/volrend/render.c
+++ b/codes/apps/volrend/render.c
@@ -29,9 +29,17 @@ float obshighlight[NM];		/*   observer t
 
 
 #include <pthread.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <sys/time.h>
 #include <unistd.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <malloc.h>
 extern pthread_t PThreadTable[];
 
diff -u -p a/codes/apps/volrend/libtiff/tiffcompat.h b/codes/apps/volrend/libtiff/tiffcompat.h
--- a/codes/apps/volrend/libtiff/tiffcompat.h
+++ b/codes/apps/volrend/libtiff/tiffcompat.h
@@ -64,6 +64,10 @@
 #endif
 #if defined(THINK_C) || defined(applec)
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #endif
 
 /*
@@ -179,6 +183,10 @@ extern	void *realloc(void *ptr, size_t s
 #else /* !MSDOS */
 #if defined(_IBMR2)
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #else /* !_IBMR2 */
 extern	char *malloc();
 extern	char *realloc();
diff -u -p a/codes/apps/volrend/adaptive.c b/codes/apps/volrend/adaptive.c
--- a/codes/apps/volrend/adaptive.c
+++ b/codes/apps/volrend/adaptive.c
@@ -41,15 +41,58 @@ long itest;
 
 
 #include <pthread.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <sys/time.h>
 #include <unistd.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <malloc.h>
 extern pthread_t PThreadTable[];
 
 
 #include "anl.h"
 
+union instance47 {struct input45{long exectime1;long exectime;long my_node;} input45;};
+void * function48(void *ctx46);
+void *function48(void *ctx46) {
+  {
+    struct input45 *incontext43=&(((union instance47 *)ctx46)->input45);
+    long exectime1=incontext43->exectime1;
+    long exectime=incontext43->exectime;
+    long my_node=incontext43->my_node;
+    {
+      printf("%3ld\t%3ld\t%6ld\t%6ld\t%6ld\t%6ld\t%8ld\n", my_node, frame, exectime, exectime1, num_rays_traced, num_traced_rays_hit_volume, num_samples_trilirped);
+    }
+    return NULL;
+  }
+}
+
+void * function41(void *ctx39);
+void *function41(void *ctx39) {
+  {
+    {
+      Global->Counter--;
+    }
+    return NULL;
+  }
+}
+
+void * function34(void *ctx32);
+void *function34(void *ctx32) {
+  {
+    {
+      Global->Counter--;
+    }
+    return NULL;
+  }
+}
+
 void Ray_Trace(long my_node)
 {
   long i,j;
@@ -106,9 +149,8 @@ void Ray_Trace(long my_node)
 };
     Pre_Shade(my_node);
 
-    {pthread_mutex_lock(&(Global->CountLock));};
-    Global->Counter--;
-    {pthread_mutex_unlock(&(Global->CountLock));};
+    {
+    liblock_execute_operation(&(Global->CountLock), (void *)(uintptr_t)(NULL), &function34); }
     while (Global->Counter);
 
     Ray_Trace_Adaptively(my_node);
@@ -175,9 +217,8 @@ void Ray_Trace(long my_node)
 
     Pre_Shade(my_node);
 
-    {pthread_mutex_lock(&(Global->CountLock));};
-    Global->Counter--;
-    {pthread_mutex_unlock(&(Global->CountLock));};
+    {
+    liblock_execute_operation(&(Global->CountLock), (void *)(uintptr_t)(NULL), &function41); }
     while (Global->Counter);
 
     Ray_Trace_Non_Adaptively(my_node);
@@ -197,12 +238,15 @@ void Ray_Trace(long my_node)
     exectime1 = 0;
   }
 
-    {pthread_mutex_lock(&(Global->CountLock));};
-    printf("%3ld\t%3ld\t%6ld\t%6ld\t%6ld\t%6ld\t%8ld\n",my_node,frame,exectime,
-	   exectime1,num_rays_traced,num_traced_rays_hit_volume,
-	   num_samples_trilirped);
-
-    {pthread_mutex_unlock(&(Global->CountLock));};
+    { union instance47 instance47 = {
+      {
+        exectime1,
+        exectime,
+        my_node,
+      },
+    };
+    
+    liblock_execute_operation(&(Global->CountLock), (void *)(uintptr_t)(&instance47), &function48); }
 
   {
 	pthread_barrier_wait(&(Global->TimeBarrier));
@@ -210,6 +254,42 @@ void Ray_Trace(long my_node)
 }
 
 
+void * function69(void *ctx67);
+void *function69(void *ctx67) {
+  {
+    {
+      Global->Queue[num_nodes][0]--;
+    }
+    return NULL;
+  }
+}
+
+void * function62(void *ctx60);
+void *function62(void *ctx60) {
+  {
+    long work;
+    long local_node=(long)(uintptr_t)ctx60;
+    {
+      work = Global->Queue[local_node][0];
+      Global->Queue[local_node][0] += 1;
+    }
+    return (void *)(uintptr_t)work;
+  }
+}
+
+void * function55(void *ctx53);
+void *function55(void *ctx53) {
+  {
+    long work;
+    long local_node=(long)(uintptr_t)ctx53;
+    {
+      work = Global->Queue[local_node][0];
+      Global->Queue[local_node][0] += 1;
+    }
+    return (void *)(uintptr_t)work;
+  }
+}
+
 void Ray_Trace_Adaptively(long my_node)
 {
   long outx,outy,yindex,xindex;
@@ -236,10 +316,11 @@ void Ray_Trace_Adaptively(long my_node)
     ystart = ROUNDUP((float)ystart/(float)highest_sampling_boxlen);
     ystart = ystart * highest_sampling_boxlen;
     ystop = MIN(ystart+num_yqueue,image_len[Y]);
-    {pthread_mutex_lock(&Global->QLock[local_node]);};
-    work = Global->Queue[local_node][0];
-    Global->Queue[local_node][0] += 1;
-    {pthread_mutex_unlock(&Global->QLock[local_node]);};
+    {
+    
+    work =(long)(uintptr_t)(liblock_execute_operation(&Global->QLock[local_node], (void *)(uintptr_t)(local_node),
+                              &function55));
+    }
     while (work < lnum_blocks) {
       xindex = xstart + (work%lnum_xblocks)*block_xlen;
       yindex = ystart + (work/lnum_xblocks)*block_ylen;
@@ -253,15 +334,16 @@ void Ray_Trace_Adaptively(long my_node)
 	  Ray_Trace_Adaptive_Box(outx,outy,highest_sampling_boxlen);
 	}
       }
-      {pthread_mutex_lock(&Global->QLock[local_node]);};
-      work = Global->Queue[local_node][0];
-      Global->Queue[local_node][0] += 1;
-      {pthread_mutex_unlock(&Global->QLock[local_node]);};
+      {
+      
+      work =(long)(uintptr_t)(liblock_execute_operation(&Global->QLock[local_node], (void *)(uintptr_t)(local_node),
+                                &function62));
+      }
     }
     if (my_node == local_node) {
-      {pthread_mutex_lock(&Global->QLock[num_nodes]);};
-      Global->Queue[num_nodes][0]--;
-      {pthread_mutex_unlock(&Global->QLock[num_nodes]);};
+      {
+      liblock_execute_operation(&Global->QLock[num_nodes], (void *)(uintptr_t)(NULL),
+                                &function69); }
     }
     local_node = (local_node+1)%num_nodes;
     while (Global->Queue[local_node][0] >= lnum_blocks &&
@@ -377,6 +459,40 @@ void Ray_Trace_Adaptive_Box(long outx, l
 }
 
 
+void * function90(void *ctx88);
+void *function90(void *ctx88) {
+  {
+    {
+      Global->Queue[num_nodes][0]--;
+    }
+    return NULL;
+  }
+}
+
+void * function83(void *ctx81);
+void *function83(void *ctx81) {
+  {
+    long work;
+    long local_node=(long)(uintptr_t)ctx81;
+    {
+      work = Global->Queue[local_node][0]++;
+    }
+    return (void *)(uintptr_t)work;
+  }
+}
+
+void * function76(void *ctx74);
+void *function76(void *ctx74) {
+  {
+    long work;
+    long local_node=(long)(uintptr_t)ctx74;
+    {
+      work = Global->Queue[local_node][0]++;
+    }
+    return (void *)(uintptr_t)work;
+  }
+}
+
 void Ray_Trace_Non_Adaptively(long my_node)
 {
   long outx,outy,xindex,yindex;
@@ -399,9 +515,11 @@ void Ray_Trace_Non_Adaptively(long my_no
     xstop = MIN(xstart+num_xqueue,image_len[X]);
     ystart = (local_node / image_section[X]) * num_yqueue;
     ystop = MIN(ystart+num_yqueue,image_len[Y]);
-    {pthread_mutex_lock(&Global->QLock[local_node]);};
-    work = Global->Queue[local_node][0]++;
-    {pthread_mutex_unlock(&Global->QLock[local_node]);};
+    {
+    
+    work =(long)(uintptr_t)(liblock_execute_operation(&Global->QLock[local_node], (void *)(uintptr_t)(local_node),
+                              &function76));
+    }
     while (work < lnum_blocks) {
       xindex = xstart + (work%lnum_xblocks)*block_xlen;
       yindex = ystart + (work/lnum_xblocks)*block_ylen;
@@ -416,14 +534,16 @@ void Ray_Trace_Non_Adaptively(long my_no
 	  Trace_Ray(foutx,fouty,pixel_address);
 	}
       }
-      {pthread_mutex_lock(&Global->QLock[local_node]);};
-      work = Global->Queue[local_node][0]++;
-      {pthread_mutex_unlock(&Global->QLock[local_node]);};
+      {
+      
+      work =(long)(uintptr_t)(liblock_execute_operation(&Global->QLock[local_node], (void *)(uintptr_t)(local_node),
+                                &function83));
+      }
     }
     if (my_node == local_node) {
-      {pthread_mutex_lock(&Global->QLock[num_nodes]);};
-      Global->Queue[num_nodes][0]--;
-      {pthread_mutex_unlock(&Global->QLock[num_nodes]);};
+      {
+      liblock_execute_operation(&Global->QLock[num_nodes], (void *)(uintptr_t)(NULL),
+                                &function90); }
     }
     local_node = (local_node+1)%num_nodes;
     while (Global->Queue[local_node][0] >= lnum_blocks &&
diff -u -p a/codes/apps/volrend/option.c b/codes/apps/volrend/option.c
--- a/codes/apps/volrend/option.c
+++ b/codes/apps/volrend/option.c
@@ -79,9 +79,17 @@ float angle[NM];                /* initi
 
 
 #include <pthread.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <sys/time.h>
 #include <unistd.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <malloc.h>
 extern pthread_t PThreadTable[];
 
diff -u -p a/codes/apps/volrend/main.c b/codes/apps/volrend/main.c
--- a/codes/apps/volrend/main.c
+++ b/codes/apps/volrend/main.c
@@ -38,9 +38,17 @@
 
 
 #include <pthread.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <sys/time.h>
 #include <unistd.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <malloc.h>
 /** +EDIT */
 //#define MAX_THREADS 32
@@ -147,14 +155,15 @@ void Frame()
   Global = (struct GlobalMemory *)valloc(sizeof(struct GlobalMemory));;
   {pthread_barrier_init(&(Global->SlaveBarrier), NULL, num_nodes);};
   {pthread_barrier_init(&(Global->TimeBarrier), NULL, num_nodes);};
-  pthread_mutex_init(&(Global->IndexLock), NULL);;
-  pthread_mutex_init(&(Global->CountLock), NULL);;
+  liblock_lock_init(TYPE_NOINFO, ARG_NOINFO, &(Global->IndexLock), NULL);;
+  liblock_lock_init(TYPE_NOINFO, ARG_NOINFO, &(Global->CountLock), NULL);;
   
 {
 	unsigned long	i, Error;
 
 	for (i = 0; i < MAX_NUMPROC+1; i++) {
-		Error = pthread_mutex_init(&Global->QLock[i], NULL);
+		Error = liblock_lock_init(TYPE_NOINFO, ARG_NOINFO,
+                                          &Global->QLock[i], NULL);
 		if (Error != 0) {
 			printf("Error while initializing array of locks.\n");
 			exit(-1);
@@ -306,7 +315,7 @@ void Frame()
 	long	i, Error;
 
 	for (i = 0; i < (num_nodes) - 1; i++) {
-		Error = pthread_create(&PThreadTable[i], NULL, (void * (*)(void *))(Render_Loop), NULL);
+		Error = liblock_thread_create(&PThreadTable[i], NULL, (void * (*)(void *))(Render_Loop), NULL);
 		if (Error != 0) {
 			printf("Error in pthread_create().\n");
 			exit(-1);
@@ -318,6 +327,17 @@ void Frame()
 }
 
 
+void * function97(void *ctx95);
+void *function97(void *ctx95) {
+  {
+    long my_node;
+    {
+      my_node = Global->Index++;
+    }
+    return (void *)(uintptr_t)my_node;
+  }
+}
+
 void Render_Loop()
 {
   long step,i;
@@ -328,9 +348,10 @@ void Render_Loop()
   float inv_num_nodes;
   long my_node;
 
-  {pthread_mutex_lock(&(Global->IndexLock));};
-  my_node = Global->Index++;
-  {pthread_mutex_unlock(&(Global->IndexLock));};
+  {
+  
+  my_node =(long)(uintptr_t)(liblock_execute_operation(&(Global->IndexLock), (void *)(uintptr_t)(NULL), &function97));
+  }
   my_node = my_node%num_nodes;
 
   {;};
@@ -628,8 +649,10 @@ long WriteGrayscaleTIFF(char *filename, 
         cmap[c] = (long)(c * factor);
 
     /* open and initialize output file */
-    if ((outimage = TIFFOpen(filename, "w")) == NULL)
-        return(0);
+    if ((outimage = TIFFOpen(filename, "w")) == NULL) {
+        
+            return((0));
+        }
     TIFFSetField(outimage, TIFFTAG_IMAGEWIDTH, width);
     TIFFSetField(outimage, TIFFTAG_IMAGELENGTH, height);
     TIFFSetField(outimage, TIFFTAG_BITSPERSAMPLE, 8);
@@ -644,12 +667,12 @@ long WriteGrayscaleTIFF(char *filename, 
     for (y = 0; y < height; y++) {
         if (!TIFFWriteScanline(outimage, data, y, 0)) {
             TIFFClose(outimage);
-            return(0);
+            return((0));
         }
         data += scanbytes;
     }
 
     /* close the file */
     TIFFClose(outimage);
-    return(1);
+    return((1));
 }
diff -u -p a/codes/apps/volrend/view.c b/codes/apps/volrend/view.c
--- a/codes/apps/volrend/view.c
+++ b/codes/apps/volrend/view.c
@@ -51,9 +51,17 @@ float invmatrix[4][4];		/* Inverse of vi
 
 
 #include <pthread.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <sys/time.h>
 #include <unistd.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <malloc.h>
 extern pthread_t PThreadTable[];
 
diff -u -p a/codes/apps/water-nsquared/global.h b/codes/apps/water-nsquared/global.h
--- a/codes/apps/water-nsquared/global.h
+++ b/codes/apps/water-nsquared/global.h
@@ -22,16 +22,16 @@ by the program. */
 #define MAXLCKS	4096L
 
 struct GlobalMemory {
-    pthread_mutex_t IOLock;
-    pthread_mutex_t IndexLock;
-    pthread_mutex_t IntrafVirLock;
-    pthread_mutex_t InterfVirLock;
-    pthread_mutex_t FXLock;
-    pthread_mutex_t FYLock;
-    pthread_mutex_t FZLock;
-    pthread_mutex_t KinetiSumLock;
-    pthread_mutex_t PotengSumLock;
-    pthread_mutex_t MolLock[MAXLCKS];
+    liblock_lock_t IOLock;
+    liblock_lock_t IndexLock;
+    liblock_lock_t IntrafVirLock;
+    liblock_lock_t InterfVirLock;
+    liblock_lock_t FXLock;
+    liblock_lock_t FYLock;
+    liblock_lock_t FZLock;
+    liblock_lock_t KinetiSumLock;
+    liblock_lock_t PotengSumLock;
+    liblock_lock_t MolLock[MAXLCKS];
     
 pthread_barrier_t	(start);
 
diff -u -p a/codes/apps/water-nsquared/cshift.c b/codes/apps/water-nsquared/cshift.c
--- a/codes/apps/water-nsquared/cshift.c
+++ b/codes/apps/water-nsquared/cshift.c
@@ -17,9 +17,17 @@
 
 
 #include <pthread.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <sys/time.h>
 #include <unistd.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <malloc.h>
 extern pthread_t PThreadTable[];
 
diff -u -p a/codes/apps/water-nsquared/syscons.c b/codes/apps/water-nsquared/syscons.c
--- a/codes/apps/water-nsquared/syscons.c
+++ b/codes/apps/water-nsquared/syscons.c
@@ -17,9 +17,17 @@
 
 
 #include <pthread.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <sys/time.h>
 #include <unistd.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <malloc.h>
 extern pthread_t PThreadTable[];
 
diff -u -p a/codes/apps/water-nsquared/interf.c b/codes/apps/water-nsquared/interf.c
--- a/codes/apps/water-nsquared/interf.c
+++ b/codes/apps/water-nsquared/interf.c
@@ -17,9 +17,17 @@
 
 
 #include <pthread.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <sys/time.h>
 #include <unistd.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <malloc.h>
 extern pthread_t PThreadTable[];
 
@@ -35,6 +43,86 @@ extern pthread_t PThreadTable[];
 
 double ****PFORCES;
 
+union instance26 {struct input24{long ProcID;long DEST;long mol;} input24;};
+union instance19 {struct input17{long ProcID;long DEST;long mol;} input17;};
+union instance12 {struct input10{long ProcID;long DEST;long mol;} input10;};
+union instance5 {struct input3{double *VIR;double LVIR;} input3;};
+void * function27(void *ctx25);
+void *function27(void *ctx25) {
+    {
+        struct input24 *incontext22=&(((union instance26 *)ctx25)->input24);
+        double *temp_p;
+        long dir;
+        long ProcID=incontext22->ProcID;
+        long DEST=incontext22->DEST;
+        long mol=incontext22->mol;
+        {
+            for (dir = XDIR;dir <= ZDIR;dir++) {
+                temp_p = VAR[mol].F[DEST][dir];
+                temp_p[H1] += PFORCES[ProcID][mol][dir][H1];
+                temp_p[O] += PFORCES[ProcID][mol][dir][O];
+                temp_p[H2] += PFORCES[ProcID][mol][dir][H2];
+            }
+        }
+        return (void *)(uintptr_t)dir;
+    }
+}
+
+void * function20(void *ctx18);
+void *function20(void *ctx18) {
+    {
+        struct input17 *incontext15=&(((union instance19 *)ctx18)->input17);
+        double *temp_p;
+        long dir;
+        long ProcID=incontext15->ProcID;
+        long DEST=incontext15->DEST;
+        long mol=incontext15->mol;
+        {
+            for (dir = XDIR;dir <= ZDIR;dir++) {
+                temp_p = VAR[mol].F[DEST][dir];
+                temp_p[H1] += PFORCES[ProcID][mol][dir][H1];
+                temp_p[O] += PFORCES[ProcID][mol][dir][O];
+                temp_p[H2] += PFORCES[ProcID][mol][dir][H2];
+            }
+        }
+        return (void *)(uintptr_t)dir;
+    }
+}
+
+void * function13(void *ctx11);
+void *function13(void *ctx11) {
+    {
+        struct input10 *incontext8=&(((union instance12 *)ctx11)->input10);
+        double *temp_p;
+        long dir;
+        long ProcID=incontext8->ProcID;
+        long DEST=incontext8->DEST;
+        long mol=incontext8->mol;
+        {
+            for (dir = XDIR;dir <= ZDIR;dir++) {
+                temp_p = VAR[mol].F[DEST][dir];
+                temp_p[H1] += PFORCES[ProcID][mol][dir][H1];
+                temp_p[O] += PFORCES[ProcID][mol][dir][O];
+                temp_p[H2] += PFORCES[ProcID][mol][dir][H2];
+            }
+        }
+        return (void *)(uintptr_t)dir;
+    }
+}
+
+void * function6(void *ctx4);
+void *function6(void *ctx4) {
+    {
+        struct input3 *incontext1=&(((union instance5 *)ctx4)->input3);
+        double *VIR=incontext1->VIR;
+        double LVIR=incontext1->LVIR;
+        {
+            *VIR = *VIR + LVIR;
+        }
+        return NULL;
+    }
+}
+
 /* in this version of interf, a private force array is maintained */
 /* for every process.  A process computes interactions into its   */
 /* private force array, and later updates the shared destination  */
@@ -150,9 +238,14 @@ void INTERF(long DEST, double *VIR, long
 
     /*  accumulate the running sum from private
         per-interaction partial sums   */
-    {pthread_mutex_lock(&(gl->InterfVirLock));};
-    *VIR = *VIR + LVIR;
-    {pthread_mutex_unlock(&(gl->InterfVirLock));};
+    { union instance5 instance5 = {
+        {
+            VIR,
+            LVIR,
+        },
+    };
+    
+    liblock_execute_operation(&(gl->InterfVirLock), (void *)(uintptr_t)(&instance5), &function6); }
 
     /* at the end of the above force-computation, comp_last */
     /* contains the number of the last molecule (no modulo) */
@@ -160,37 +253,46 @@ void INTERF(long DEST, double *VIR, long
 
     if (comp_last > NMOL1) {
         for (mol = StartMol[ProcID]; mol < NMOL; mol++) {
-            {pthread_mutex_lock(&gl->MolLock[mol % MAXLCKS]);};
-            for ( dir = XDIR; dir  <= ZDIR; dir++) {
-                temp_p = VAR[mol].F[DEST][dir];
-                temp_p[H1] += PFORCES[ProcID][mol][dir][H1];
-                temp_p[O]  += PFORCES[ProcID][mol][dir][O];
-                temp_p[H2] += PFORCES[ProcID][mol][dir][H2];
+            { union instance12 instance12 = {
+                {
+                    ProcID,
+                    DEST,
+                    mol,
+                },
+            };
+            
+            dir =(long)(uintptr_t)(liblock_execute_operation(&gl->MolLock[mol % MAXLCKS],
+                                      (void *)(uintptr_t)(&instance12), &function13));
             }
-            {pthread_mutex_unlock(&gl->MolLock[mol % MAXLCKS]);};
         }
         comp = comp_last % NMOL;
         for (mol = 0; ((mol <= comp) && (mol < StartMol[ProcID])); mol++) {
-            {pthread_mutex_lock(&gl->MolLock[mol % MAXLCKS]);};
-            for ( dir = XDIR; dir  <= ZDIR; dir++) {
-                temp_p = VAR[mol].F[DEST][dir];
-                temp_p[H1] += PFORCES[ProcID][mol][dir][H1];
-                temp_p[O]  += PFORCES[ProcID][mol][dir][O];
-                temp_p[H2] += PFORCES[ProcID][mol][dir][H2];
+            { union instance19 instance19 = {
+                {
+                    ProcID,
+                    DEST,
+                    mol,
+                },
+            };
+            
+            dir =(long)(uintptr_t)(liblock_execute_operation(&gl->MolLock[mol % MAXLCKS],
+                                      (void *)(uintptr_t)(&instance19), &function20));
             }
-            {pthread_mutex_unlock(&gl->MolLock[mol % MAXLCKS]);};
         }
     }
     else{
         for (mol = StartMol[ProcID]; mol <= comp_last; mol++) {
-            {pthread_mutex_lock(&gl->MolLock[mol % MAXLCKS]);};
-            for ( dir = XDIR; dir  <= ZDIR; dir++) {
-                temp_p = VAR[mol].F[DEST][dir];
-                temp_p[H1] += PFORCES[ProcID][mol][dir][H1];
-                temp_p[O]  += PFORCES[ProcID][mol][dir][O];
-                temp_p[H2] += PFORCES[ProcID][mol][dir][H2];
+            { union instance26 instance26 = {
+                {
+                    ProcID,
+                    DEST,
+                    mol,
+                },
+            };
+            
+            dir =(long)(uintptr_t)(liblock_execute_operation(&gl->MolLock[mol % MAXLCKS],
+                                      (void *)(uintptr_t)(&instance26), &function27));
             }
-            {pthread_mutex_unlock(&gl->MolLock[mol % MAXLCKS]);};
         }
     }
 
diff -u -p a/codes/apps/water-nsquared/intraf.c b/codes/apps/water-nsquared/intraf.c
--- a/codes/apps/water-nsquared/intraf.c
+++ b/codes/apps/water-nsquared/intraf.c
@@ -17,9 +17,17 @@
 
 
 #include <pthread.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <sys/time.h>
 #include <unistd.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <malloc.h>
 extern pthread_t PThreadTable[];
 
@@ -33,6 +41,20 @@ extern pthread_t PThreadTable[];
 #include "split.h"
 #include "global.h"
 
+union instance33 {struct input31{double *VIR;double LVIR;} input31;};
+void * function34(void *ctx32);
+void *function34(void *ctx32) {
+    {
+        struct input31 *incontext29=&(((union instance33 *)ctx32)->input31);
+        double *VIR=incontext29->VIR;
+        double LVIR=incontext29->LVIR;
+        {
+            *VIR = *VIR + LVIR;
+        }
+        return NULL;
+    }
+}
+
 void INTRAF(double *VIR, long ProcID)
 {
     /*
@@ -137,7 +159,12 @@ void INTRAF(double *VIR, long ProcID)
                 LVIR += VAR[mol].F[DISP][dir][atom] *
                     VAR[mol].F[FORCES][dir][atom];
 
-    {pthread_mutex_lock(&(gl->IntrafVirLock));};
-    *VIR =  *VIR + LVIR;
-    {pthread_mutex_unlock(&(gl->IntrafVirLock));};
+    { union instance33 instance33 = {
+        {
+            VIR,
+            LVIR,
+        },
+    };
+    
+    liblock_execute_operation(&(gl->IntrafVirLock), (void *)(uintptr_t)(&instance33), &function34); }
 } /* end of subroutine INTRAF */
diff -u -p a/codes/apps/water-nsquared/predcor.c b/codes/apps/water-nsquared/predcor.c
--- a/codes/apps/water-nsquared/predcor.c
+++ b/codes/apps/water-nsquared/predcor.c
@@ -17,9 +17,17 @@
 
 
 #include <pthread.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <sys/time.h>
 #include <unistd.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <malloc.h>
 extern pthread_t PThreadTable[];
 
diff -u -p a/codes/apps/water-nsquared/mdmain.c b/codes/apps/water-nsquared/mdmain.c
--- a/codes/apps/water-nsquared/mdmain.c
+++ b/codes/apps/water-nsquared/mdmain.c
@@ -17,9 +17,17 @@
 
 
 #include <pthread.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <sys/time.h>
 #include <unistd.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <malloc.h>
 extern pthread_t PThreadTable[];
 
diff -u -p a/codes/apps/water-nsquared/bndry.c b/codes/apps/water-nsquared/bndry.c
--- a/codes/apps/water-nsquared/bndry.c
+++ b/codes/apps/water-nsquared/bndry.c
@@ -17,9 +17,17 @@
 
 
 #include <pthread.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <sys/time.h>
 #include <unistd.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <malloc.h>
 extern pthread_t PThreadTable[];
 
diff -u -p a/codes/apps/water-nsquared/water.c b/codes/apps/water-nsquared/water.c
--- a/codes/apps/water-nsquared/water.c
+++ b/codes/apps/water-nsquared/water.c
@@ -46,9 +46,17 @@
 
 
 #include <pthread.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <sys/time.h>
 #include <unistd.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <malloc.h>
 /** +EDIT */
 //#define MAX_THREADS 32
@@ -196,20 +204,21 @@ int main(int argc, char **argv)
         {pthread_barrier_init(&(gl->start), NULL, NumProcs);};
 	{pthread_barrier_init(&(gl->InterfBar), NULL, NumProcs);};
 	{pthread_barrier_init(&(gl->PotengBar), NULL, NumProcs);};
-        pthread_mutex_init(&(gl->IOLock), NULL);;
-        pthread_mutex_init(&(gl->IndexLock), NULL);;
-        pthread_mutex_init(&(gl->IntrafVirLock), NULL);;
-        pthread_mutex_init(&(gl->InterfVirLock), NULL);;
-        pthread_mutex_init(&(gl->FXLock), NULL);;
-        pthread_mutex_init(&(gl->FYLock), NULL);;
-        pthread_mutex_init(&(gl->FZLock), NULL);;
+        liblock_lock_init(TYPE_NOINFO, ARG_NOINFO, &(gl->IOLock), NULL);;
+        liblock_lock_init(TYPE_NOINFO, ARG_NOINFO, &(gl->IndexLock), NULL);;
+        liblock_lock_init(TYPE_NOINFO, ARG_NOINFO, &(gl->IntrafVirLock), NULL);;
+        liblock_lock_init(TYPE_NOINFO, ARG_NOINFO, &(gl->InterfVirLock), NULL);;
+        liblock_lock_init(TYPE_NOINFO, ARG_NOINFO, &(gl->FXLock), NULL);;
+        liblock_lock_init(TYPE_NOINFO, ARG_NOINFO, &(gl->FYLock), NULL);;
+        liblock_lock_init(TYPE_NOINFO, ARG_NOINFO, &(gl->FZLock), NULL);;
         if (NMOL < MAXLCKS) {
             
 {
 	unsigned long	i, Error;
 
 	for (i = 0; i < NMOL; i++) {
-		Error = pthread_mutex_init(&gl->MolLock[i], NULL);
+		Error = liblock_lock_init(TYPE_NOINFO, ARG_NOINFO,
+                                          &gl->MolLock[i], NULL);
 		if (Error != 0) {
 			printf("Error while initializing array of locks.\n");
 			exit(-1);
@@ -224,7 +233,8 @@ int main(int argc, char **argv)
 	unsigned long	i, Error;
 
 	for (i = 0; i < MAXLCKS; i++) {
-		Error = pthread_mutex_init(&gl->MolLock[i], NULL);
+		Error = liblock_lock_init(TYPE_NOINFO, ARG_NOINFO,
+                                          &gl->MolLock[i], NULL);
 		if (Error != 0) {
 			printf("Error while initializing array of locks.\n");
 			exit(-1);
@@ -233,8 +243,8 @@ int main(int argc, char **argv)
 }
 ;
         }
-        pthread_mutex_init(&(gl->KinetiSumLock), NULL);;
-        pthread_mutex_init(&(gl->PotengSumLock), NULL);;
+        liblock_lock_init(TYPE_NOINFO, ARG_NOINFO, &(gl->KinetiSumLock), NULL);;
+        liblock_lock_init(TYPE_NOINFO, ARG_NOINFO, &(gl->PotengSumLock), NULL);;
 
         /* set up control for static scheduling */
 
@@ -290,7 +300,7 @@ int main(int argc, char **argv)
 	long	i, Error;
 
 	for (i = 0; i < (NumProcs) - 1; i++) {
-		Error = pthread_create(&PThreadTable[i], NULL, (void * (*)(void *))(WorkStart), NULL);
+		Error = liblock_thread_create(&PThreadTable[i], NULL, (void * (*)(void *))(WorkStart), NULL);
 		if (Error != 0) {
 			printf("Error in pthread_create().\n");
 			exit(-1);
@@ -329,7 +339,18 @@ int main(int argc, char **argv)
     printf("\nExited Happily with XTT = %g (note: XTT value is garbage if NPRINT > NSTEP)\n", XTT);
 
     {exit(0);};
-} /* main.c */
+} void * function41(void *ctx39);
+void *function41(void *ctx39) {
+    {
+        long ProcID;
+        {
+            ProcID = gl->Index++;
+        }
+        return (void *)(uintptr_t)ProcID;
+    }
+}
+
+/* main.c */
 
 void WorkStart() /* routine that each created process starts at;
                     it simply calls the timestep routine */
@@ -337,9 +358,10 @@ void WorkStart() /* routine that each cr
     long ProcID;
     double LocalXTT;
 
-    {pthread_mutex_lock(&(gl->IndexLock));};
-    ProcID = gl->Index++;
-    {pthread_mutex_unlock(&(gl->IndexLock));};
+    {
+    
+    ProcID =(long)(uintptr_t)(liblock_execute_operation(&(gl->IndexLock), (void *)(uintptr_t)(NULL), &function41));
+    }
 
     {;};
     {;};
diff -u -p a/codes/apps/water-nsquared/cnstnt.c b/codes/apps/water-nsquared/cnstnt.c
--- a/codes/apps/water-nsquared/cnstnt.c
+++ b/codes/apps/water-nsquared/cnstnt.c
@@ -17,9 +17,17 @@
 
 
 #include <pthread.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <sys/time.h>
 #include <unistd.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <malloc.h>
 extern pthread_t PThreadTable[];
 
diff -u -p a/codes/apps/water-nsquared/poteng.c b/codes/apps/water-nsquared/poteng.c
--- a/codes/apps/water-nsquared/poteng.c
+++ b/codes/apps/water-nsquared/poteng.c
@@ -17,9 +17,17 @@
 
 
 #include <pthread.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <sys/time.h>
 #include <unistd.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <malloc.h>
 extern pthread_t PThreadTable[];
 
@@ -33,6 +41,26 @@ extern pthread_t PThreadTable[];
 #include "split.h"
 #include "global.h"
 
+union instance47 {struct input45{double *PTRF;double *POTR;double *POTA;double LPTRF;double LPOTR;double LPOTA;} input45;};
+void * function48(void *ctx46);
+void *function48(void *ctx46) {
+{
+struct input45 *incontext43=&(((union instance47 *)ctx46)->input45);
+double *PTRF=incontext43->PTRF;
+double *POTR=incontext43->POTR;
+double *POTA=incontext43->POTA;
+double LPTRF=incontext43->LPTRF;
+double LPOTR=incontext43->LPOTR;
+double LPOTA=incontext43->LPOTA;
+{
+*POTA = *POTA + LPOTA;
+*POTR = *POTR + LPOTR;
+*PTRF = *PTRF + LPTRF;
+}
+return NULL;
+}
+}
+
 void POTENG(double *POTA, double *POTR, double *PTRF, long ProcID)
 {
 
@@ -165,9 +193,16 @@ void POTENG(double *POTA, double *POTR, 
     } /* for mol */
 
     /* update shared sums from computed  private sums */
-    {pthread_mutex_lock(&(gl->PotengSumLock));};
-    *POTA = *POTA + LPOTA;
-    *POTR = *POTR + LPOTR;
-    *PTRF = *PTRF + LPTRF;
-    {pthread_mutex_unlock(&(gl->PotengSumLock));};
+    { union instance47 instance47 = {
+    {
+    PTRF,
+    POTR,
+    POTA,
+    LPTRF,
+    LPOTR,
+    LPOTA,
+    },
+    };
+    
+    liblock_execute_operation(&(gl->PotengSumLock), (void *)(uintptr_t)(&instance47), &function48); }
 } /* end of subroutine POTENG */
diff -u -p a/codes/apps/water-nsquared/kineti.c b/codes/apps/water-nsquared/kineti.c
--- a/codes/apps/water-nsquared/kineti.c
+++ b/codes/apps/water-nsquared/kineti.c
@@ -17,9 +17,17 @@
 
 
 #include <pthread.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <sys/time.h>
 #include <unistd.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <malloc.h>
 extern pthread_t PThreadTable[];
 
@@ -30,6 +38,21 @@ extern pthread_t PThreadTable[];
 #include "split.h"
 #include "global.h"
 
+  union instance54 {struct input52{double *SUM;double S;long dir;} input52;};
+  void * function55(void *ctx53);
+  void *function55(void *ctx53) {
+      {
+          struct input52 *incontext50=&(((union instance54 *)ctx53)->input52);
+          double *SUM=incontext50->SUM;
+          double S=incontext50->S;
+          long dir=incontext50->dir;
+          {
+              SUM[dir] += S;
+          }
+          return NULL;
+      }
+  }
+  
   /* this routine computes kinetic energy in each of the three spatial
      dimensions, and puts the computed values in the SUM array */
 void KINETI(double *SUM, double HMAS, double OMAS, long ProcID)
@@ -47,9 +70,16 @@ void KINETI(double *SUM, double HMAS, do
                   tempptr[H2] * tempptr[H2] ) * HMAS
                       + (tempptr[O] * tempptr[O]) * OMAS;
         }
-        {pthread_mutex_lock(&(gl->KinetiSumLock));};
-        SUM[dir]+=S;
-        {pthread_mutex_unlock(&(gl->KinetiSumLock));};
+        { union instance54 instance54 = {
+            {
+                SUM,
+                S,
+                dir,
+            },
+        };
+        
+        liblock_execute_operation(&(gl->KinetiSumLock), (void *)(uintptr_t)(&instance54),
+                                  &function55); }
     } /* for */
 } /* end of subroutine KINETI */
 
diff -u -p a/codes/apps/water-nsquared/initia.c b/codes/apps/water-nsquared/initia.c
--- a/codes/apps/water-nsquared/initia.c
+++ b/codes/apps/water-nsquared/initia.c
@@ -17,9 +17,17 @@
 
 
 #include <pthread.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <sys/time.h>
 #include <unistd.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <malloc.h>
 extern pthread_t PThreadTable[];
 
diff -u -p a/codes/apps/water-spatial/mddata.h b/codes/apps/water-spatial/mddata.h
--- a/codes/apps/water-spatial/mddata.h
+++ b/codes/apps/water-spatial/mddata.h
@@ -33,7 +33,7 @@ typedef struct link {
 
 typedef struct box_dummy {
       struct link *list;
-      pthread_mutex_t boxlock;
+      liblock_lock_t boxlock;
 } box_type;
 
 extern box_type ***BOX;
diff -u -p a/codes/apps/water-spatial/global.h b/codes/apps/water-spatial/global.h
--- a/codes/apps/water-spatial/global.h
+++ b/codes/apps/water-spatial/global.h
@@ -20,12 +20,12 @@ structure and the maximum number of mole
 by the program. */
 
 struct GlobalMemory {
-    pthread_mutex_t IOLock;
-    pthread_mutex_t IndexLock;
-    pthread_mutex_t IntrafVirLock;
-    pthread_mutex_t InterfVirLock;
-    pthread_mutex_t KinetiSumLock;
-    pthread_mutex_t PotengSumLock;
+    liblock_lock_t IOLock;
+    liblock_lock_t IndexLock;
+    liblock_lock_t IntrafVirLock;
+    liblock_lock_t InterfVirLock;
+    liblock_lock_t KinetiSumLock;
+    liblock_lock_t PotengSumLock;
     
 pthread_barrier_t	(start);
 
diff -u -p a/codes/apps/water-spatial/cshift.c b/codes/apps/water-spatial/cshift.c
--- a/codes/apps/water-spatial/cshift.c
+++ b/codes/apps/water-spatial/cshift.c
@@ -17,9 +17,17 @@
 
 
 #include <pthread.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <sys/time.h>
 #include <unistd.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <malloc.h>
 extern pthread_t PThreadTable[];
 
diff -u -p a/codes/apps/water-spatial/syscons.c b/codes/apps/water-spatial/syscons.c
--- a/codes/apps/water-spatial/syscons.c
+++ b/codes/apps/water-spatial/syscons.c
@@ -17,9 +17,17 @@
 
 
 #include <pthread.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <sys/time.h>
 #include <unistd.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <malloc.h>
 extern pthread_t PThreadTable[];
 
diff -u -p a/codes/apps/water-spatial/interf.c b/codes/apps/water-spatial/interf.c
--- a/codes/apps/water-spatial/interf.c
+++ b/codes/apps/water-spatial/interf.c
@@ -17,9 +17,17 @@
 
 
 #include <pthread.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <sys/time.h>
 #include <unistd.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <malloc.h>
 extern pthread_t PThreadTable[];
 
@@ -35,6 +43,20 @@ extern pthread_t PThreadTable[];
 #include "split.h"
 #include "global.h"
 
+union instance5 {struct input3{double *VIR;double LVIR;} input3;};
+void * function6(void *ctx4);
+void *function6(void *ctx4) {
+{
+struct input3 *incontext1=&(((union instance5 *)ctx4)->input3);
+double *VIR=incontext1->VIR;
+double LVIR=incontext1->LVIR;
+{
+*VIR = *VIR + LVIR / 2.0;
+}
+return NULL;
+}
+}
+
 void INTERF(long DEST, double *VIR, long ProcID)
 {
 
@@ -200,9 +222,14 @@ void INTERF(long DEST, double *VIR, long
 
     /*  accumulate running sum from private partial sums */
 
-    {pthread_mutex_lock(&(gl->InterfVirLock));};
-    *VIR = *VIR + LVIR/2.0;
-    {pthread_mutex_unlock(&(gl->InterfVirLock));};
+    { union instance5 instance5 = {
+    {
+    VIR,
+    LVIR,
+    },
+    };
+    
+    liblock_execute_operation(&(gl->InterfVirLock), (void *)(uintptr_t)(&instance5), &function6); }
 
     /* wait till all forces are updated */
 
diff -u -p a/codes/apps/water-spatial/intraf.c b/codes/apps/water-spatial/intraf.c
--- a/codes/apps/water-spatial/intraf.c
+++ b/codes/apps/water-spatial/intraf.c
@@ -17,9 +17,17 @@
 
 
 #include <pthread.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <sys/time.h>
 #include <unistd.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <malloc.h>
 extern pthread_t PThreadTable[];
 
@@ -35,6 +43,20 @@ extern pthread_t PThreadTable[];
 #include "split.h"
 #include "global.h"
 
+union instance12 {struct input10{double *VIR;double LVIR;} input10;};
+void * function13(void *ctx11);
+void *function13(void *ctx11) {
+{
+struct input10 *incontext8=&(((union instance12 *)ctx11)->input10);
+double *VIR=incontext8->VIR;
+double LVIR=incontext8->LVIR;
+{
+*VIR = *VIR + LVIR;
+}
+return NULL;
+}
+}
+
 void INTRAF(double *VIR, long ProcID)
 {
 
@@ -174,8 +196,13 @@ void INTRAF(double *VIR, long ProcID)
 
     /* Update potential energy */
 
-    {pthread_mutex_lock(&(gl->IntrafVirLock));};
-    *VIR =  *VIR + LVIR;
-    {pthread_mutex_unlock(&(gl->IntrafVirLock));};
+    { union instance12 instance12 = {
+    {
+    VIR,
+    LVIR,
+    },
+    };
+    
+    liblock_execute_operation(&(gl->IntrafVirLock), (void *)(uintptr_t)(&instance12), &function13); }
 
 } /* end of subroutine INTRAF */
diff -u -p a/codes/apps/water-spatial/predcor.c b/codes/apps/water-spatial/predcor.c
--- a/codes/apps/water-spatial/predcor.c
+++ b/codes/apps/water-spatial/predcor.c
@@ -17,9 +17,17 @@
 
 
 #include <pthread.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <sys/time.h>
 #include <unistd.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <malloc.h>
 extern pthread_t PThreadTable[];
 
diff -u -p a/codes/apps/water-spatial/mdmain.c b/codes/apps/water-spatial/mdmain.c
--- a/codes/apps/water-spatial/mdmain.c
+++ b/codes/apps/water-spatial/mdmain.c
@@ -17,9 +17,17 @@
 
 
 #include <pthread.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <sys/time.h>
 #include <unistd.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <malloc.h>
 extern pthread_t PThreadTable[];
 
@@ -36,6 +44,28 @@ extern pthread_t PThreadTable[];
 #include "split.h"
 #include "global.h"
 
+union instance19 {struct input17{double XVIR;double AVGT;double XTT;double POTRF;double POTR;double POTA;double TEN;long i;} input17;};
+void * function20(void *ctx18);
+void *function20(void *ctx18) {
+    {
+        struct input17 *incontext15=&(((union instance19 *)ctx18)->input17);
+        double XVIR=incontext15->XVIR;
+        double AVGT=incontext15->AVGT;
+        double XTT=incontext15->XTT;
+        double POTRF=incontext15->POTRF;
+        double POTR=incontext15->POTR;
+        double POTA=incontext15->POTA;
+        double TEN=incontext15->TEN;
+        long i=incontext15->i;
+        {
+            fprintf(six, "     %5ld %14.5lf %12.5lf %12.5lf %12.5lf \n", i, TEN, POTA, POTR, POTRF);
+            fprintf(six, " %16.3lf %16.5lf %16.5lf\n", XTT, AVGT, XVIR);
+            fflush(six);
+        }
+        return NULL;
+    }
+}
+
 /************************************************************************/
 
 double MDMAIN(long NSTEP, long NPRINT, long NSAVE, long NORD1, long ProcID)
@@ -229,12 +259,21 @@ double MDMAIN(long NSTEP, long NPRINT, l
 
             /* if it is time to print output as well ... */
             if ((i % NPRINT) == 0 && ProcID == 0) {
-                {pthread_mutex_lock(&(gl->IOLock));};
-                fprintf(six,"     %5ld %14.5lf %12.5lf %12.5lf %12.5lf \n"
-                        ,i,TEN,POTA,POTR,POTRF);
-                fprintf(six," %16.3lf %16.5lf %16.5lf\n",XTT,AVGT,XVIR);
-                fflush(six);
-                {pthread_mutex_unlock(&(gl->IOLock));};
+                { union instance19 instance19 = {
+                    {
+                        XVIR,
+                        AVGT,
+                        XTT,
+                        POTRF,
+                        POTR,
+                        POTA,
+                        TEN,
+                        i,
+                    },
+                };
+                
+                liblock_execute_operation(&(gl->IOLock), (void *)(uintptr_t)(&instance19),
+                                          &function20); }
             }
 
         }
@@ -255,6 +294,6 @@ double MDMAIN(long NSTEP, long NPRINT, l
 
     } /* for i */
 
-    return(XTT);
+    return((XTT));
 
 } /* mdmain.c */
diff -u -p a/codes/apps/water-spatial/bndry.c b/codes/apps/water-spatial/bndry.c
--- a/codes/apps/water-spatial/bndry.c
+++ b/codes/apps/water-spatial/bndry.c
@@ -17,9 +17,17 @@
 
 
 #include <pthread.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <sys/time.h>
 #include <unistd.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <malloc.h>
 extern pthread_t PThreadTable[];
 
@@ -31,6 +39,44 @@ extern pthread_t PThreadTable[];
 #include "split.h"
 #include "global.h"
 
+union instance33 {struct input31{struct link *curr_ptr;long Z_INDEX;long Y_INDEX;long X_INDEX;} input31;};
+union instance26 {struct input24{struct link *curr_ptr;struct link *last_ptr;long k;long j;long i;} input24;};
+void * function34(void *ctx32);
+void *function34(void *ctx32) {
+    {
+        struct input31 *incontext29=&(((union instance33 *)ctx32)->input31);
+        struct link *temp_ptr;
+        struct link *curr_ptr=incontext29->curr_ptr;
+        long Z_INDEX=incontext29->Z_INDEX;
+        long Y_INDEX=incontext29->Y_INDEX;
+        long X_INDEX=incontext29->X_INDEX;
+        {
+            temp_ptr = BOX[X_INDEX][Y_INDEX][Z_INDEX].list;
+            BOX[X_INDEX][Y_INDEX][Z_INDEX].list = curr_ptr;
+            curr_ptr->next_mol = temp_ptr;
+        }
+        return NULL;
+    }
+}
+
+void * function27(void *ctx25);
+void *function27(void *ctx25) {
+    {
+        struct input24 *incontext22=&(((union instance26 *)ctx25)->input24);
+        struct link *curr_ptr=incontext22->curr_ptr;
+        struct link *last_ptr=incontext22->last_ptr;
+        long k=incontext22->k;
+        long j=incontext22->j;
+        long i=incontext22->i;
+        {
+            if (last_ptr != NULL)
+                last_ptr->next_mol = curr_ptr->next_mol;else
+                BOX[i][j][k].list = curr_ptr->next_mol;
+        }
+        return NULL;
+    }
+}
+
 void BNDRY(long ProcID)     /* this routine puts the molecules back inside the box if they are out */
 {
     long i, j, k, dir;
@@ -85,20 +131,32 @@ void BNDRY(long ProcID)     /* this rout
 
                 /* Remove link from BOX[i][j][k] */
 
-                {pthread_mutex_lock(&(BOX[i][j][k].boxlock));};
-                if (last_ptr != NULL)
-                    last_ptr->next_mol = curr_ptr->next_mol;
-                else
-                    BOX[i][j][k].list = curr_ptr->next_mol;
-                {pthread_mutex_unlock(&(BOX[i][j][k].boxlock));};
+                { union instance26 instance26 = {
+                    {
+                        curr_ptr,
+                        last_ptr,
+                        k,
+                        j,
+                        i,
+                    },
+                };
+                
+                liblock_execute_operation(&(BOX[i][j][k].boxlock),
+                                          (void *)(uintptr_t)(&instance26), &function27); }
 
                 /* Add link to BOX[X_INDEX][Y_INDEX][Z_INDEX] */
 
-                {pthread_mutex_lock(&(BOX[X_INDEX][Y_INDEX][Z_INDEX].boxlock));};
-                temp_ptr = BOX[X_INDEX][Y_INDEX][Z_INDEX].list;
-                BOX[X_INDEX][Y_INDEX][Z_INDEX].list = curr_ptr;
-                curr_ptr->next_mol = temp_ptr;
-                {pthread_mutex_unlock(&(BOX[X_INDEX][Y_INDEX][Z_INDEX].boxlock));};
+                { union instance33 instance33 = {
+                    {
+                        curr_ptr,
+                        Z_INDEX,
+                        Y_INDEX,
+                        X_INDEX,
+                    },
+                };
+                
+                liblock_execute_operation(&(BOX[X_INDEX][Y_INDEX][Z_INDEX].boxlock),
+                                          (void *)(uintptr_t)(&instance33), &function34); }
 
             }
             else last_ptr = curr_ptr;
diff -u -p a/codes/apps/water-spatial/water.c b/codes/apps/water-spatial/water.c
--- a/codes/apps/water-spatial/water.c
+++ b/codes/apps/water-spatial/water.c
@@ -17,9 +17,17 @@
 
 
 #include <pthread.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <sys/time.h>
 #include <unistd.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <malloc.h>
 /** +EDIT */
 //#define MAX_THREADS 32
@@ -307,7 +315,8 @@ int main(int argc, char **argv)
                 BOX[i][j] = (box_type *) valloc(BOX_PER_SIDE * sizeof(box_type));;
                 for (k=0; k < BOX_PER_SIDE; k++) {
                     BOX[i][j][k].list = NULL;
-                    pthread_mutex_init(&(BOX[i][j][k].boxlock), NULL);;
+                    liblock_lock_init(TYPE_NOINFO, ARG_NOINFO,
+                                      &(BOX[i][j][k].boxlock), NULL);;
                 }
             }
         } /* for i */
@@ -319,12 +328,12 @@ int main(int argc, char **argv)
         {pthread_barrier_init(&(gl->start), NULL, NumProcs);};
         {pthread_barrier_init(&(gl->InterfBar), NULL, NumProcs);};
         {pthread_barrier_init(&(gl->PotengBar), NULL, NumProcs);};
-        pthread_mutex_init(&(gl->IOLock), NULL);;
-        pthread_mutex_init(&(gl->IndexLock), NULL);;
-        pthread_mutex_init(&(gl->IntrafVirLock), NULL);;
-        pthread_mutex_init(&(gl->InterfVirLock), NULL);;
-        pthread_mutex_init(&(gl->KinetiSumLock), NULL);;
-        pthread_mutex_init(&(gl->PotengSumLock), NULL);;
+        liblock_lock_init(TYPE_NOINFO, ARG_NOINFO, &(gl->IOLock), NULL);;
+        liblock_lock_init(TYPE_NOINFO, ARG_NOINFO, &(gl->IndexLock), NULL);;
+        liblock_lock_init(TYPE_NOINFO, ARG_NOINFO, &(gl->IntrafVirLock), NULL);;
+        liblock_lock_init(TYPE_NOINFO, ARG_NOINFO, &(gl->InterfVirLock), NULL);;
+        liblock_lock_init(TYPE_NOINFO, ARG_NOINFO, &(gl->KinetiSumLock), NULL);;
+        liblock_lock_init(TYPE_NOINFO, ARG_NOINFO, &(gl->PotengSumLock), NULL);;
     }
 
     fprintf(six,"SPHERICAL CUTOFF RADIUS    = %8.4f ANGSTROM\n",CUTOFF);
@@ -360,7 +369,7 @@ int main(int argc, char **argv)
 	long	i, Error;
 
 	for (i = 0; i < (NumProcs) - 1; i++) {
-		Error = pthread_create(&PThreadTable[i], NULL, (void * (*)(void *))(WorkStart), NULL);
+		Error = liblock_thread_create(&PThreadTable[i], NULL, (void * (*)(void *))(WorkStart), NULL);
 		if (Error != 0) {
 			printf("Error in pthread_create().\n");
 			exit(-1);
@@ -399,7 +408,18 @@ int main(int argc, char **argv)
     printf("\nExited Happily with XTT = %g (note: XTT value is garbage if NPRINT > NSTEP)\n", XTT);
 
     {exit(0);};
-} /* main.c */
+} void * function41(void *ctx39);
+void *function41(void *ctx39) {
+    {
+        long ProcID;
+        {
+            ProcID = gl->Index++;
+        }
+        return (void *)(uintptr_t)ProcID;
+    }
+}
+
+/* main.c */
 
 void WorkStart() /* routine that each created process starts at;
                     it simply calls the timestep routine */
@@ -407,9 +427,10 @@ void WorkStart() /* routine that each cr
     long ProcID;
     double LocalXTT;
 
-    {pthread_mutex_lock(&(gl->IndexLock));};
-    ProcID = gl->Index++;
-    {pthread_mutex_unlock(&(gl->IndexLock));};
+    {
+    
+    ProcID =(long)(uintptr_t)(liblock_execute_operation(&(gl->IndexLock), (void *)(uintptr_t)(NULL), &function41));
+    }
 
     {;};
     {;};
diff -u -p a/codes/apps/water-spatial/cnstnt.c b/codes/apps/water-spatial/cnstnt.c
--- a/codes/apps/water-spatial/cnstnt.c
+++ b/codes/apps/water-spatial/cnstnt.c
@@ -17,9 +17,17 @@
 
 
 #include <pthread.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <sys/time.h>
 #include <unistd.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <malloc.h>
 extern pthread_t PThreadTable[];
 
diff -u -p a/codes/apps/water-spatial/poteng.c b/codes/apps/water-spatial/poteng.c
--- a/codes/apps/water-spatial/poteng.c
+++ b/codes/apps/water-spatial/poteng.c
@@ -17,9 +17,17 @@
 
 
 #include <pthread.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <sys/time.h>
 #include <unistd.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <malloc.h>
 extern pthread_t PThreadTable[];
 
@@ -34,6 +42,26 @@ extern pthread_t PThreadTable[];
 #include "split.h"
 #include "global.h"
 
+union instance47 {struct input45{double *PTRF;double *POTR;double *POTA;double LPTRF;double LPOTR;double LPOTA;} input45;};
+void * function48(void *ctx46);
+void *function48(void *ctx46) {
+{
+struct input45 *incontext43=&(((union instance47 *)ctx46)->input45);
+double *PTRF=incontext43->PTRF;
+double *POTR=incontext43->POTR;
+double *POTA=incontext43->POTA;
+double LPTRF=incontext43->LPTRF;
+double LPOTR=incontext43->LPOTR;
+double LPOTA=incontext43->LPOTA;
+{
+*POTA = *POTA + LPOTA;
+*POTR = *POTR + LPOTR;
+*PTRF = *PTRF + LPTRF;
+}
+return NULL;
+}
+}
+
 void POTENG(double *POTA, double *POTR, double *PTRF, long ProcID)
 {
 
@@ -259,10 +287,17 @@ void POTENG(double *POTA, double *POTR, 
 
     /* update shared sums from computed private sums */
 
-    {pthread_mutex_lock(&(gl->PotengSumLock));};
-    *POTA = *POTA + LPOTA;
-    *POTR = *POTR + LPOTR;
-    *PTRF = *PTRF + LPTRF;
-    {pthread_mutex_unlock(&(gl->PotengSumLock));};
+    { union instance47 instance47 = {
+    {
+    PTRF,
+    POTR,
+    POTA,
+    LPTRF,
+    LPOTR,
+    LPOTA,
+    },
+    };
+    
+    liblock_execute_operation(&(gl->PotengSumLock), (void *)(uintptr_t)(&instance47), &function48); }
 
 } /* end of subroutine POTENG */
diff -u -p a/codes/apps/water-spatial/kineti.c b/codes/apps/water-spatial/kineti.c
--- a/codes/apps/water-spatial/kineti.c
+++ b/codes/apps/water-spatial/kineti.c
@@ -17,9 +17,17 @@
 
 
 #include <pthread.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <sys/time.h>
 #include <unistd.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <malloc.h>
 extern pthread_t PThreadTable[];
 
@@ -31,6 +39,21 @@ extern pthread_t PThreadTable[];
 #include "split.h"
 #include "global.h"
 
+union instance54 {struct input52{double *SUM;double S;long dir;} input52;};
+void * function55(void *ctx53);
+void *function55(void *ctx53) {
+    {
+        struct input52 *incontext50=&(((union instance54 *)ctx53)->input52);
+        double *SUM=incontext50->SUM;
+        double S=incontext50->S;
+        long dir=incontext50->dir;
+        {
+            SUM[dir] += S;
+        }
+        return NULL;
+    }
+}
+
 /* this routine computes kinetic energy in each of the three spatial
    dimensions, and puts the computed values in the SUM array */
 void KINETI(double *SUM, double HMAS, double OMAS, long ProcID)
@@ -70,9 +93,16 @@ void KINETI(double *SUM, double HMAS, do
 
         } /* while curr_box */
 
-        {pthread_mutex_lock(&(gl->KinetiSumLock));};
-        SUM[dir]+=S;
-        {pthread_mutex_unlock(&(gl->KinetiSumLock));};
+        { union instance54 instance54 = {
+            {
+                SUM,
+                S,
+                dir,
+            },
+        };
+        
+        liblock_execute_operation(&(gl->KinetiSumLock), (void *)(uintptr_t)(&instance54),
+                                  &function55); }
 
     } /* for dir */
 
diff -u -p a/codes/apps/water-spatial/initia.c b/codes/apps/water-spatial/initia.c
--- a/codes/apps/water-spatial/initia.c
+++ b/codes/apps/water-spatial/initia.c
@@ -17,9 +17,17 @@
 
 
 #include <pthread.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <sys/time.h>
 #include <unistd.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <malloc.h>
 extern pthread_t PThreadTable[];
 
diff -u -p a/codes/kernels/cholesky/matrix.h b/codes/kernels/cholesky/matrix.h
--- a/codes/kernels/cholesky/matrix.h
+++ b/codes/kernels/cholesky/matrix.h
@@ -79,8 +79,8 @@ struct GlobalMemory {
 	
 pthread_barrier_t	(start);
 
-	pthread_mutex_t waitLock;
-	pthread_mutex_t memLock;
+	liblock_lock_t waitLock;
+	liblock_lock_t memLock;
 	unsigned long runtime[MAX_PROC];
 	};
 
diff -u -p a/codes/kernels/cholesky/tree.c b/codes/kernels/cholesky/tree.c
--- a/codes/kernels/cholesky/tree.c
+++ b/codes/kernels/cholesky/tree.c
@@ -17,9 +17,17 @@
 
 
 #include <pthread.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <sys/time.h>
 #include <unistd.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <malloc.h>
 extern pthread_t PThreadTable[];
 
diff -u -p a/codes/kernels/cholesky/bfac.c b/codes/kernels/cholesky/bfac.c
--- a/codes/kernels/cholesky/bfac.c
+++ b/codes/kernels/cholesky/bfac.c
@@ -17,9 +17,17 @@
 
 
 #include <pthread.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <sys/time.h>
 #include <unistd.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <malloc.h>
 extern pthread_t PThreadTable[];
 
diff -u -p a/codes/kernels/cholesky/seg.c b/codes/kernels/cholesky/seg.c
--- a/codes/kernels/cholesky/seg.c
+++ b/codes/kernels/cholesky/seg.c
@@ -17,9 +17,17 @@
 
 
 #include <pthread.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <sys/time.h>
 #include <unistd.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <malloc.h>
 extern pthread_t PThreadTable[];
 
diff -u -p a/codes/kernels/cholesky/numLL.c b/codes/kernels/cholesky/numLL.c
--- a/codes/kernels/cholesky/numLL.c
+++ b/codes/kernels/cholesky/numLL.c
@@ -17,9 +17,17 @@
 
 
 #include <pthread.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <sys/time.h>
 #include <unistd.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <malloc.h>
 extern pthread_t PThreadTable[];
 
diff -u -p a/codes/kernels/cholesky/block2.c b/codes/kernels/cholesky/block2.c
--- a/codes/kernels/cholesky/block2.c
+++ b/codes/kernels/cholesky/block2.c
@@ -17,9 +17,17 @@
 
 
 #include <pthread.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <sys/time.h>
 #include <unistd.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <malloc.h>
 extern pthread_t PThreadTable[];
 
diff -u -p a/codes/kernels/cholesky/parts.c b/codes/kernels/cholesky/parts.c
--- a/codes/kernels/cholesky/parts.c
+++ b/codes/kernels/cholesky/parts.c
@@ -17,9 +17,17 @@
 
 
 #include <pthread.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <sys/time.h>
 #include <unistd.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <malloc.h>
 extern pthread_t PThreadTable[];
 
diff -u -p a/codes/kernels/cholesky/util.c b/codes/kernels/cholesky/util.c
--- a/codes/kernels/cholesky/util.c
+++ b/codes/kernels/cholesky/util.c
@@ -17,9 +17,17 @@
 
 
 #include <pthread.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <sys/time.h>
 #include <unistd.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <malloc.h>
 extern pthread_t PThreadTable[];
 
diff -u -p a/codes/kernels/cholesky/malloc.c b/codes/kernels/cholesky/malloc.c
--- a/codes/kernels/cholesky/malloc.c
+++ b/codes/kernels/cholesky/malloc.c
@@ -20,9 +20,17 @@
 
 
 #include <pthread.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <sys/time.h>
 #include <unistd.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <malloc.h>
 extern pthread_t PThreadTable[];
 
@@ -38,7 +46,7 @@ extern pthread_t PThreadTable[];
 #define NEXTFREE(block) (*((long **) block)) /* in free blocks */
 
 struct MemPool {
-	pthread_mutex_t memoryLock;
+	liblock_lock_t memoryLock;
 	long *volatile*freeBlock;
 	long tally, touched, maxm;
 	} *mem_pool;
@@ -68,7 +76,7 @@ void InitOneFreeList(long p)
 {
   long j;
 
-  pthread_mutex_init(&(mem_pool[p].memoryLock), NULL);;
+  liblock_lock_init(TYPE_NOINFO, ARG_NOINFO, &(mem_pool[p].memoryLock), NULL);;
   if (p > 0) {
     mem_pool[p].freeBlock = (long **)
       valloc((MAXFAST+1)*sizeof(long *));;
@@ -115,10 +123,89 @@ long FindBucket(long size)
       bucket++;
   }
 
-  return(bucket);
+  return((bucket));
 }
 
 
+union instance19 {struct input17{long home;long block_size;} input17;};
+union instance12 {struct input10{long *result;long alloc_size;long home;} input10;};
+union instance5 {struct input3{long bucket;long home;} input3;};
+void * function20(void *ctx18);
+void *function20(void *ctx18) {
+  {
+    struct input17 *incontext15=&(((union instance19 *)ctx18)->input17);
+    long *freespace;
+    long home=incontext15->home;
+    long block_size=incontext15->block_size;
+    {
+      freespace = (long *)valloc(block_size + 2 * sizeof(long));
+      ;
+      MigrateMem(freespace, block_size + 2 * sizeof(long), home);
+      mem_pool[home].touched++;
+    }
+    return (void *)(uintptr_t)freespace;
+  }
+}
+
+void * function13(void *ctx11);
+void *function13(void *ctx11) {
+  {
+    struct input10 *incontext8=&(((union instance12 *)ctx11)->input10);
+    long *d;
+    long *prev;
+    long leftover;
+    long block_size;
+    long *result=incontext8->result;
+    long alloc_size=incontext8->alloc_size;
+    long home=incontext8->home;
+    result = result;
+    {
+      prev = NULL;
+      d = mem_pool[home].freeBlock[MAXFAST];
+      while (d) {
+        block_size = SIZE(d);
+        if (block_size >= alloc_size) {
+          leftover = block_size - alloc_size - 2 * sizeof(long);
+          result = d + (leftover / sizeof(long)) + 2;
+          SIZE(result) = alloc_size;
+          HOME(result) = home;
+          if (leftover > MAXFASTBL) {
+            SIZE(d) = leftover;
+          }else {
+            if (prev)
+              NEXTFREE(prev) = NEXTFREE(d);else
+              mem_pool[home].freeBlock[MAXFAST] = NEXTFREE(d);
+            if (leftover > 0) {
+              SIZE(d) = leftover;
+              MyFreeNow(d);
+            }
+          }
+          break;
+        }
+        prev = d;
+        d = NEXTFREE(d);
+      }
+    }
+    return (void *)(uintptr_t)result;
+  }
+}
+
+void * function6(void *ctx4);
+void *function6(void *ctx4) {
+  {
+    struct input3 *incontext1=&(((union instance5 *)ctx4)->input3);
+    long *result;
+    long bucket=incontext1->bucket;
+    long home=incontext1->home;
+    {
+      result = mem_pool[home].freeBlock[bucket];
+      if (result)
+        mem_pool[home].freeBlock[bucket] = NEXTFREE(result);
+    }
+    return (void *)(uintptr_t)result;
+  }
+}
+
 /* size is in bytes */
 
 char *MyMalloc(long size, long home)
@@ -143,55 +230,32 @@ char *MyMalloc(long size, long home)
 
   if (bucket < MAXFAST) {
     if (mem_pool[home].freeBlock[bucket]) {
-      {pthread_mutex_lock(&(mem_pool[home].memoryLock));}
-      result = mem_pool[home].freeBlock[bucket];
-      if (result)
-	mem_pool[home].freeBlock[bucket] = NEXTFREE(result);
-      {pthread_mutex_unlock(&(mem_pool[home].memoryLock));}
+      { union instance5 instance5 = {
+        {
+          bucket,
+          home,
+        },
+      };
+      
+      result =(long *)(uintptr_t)(liblock_execute_operation(&(mem_pool[home].memoryLock), (void *)(uintptr_t)(&instance5),
+                                &function6));
+      }
     }
   }
 
   if (!result) {
-    {pthread_mutex_lock(&(mem_pool[home].memoryLock));}
-    prev = NULL;
-    d = mem_pool[home].freeBlock[MAXFAST];
-    while (d) {
-
-      block_size = SIZE(d);
-
-      if (block_size >= alloc_size) {  /* Found one! */
-
-	leftover = block_size - alloc_size - 2*sizeof(long);
-        result = d + (leftover/sizeof(long)) + 2;
-	SIZE(result) = alloc_size;
-	HOME(result) = home;
-
-	if (leftover > MAXFASTBL) {
-	  SIZE(d) = leftover;
-	}
-	else {
-	  /* don't leave a block */
-
-	  /* unlink 'd' */
-	  if (prev)
-	    NEXTFREE(prev) = NEXTFREE(d);
-	  else
-	    mem_pool[home].freeBlock[MAXFAST] = NEXTFREE(d);
-
-	  if (leftover > 0) {
-	    SIZE(d) = leftover;
-	    MyFreeNow(d);
-	  }
-	}
-        break;
-      }
-
-      prev = d;
-      d = NEXTFREE(d);
+    { union instance12 instance12 = {
+      {
+        result,
+        alloc_size,
+        home,
+      },
+    };
+    
+    result =(long *)(uintptr_t)(liblock_execute_operation(&(mem_pool[home].memoryLock), (void *)(uintptr_t)(&instance12),
+                              &function13));
     }
 
-    {pthread_mutex_unlock(&(mem_pool[home].memoryLock));}
-
   }
 
   if (result) {
@@ -200,12 +264,15 @@ char *MyMalloc(long size, long home)
   else {
     /* grab a big block, free it, then retry request */
     block_size = max(alloc_size, 4*(1<<MAXFAST));
-    {pthread_mutex_lock(&(Global->memLock));};
-    freespace = (long *) valloc(block_size+2*sizeof(long));;
-    MigrateMem(freespace, block_size+2*sizeof(long), home);
-
-    mem_pool[home].touched++;
-    {pthread_mutex_unlock(&(Global->memLock));};
+    { union instance19 instance19 = {
+      {
+        home,
+        block_size,
+      },
+    };
+    
+    freespace =(long *)(uintptr_t)(liblock_execute_operation(&(Global->memLock), (void *)(uintptr_t)(&instance19), &function20));
+    }
     freespace+=2;
     SIZE(freespace) = block_size;
     HOME(freespace) = home;
@@ -231,7 +298,7 @@ char *MyMalloc(long size, long home)
   if (SIZE(result) < size)
     printf("*** Bad size from malloc %ld, %ld\n", size, SIZE(result));
 
-  return((char *) result);
+  return(((char *) result));
 
 }
 
@@ -270,14 +337,26 @@ void MigrateMem(long *start, long length
 }
     
 
+void * function27(void *ctx25);
+void *function27(void *ctx25) {
+  {
+    long *block=(long *)(uintptr_t)ctx25;
+    {
+      MyFreeNow(block);
+    }
+    return NULL;
+  }
+}
+
 void MyFree(long *block)
 {
   long home;
 
   home = HOME(block);
-  {pthread_mutex_lock(&(mem_pool[home].memoryLock));}
-  MyFreeNow(block);
-  {pthread_mutex_unlock(&(mem_pool[home].memoryLock));}
+  {
+  
+  liblock_execute_operation(&(mem_pool[home].memoryLock), (void *)(uintptr_t)(block),
+                            &function27); }
 }
 
 
@@ -306,8 +385,10 @@ void MyFreeNow(long *block)
   }
 
   /* throw away tiny blocks */
-  if (bucket == 0)
-    return;
+  if (bucket == 0) {
+    
+      return;
+    }
 
   NEXTFREE(block) = (long *) mem_pool[home].freeBlock[bucket];
   mem_pool[home].freeBlock[bucket] = block;
diff -u -p a/codes/kernels/cholesky/fo.c b/codes/kernels/cholesky/fo.c
--- a/codes/kernels/cholesky/fo.c
+++ b/codes/kernels/cholesky/fo.c
@@ -17,9 +17,17 @@
 
 
 #include <pthread.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <sys/time.h>
 #include <unistd.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <malloc.h>
 extern pthread_t PThreadTable[];
 
diff -u -p a/codes/kernels/cholesky/assign.c b/codes/kernels/cholesky/assign.c
--- a/codes/kernels/cholesky/assign.c
+++ b/codes/kernels/cholesky/assign.c
@@ -17,9 +17,17 @@
 
 
 #include <pthread.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <sys/time.h>
 #include <unistd.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <malloc.h>
 extern pthread_t PThreadTable[];
 
diff -u -p a/codes/kernels/cholesky/bksolve.c b/codes/kernels/cholesky/bksolve.c
--- a/codes/kernels/cholesky/bksolve.c
+++ b/codes/kernels/cholesky/bksolve.c
@@ -17,9 +17,17 @@
 
 
 #include <pthread.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <sys/time.h>
 #include <unistd.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <malloc.h>
 extern pthread_t PThreadTable[];
 
diff -u -p a/codes/kernels/cholesky/solve.c b/codes/kernels/cholesky/solve.c
--- a/codes/kernels/cholesky/solve.c
+++ b/codes/kernels/cholesky/solve.c
@@ -34,9 +34,17 @@
 
 
 #include <pthread.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <sys/time.h>
 #include <unistd.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <malloc.h>
 /** +EDIT */
 //#define MAX_THREADS 32
@@ -147,8 +155,8 @@ int main(int argc, char *argv[])
   Global = (struct GlobalMemory *)
     valloc(sizeof(struct GlobalMemory));;
   {pthread_barrier_init(&(Global->start), NULL, P);}
-  pthread_mutex_init(&(Global->waitLock), NULL);
-  pthread_mutex_init(&(Global->memLock), NULL);
+  liblock_lock_init(TYPE_NOINFO, ARG_NOINFO, &(Global->waitLock), NULL);
+  liblock_lock_init(TYPE_NOINFO, ARG_NOINFO, &(Global->memLock), NULL);
 
   MallocInit(P);  
 
@@ -272,7 +280,7 @@ int main(int argc, char *argv[])
 	long	i, Error;
 
 	for (i = 0; i < (P) - 1; i++) {
-		Error = pthread_create(&PThreadTable[i], NULL, (void * (*)(void *))(Go), NULL);
+		Error = liblock_thread_create(&PThreadTable[i], NULL, (void * (*)(void *))(Go), NULL);
 		if (Error != 0) {
 			printf("Error in pthread_create().\n");
 			exit(-1);
@@ -348,15 +356,27 @@ int main(int argc, char *argv[])
 }
 
 
+void * function34(void *ctx32);
+void *function34(void *ctx32) {
+  {
+    long MyNum;
+    {
+      MyNum = gp->pid;
+      gp->pid++;
+    }
+    return (void *)(uintptr_t)MyNum;
+  }
+}
+
 void Go()
 {
   long MyNum;
   struct LocalCopies *lc;
 
-  {pthread_mutex_lock(&(Global->waitLock));}
-    MyNum = gp->pid;
-    gp->pid++;
-  {pthread_mutex_unlock(&(Global->waitLock));}
+  {
+  
+  MyNum =(long)(uintptr_t)(liblock_execute_operation(&(Global->waitLock), (void *)(uintptr_t)(NULL), &function34));
+  }
 
   {;};
 /* POSSIBLE ENHANCEMENT:  Here is where one might pin processes to
diff -u -p a/codes/kernels/cholesky/amal.c b/codes/kernels/cholesky/amal.c
--- a/codes/kernels/cholesky/amal.c
+++ b/codes/kernels/cholesky/amal.c
@@ -17,9 +17,17 @@
 
 
 #include <pthread.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <sys/time.h>
 #include <unistd.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <malloc.h>
 extern pthread_t PThreadTable[];
 
diff -u -p a/codes/kernels/cholesky/mf.c b/codes/kernels/cholesky/mf.c
--- a/codes/kernels/cholesky/mf.c
+++ b/codes/kernels/cholesky/mf.c
@@ -17,9 +17,17 @@
 
 
 #include <pthread.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <sys/time.h>
 #include <unistd.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <malloc.h>
 extern pthread_t PThreadTable[];
 
@@ -33,7 +41,7 @@ extern struct GlobalMemory *Global;
 struct Update **updateHash;
 
 struct taskQ {
-	pthread_mutex_t taskLock;
+	liblock_lock_t taskLock;
 	struct Task *volatile taskQ; 
 	struct Task *volatile taskQlast;
 	struct Task *volatile probeQ; 
@@ -48,7 +56,7 @@ void InitTaskQueues(long P)
 
   tasks = (struct taskQ *) MyMalloc(P*sizeof(struct taskQ), DISTRIBUTED);
   for (i=0; i<P; i++) {
-    pthread_mutex_init(&(tasks[i].taskLock), NULL);
+    liblock_lock_init(TYPE_NOINFO, ARG_NOINFO, &(tasks[i].taskLock), NULL);
 
     tasks[i].taskQ = (struct Task *) NULL;
     tasks[i].taskQlast = (struct Task *) NULL;
@@ -77,13 +85,42 @@ long FindBlock(long i, long j)
       lo = probe+1;
   }
 
-  if (LB.row[probe] == i)
-    return(probe);
+  if (LB.row[probe] == i) {
+    
+      return((probe));
+    }
   else
-    return(-1);
+    {
+      return((-1));
+    }
 }
 
 
+union instance40 {struct input38{struct Task *t;long procnum;long is_probe;} input38;};
+void * function41(void *ctx39);
+void *function41(void *ctx39) {
+  {
+    struct input38 *incontext36=&(((union instance40 *)ctx39)->input38);
+    struct Task *t=incontext36->t;
+    long procnum=incontext36->procnum;
+    long is_probe=incontext36->is_probe;
+    {
+      if (is_probe) {
+        if (tasks[procnum].probeQlast)
+          tasks[procnum].probeQlast->next = t;else
+          tasks[procnum].probeQ = t;
+        tasks[procnum].probeQlast = t;
+      }else {
+        if (tasks[procnum].taskQlast)
+          tasks[procnum].taskQlast->next = t;else
+          tasks[procnum].taskQ = t;
+        tasks[procnum].taskQlast = t;
+      }
+    }
+    return NULL;
+  }
+}
+
 /* p is processor no if block_num = -1, ignored otherwise */
 
 void Send(long src_block, long dest_block, long desti, long destj, struct Update *update, long p, long MyNum, struct LocalCopies *lc)
@@ -107,33 +144,49 @@ void Send(long src_block, long dest_bloc
   t->desti = desti; t->destj = destj; t->src = src_block; t->update = update;
   t->next = NULL;
 
-  {pthread_mutex_lock(&(tasks[procnum].taskLock));}
-
-  if (is_probe) {
-    if (tasks[procnum].probeQlast)
-      tasks[procnum].probeQlast->next = t;
-    else
-      tasks[procnum].probeQ = t;
-    tasks[procnum].probeQlast = t;
-  }
-  else {
-    if (tasks[procnum].taskQlast)
-      tasks[procnum].taskQlast->next = t;
-    else
-      tasks[procnum].taskQ = t;
-    tasks[procnum].taskQlast = t;
-  }
-
-  {pthread_mutex_unlock(&(tasks[procnum].taskLock));}
+  { union instance40 instance40 = {
+    {
+      t,
+      procnum,
+      is_probe,
+    },
+  };
+  
+  liblock_execute_operation(&(tasks[procnum].taskLock), (void *)(uintptr_t)(&instance40),
+                            &function41); }
 }
 
 
 long TaskWaiting(long MyNum)
 {
-  return(tasks[MyNum].taskQ != NULL);
+  return((tasks[MyNum].taskQ != NULL));
 }
 
 
+void * function48(void *ctx46);
+void *function48(void *ctx46) {
+  {
+    struct Task *t;
+    long MyNum=(long)(uintptr_t)ctx46;
+    {
+      t = NULL;
+      if (tasks[MyNum].probeQ) {
+        t = (struct Task *)tasks[MyNum].probeQ;
+        tasks[MyNum].probeQ = t->next;
+        if (!t->next)
+          tasks[MyNum].probeQlast = NULL;
+      }else
+        if (tasks[MyNum].taskQ) {
+          t = (struct Task *)tasks[MyNum].taskQ;
+          tasks[MyNum].taskQ = t->next;
+          if (!t->next)
+            tasks[MyNum].taskQlast = NULL;
+        }
+    }
+    return (void *)(uintptr_t)t;
+  }
+}
+
 void GetBlock(long *desti, long *destj, long *src, struct Update **update, long MyNum, struct LocalCopies *lc)
 {
   struct Task *t;
@@ -141,21 +194,11 @@ void GetBlock(long *desti, long *destj, 
   for (;;) {
 
     if (tasks[MyNum].taskQ || tasks[MyNum].probeQ) {
-      {pthread_mutex_lock(&(tasks[MyNum].taskLock));}
-      t = NULL;
-      if (tasks[MyNum].probeQ) {
-        t = (struct Task *) tasks[MyNum].probeQ;
-        tasks[MyNum].probeQ = t->next;
-	if (!t->next)
-	  tasks[MyNum].probeQlast = NULL;
-      }
-      else if (tasks[MyNum].taskQ) {
-        t = (struct Task *) tasks[MyNum].taskQ;
-        tasks[MyNum].taskQ = t->next;
-	if (!t->next)
-	  tasks[MyNum].taskQlast = NULL;
+      {
+      
+      t =(struct Task *)(uintptr_t)(liblock_execute_operation(&(tasks[MyNum].taskLock), (void *)(uintptr_t)(MyNum),
+                                &function48));
       }
-      {pthread_mutex_unlock(&(tasks[MyNum].taskLock));}
       if (t)
         break;
     }
diff -u -p a/codes/kernels/fft/fft.c b/codes/kernels/fft/fft.c
--- a/codes/kernels/fft/fft.c
+++ b/codes/kernels/fft/fft.c
@@ -55,9 +55,17 @@
 
 
 #include <pthread.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <sys/time.h>
 #include <unistd.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <malloc.h>
 /** +EDIT */
 //#define MAX_THREADS 32
@@ -70,7 +78,7 @@ pthread_t PThreadTable[MAX_THREADS];
 
 struct GlobalMemory {
   long id;
-  pthread_mutex_t idlock;
+  liblock_lock_t idlock;
   
 pthread_barrier_t	(start);
 
@@ -321,7 +329,7 @@ int main(int argc, char *argv[])
   printf("\n");
 
   {pthread_barrier_init(&(Global->start), NULL, P);};
-  pthread_mutex_init(&(Global->idlock), NULL);;
+  liblock_lock_init(TYPE_NOINFO, ARG_NOINFO, &(Global->idlock), NULL);;
   Global->id = 0;
   InitX(x);                  /* place random values in x */
 
@@ -342,7 +350,7 @@ int main(int argc, char *argv[])
 	long	i, Error;
 
 	for (i = 0; i < (P) - 1; i++) {
-		Error = pthread_create(&PThreadTable[i], NULL, (void * (*)(void *))(SlaveStart), NULL);
+		Error = liblock_thread_create(&PThreadTable[i], NULL, (void * (*)(void *))(SlaveStart), NULL);
 		if (Error != 0) {
 			printf("Error in pthread_create().\n");
 			exit(-1);
@@ -456,6 +464,18 @@ int main(int argc, char *argv[])
 }
 
 
+void * function6(void *ctx4);
+void *function6(void *ctx4) {
+  {
+    long MyNum;
+    {
+      MyNum = Global->id;
+      Global->id++;
+    }
+    return (void *)(uintptr_t)MyNum;
+  }
+}
+
 void SlaveStart()
 {
   long i;
@@ -467,10 +487,10 @@ void SlaveStart()
   long MyFirst; 
   long MyLast;
 
-  {pthread_mutex_lock(&(Global->idlock));};
-    MyNum = Global->id;
-    Global->id++;
-  {pthread_mutex_unlock(&(Global->idlock));}; 
+  {
+  
+  MyNum =(long)(uintptr_t)(liblock_execute_operation(&(Global->idlock), (void *)(uintptr_t)(NULL), &function6));
+  }
 
   {;};
 
@@ -555,7 +575,7 @@ double TouchArray(double *x, double *scr
 	     u[2*(k+i)] + u[2*(k+i)+1];
     }
   }  
-  return tot;
+  return( tot);
 }
 
 
@@ -572,7 +592,7 @@ double CheckSum(double *x)
     }
   }
 
-  return(cks);
+  return((cks));
 }
 
 
@@ -638,7 +658,7 @@ long BitReverse(long M, long k)
     j = 2*j + (tmp&0x1);
     tmp = tmp>>1;
   }
-  return(j);
+  return((j));
 }
 
 
@@ -985,9 +1005,9 @@ long log_2(long number)
   }
 
   if (cumulative == number) {
-    return(out);
+    return((out));
   } else {
-    return(-1);
+    return((-1));
   }
 }
 
diff -u -p a/codes/kernels/lu/contiguous_blocks/lu.c b/codes/kernels/lu/contiguous_blocks/lu.c
--- a/codes/kernels/lu/contiguous_blocks/lu.c
+++ b/codes/kernels/lu/contiguous_blocks/lu.c
@@ -43,11 +43,23 @@
 #include <stdio.h>
 #include <math.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 
 #include <pthread.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <sys/time.h>
 #include <unistd.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <malloc.h>
 /** +EDIT */
 //#define MAX_THREADS 32
@@ -78,7 +90,7 @@ struct GlobalMemory {
   
 pthread_barrier_t	(start);
 
-  pthread_mutex_t idlock;
+  liblock_lock_t idlock;
 } *Global;
 
 struct LocalCopies {
@@ -312,7 +324,7 @@ int main(int argc, char *argv[])
 */
 
   {pthread_barrier_init(&(Global->start), NULL, P);};
-  pthread_mutex_init(&(Global->idlock), NULL);;
+  liblock_lock_init(TYPE_NOINFO, ARG_NOINFO, &(Global->idlock), NULL);;
   Global->id = 0;
 
   InitA(rhs);
@@ -325,7 +337,7 @@ int main(int argc, char *argv[])
 	long	i, Error;
 
 	for (i = 0; i < (P) - 1; i++) {
-		Error = pthread_create(&PThreadTable[i], NULL, (void * (*)(void *))(SlaveStart), NULL);
+		Error = liblock_thread_create(&PThreadTable[i], NULL, (void * (*)(void *))(SlaveStart), NULL);
 		if (Error != 0) {
 			printf("Error in pthread_create().\n");
 			exit(-1);
@@ -443,14 +455,26 @@ int main(int argc, char *argv[])
 }
 
 
+void * function6(void *ctx4);
+void *function6(void *ctx4) {
+  {
+    long MyNum;
+    {
+      MyNum = Global->id;
+      Global->id++;
+    }
+    return (void *)(uintptr_t)MyNum;
+  }
+}
+
 void SlaveStart()
 {
   long MyNum;
 
-  {pthread_mutex_lock(&(Global->idlock));}
-    MyNum = Global->id;
-    Global->id ++;
-  {pthread_mutex_unlock(&(Global->idlock));}
+  {
+  
+  MyNum =(long)(uintptr_t)(liblock_execute_operation(&(Global->idlock), (void *)(uintptr_t)(NULL), &function6));
+  }
 
 /* POSSIBLE ENHANCEMENT:  Here is where one might pin processes to
    processors to avoid migration */
@@ -617,17 +641,17 @@ void daxpy(double *a, double *b, long n,
 long BlockOwner(long I, long J)
 {
 //	return((J%num_cols) + (I%num_rows)*num_cols); 
-	return((I + J) % P);
+	return(((I + J) % P));
 }
 
 long BlockOwnerColumn(long I, long J)
 {
-	return(I % P);
+	return((I % P));
 }
 
 long BlockOwnerRow(long I, long J)
 {
-	return(((J % P) + (P / 2)) % P);
+	return((((J % P) + (P / 2)) % P));
 }
 
 void lu(long n, long bs, long MyNum, struct LocalCopies *lc, long dostats)
@@ -876,7 +900,7 @@ double TouchA(long bs, long MyNum)
       }
     }
   } 
-  return(tot);
+  return((tot));
 }
 
 
diff -u -p a/codes/kernels/lu/non_contiguous_blocks/lu.c b/codes/kernels/lu/non_contiguous_blocks/lu.c
--- a/codes/kernels/lu/non_contiguous_blocks/lu.c
+++ b/codes/kernels/lu/non_contiguous_blocks/lu.c
@@ -40,11 +40,23 @@
 #include <stdio.h>
 #include <math.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 
 #include <pthread.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <sys/time.h>
 #include <unistd.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <malloc.h>
 /** +EDIT */
 //#define MAX_THREADS 32
@@ -74,7 +86,7 @@ struct GlobalMemory {
   
 pthread_barrier_t	(start);
 
-  pthread_mutex_t idlock;
+  liblock_lock_t idlock;
 } *Global;
 
 struct LocalCopies {
@@ -222,7 +234,7 @@ int main(int argc, char *argv[])
    round-robin fashion as desired. */
 
   {pthread_barrier_init(&(Global->start), NULL, P);};
-  pthread_mutex_init(&(Global->idlock), NULL);;
+  liblock_lock_init(TYPE_NOINFO, ARG_NOINFO, &(Global->idlock), NULL);;
   Global->id = 0;
 
   InitA(rhs);
@@ -235,7 +247,7 @@ int main(int argc, char *argv[])
 	long	i, Error;
 
 	for (i = 0; i < (P) - 1; i++) {
-		Error = pthread_create(&PThreadTable[i], NULL, (void * (*)(void *))(SlaveStart), NULL);
+		Error = liblock_thread_create(&PThreadTable[i], NULL, (void * (*)(void *))(SlaveStart), NULL);
 		if (Error != 0) {
 			printf("Error in pthread_create().\n");
 			exit(-1);
@@ -352,14 +364,26 @@ int main(int argc, char *argv[])
   {exit(0);};
 }
 
+void * function13(void *ctx11);
+void *function13(void *ctx11) {
+  {
+    long MyNum;
+    {
+      MyNum = Global->id;
+      Global->id++;
+    }
+    return (void *)(uintptr_t)MyNum;
+  }
+}
+
 void SlaveStart()
 {
   long MyNum;
 
-  {pthread_mutex_lock(&(Global->idlock));}
-    MyNum = Global->id;
-    Global->id ++;
-  {pthread_mutex_unlock(&(Global->idlock));}
+  {
+  
+  MyNum =(long)(uintptr_t)(liblock_execute_operation(&(Global->idlock), (void *)(uintptr_t)(NULL), &function13));
+  }
 
 /* POSSIBLE ENHANCEMENT:  Here is where one might pin processes to
    processors to avoid migration */
@@ -517,17 +541,17 @@ void daxpy(double *a, double *b, long n,
 long BlockOwner(long I, long J)
 {
 //	return((I%num_cols) + (J%num_rows)*num_cols);
-	return((I + J) % P);
+	return(((I + J) % P));
 }
 
 long BlockOwnerColumn(long I, long J)
 {
-	return(I % P);
+	return((I % P));
 }
 
 long BlockOwnerRow(long I, long J)
 {
-	return(((J % P) + (P / 2)) % P);
+	return((((J % P) + (P / 2)) % P));
 }
 
 void lu(long n, long bs, long MyNum, struct LocalCopies *lc, long dostats)
@@ -706,7 +730,7 @@ double TouchA(long bs, long MyNum)
       }
     }
   }
-  return(tot);
+  return((tot));
 }
 
 
diff -u -p a/codes/kernels/radix/radix.c b/codes/kernels/radix/radix.c
--- a/codes/kernels/radix/radix.c
+++ b/codes/kernels/radix/radix.c
@@ -56,9 +56,17 @@
 
 
 #include <pthread.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <sys/time.h>
 #include <unistd.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-splash2.h>
+//;
+#include <stdint.h>
 #include <malloc.h>
 /** +EDIT */
 //#define MAX_THREADS 32
@@ -72,7 +80,7 @@ struct prefix_node {
    long ranks[MAX_RADIX];
    
 struct {
-	pthread_mutex_t	Mutex;
+	liblock_lock_t	Mutex;
 	pthread_cond_t	CondVar;
 	unsigned long	Flag;
 } done;
@@ -82,8 +90,8 @@ struct {
 
 struct global_memory {
    long Index;                             /* process ID */
-   pthread_mutex_t lock_Index;                    /* for fetch and add to get ID */
-   pthread_mutex_t rank_lock;                     /* for fetch and add to get ID */
+   liblock_lock_t lock_Index;                    /* for fetch and add to get ID */
+   liblock_lock_t rank_lock;                     /* for fetch and add to get ID */
 /*   pthread_mutex_t section_lock[MAX_PROCESSORS];*/  /* key locks */
    
 pthread_barrier_t	(barrier_rank);
@@ -252,8 +260,8 @@ int main(int argc, char *argv[])
    for (i=0;i<number_of_processors;i++) {
      gp[i].rank_ff = (long *) valloc(radix*sizeof(long)+PAGE_SIZE);;
    }
-   pthread_mutex_init(&(global->lock_Index), NULL);
-   pthread_mutex_init(&(global->rank_lock), NULL);
+   liblock_lock_init(TYPE_NOINFO, ARG_NOINFO, &(global->lock_Index), NULL);
+   liblock_lock_init(TYPE_NOINFO, ARG_NOINFO, &(global->rank_lock), NULL);
 /*   
 {
 	unsigned long	i, Error;
@@ -272,7 +280,8 @@ int main(int argc, char *argv[])
    
    for (i=0; i<2*number_of_processors; i++) {
      {
-	pthread_mutex_init(&global->prefix_tree[i].done.Mutex, NULL);
+	liblock_lock_init(TYPE_NOINFO, ARG_NOINFO,
+                          &global->prefix_tree[i].done.Mutex, NULL);
 	pthread_cond_init(&global->prefix_tree[i].done.CondVar, NULL);
 	global->prefix_tree[i].done.Flag = 0;
 }
@@ -359,7 +368,7 @@ int main(int argc, char *argv[])
 	long	i, Error;
 
 	for (i = 0; i < (number_of_processors) - 1; i++) {
-		Error = pthread_create(&PThreadTable[i], NULL, (void * (*)(void *))(slave_sort), NULL);
+		Error = liblock_thread_create(&PThreadTable[i], NULL, (void * (*)(void *))(slave_sort), NULL);
 		if (Error != 0) {
 			printf("Error in pthread_create().\n");
 			exit(-1);
@@ -452,6 +461,97 @@ int main(int argc, char *argv[])
    {exit(0);};
 }
 
+union instance40 {struct input38{long offset;long base;} input38;};
+union instance26 {struct input24{long offset;long base;} input24;};
+union instance12 {struct input10{long offset;long base;} input10;};
+void * function41(void *ctx39);
+void *function41(void *ctx39) {
+   {
+      struct input38 *incontext36=&(((union instance40 *)ctx39)->input38);
+      long offset=incontext36->offset;
+      long base=incontext36->base;
+      {
+         global->prefix_tree[base + offset - 1].done.Flag = 1;
+         pthread_cond_broadcast(&global->prefix_tree[base + offset - 1].done.CondVar);
+      }
+      return NULL;
+   }
+}
+
+void * function34(void *ctx32);
+void *function34(void *ctx32) {
+   {
+      struct prefix_node *my_node=(struct prefix_node *)(uintptr_t)ctx32;
+      {
+         if (my_node->done.Flag == 0) {
+            liblock_cond_wait(&my_node->done.CondVar, &my_node->done.Mutex);
+         }
+      }
+      ;
+      {
+         my_node->done.Flag = 0;
+      }
+      return NULL;
+   }
+}
+
+void * function27(void *ctx25);
+void *function27(void *ctx25) {
+   {
+      struct input24 *incontext22=&(((union instance26 *)ctx25)->input24);
+      long offset=incontext22->offset;
+      long base=incontext22->base;
+      {
+         global->prefix_tree[base + (offset >> 1)].done.Flag = 1;
+         pthread_cond_broadcast(&global->prefix_tree[base + (offset >> 1)].done.CondVar);
+      }
+      return NULL;
+   }
+}
+
+void * function20(void *ctx18);
+void *function20(void *ctx18) {
+   {
+      struct prefix_node *n=(struct prefix_node *)(uintptr_t)ctx18;
+      {
+         if (n->done.Flag == 0) {
+            liblock_cond_wait(&n->done.CondVar, &n->done.Mutex);
+         }
+      }
+      ;
+      {
+         n->done.Flag = 0;
+      }
+      return NULL;
+   }
+}
+
+void * function13(void *ctx11);
+void *function13(void *ctx11) {
+   {
+      struct input10 *incontext8=&(((union instance12 *)ctx11)->input10);
+      long offset=incontext8->offset;
+      long base=incontext8->base;
+      {
+         global->prefix_tree[base + (offset >> 1)].done.Flag = 1;
+         pthread_cond_broadcast(&global->prefix_tree[base + (offset >> 1)].done.CondVar);
+      }
+      return NULL;
+   }
+}
+
+void * function6(void *ctx4);
+void *function6(void *ctx4) {
+   {
+      long MyNum;
+      {
+         MyNum = global->Index;
+         global->Index++;
+      }
+      return (void *)(uintptr_t)MyNum;
+   }
+}
+
 void slave_sort()
 {
    long i;
@@ -494,10 +594,10 @@ void slave_sort()
 
    stats = dostats;
 
-   {pthread_mutex_lock(&(global->lock_Index));}
-     MyNum = global->Index;
-     global->Index++;
-   {pthread_mutex_unlock(&(global->lock_Index));}
+   {
+   
+   MyNum =(long)(uintptr_t)(liblock_execute_operation(&(global->lock_Index), (void *)(uintptr_t)(NULL), &function6));
+   }
 
    {;};
    {;};
@@ -587,10 +687,15 @@ void slave_sort()
      base = number_of_processors;
      if ((MyNum & 0x1) == 0) {
         {
-	pthread_mutex_lock(&global->prefix_tree[base + (offset >> 1)].done.Mutex);
-	global->prefix_tree[base + (offset >> 1)].done.Flag = 1;
-	pthread_cond_broadcast(&global->prefix_tree[base + (offset >> 1)].done.CondVar);
-	pthread_mutex_unlock(&global->prefix_tree[base + (offset >> 1)].done.Mutex);}
+	{ union instance12 instance12 = {
+	   {
+   	   offset,
+      	base,
+   	},
+	};
+	
+	liblock_execute_operation(&global->prefix_tree[base + (offset >> 1)].done.Mutex,
+                                  (void *)(uintptr_t)(&instance12), &function13); }}
 ;
      }
      while ((offset & 0x1) != 0) {
@@ -600,14 +705,9 @@ void slave_sort()
        index = base + offset;
        n = &(global->prefix_tree[index]);
        {
-	pthread_mutex_lock(&n->done.Mutex);
-	if (n->done.Flag == 0) {
-		pthread_cond_wait(&n->done.CondVar, &n->done.Mutex);
-	}
-};
-       {
-	n->done.Flag = 0;
-	pthread_mutex_unlock(&n->done.Mutex);}
+	{
+	
+	liblock_execute_operation(&n->done.Mutex, (void *)(uintptr_t)(n), &function20); }}
 ;
        if (offset != (level - 1)) {
          for (i = 0; i < radix; i++) {
@@ -623,10 +723,15 @@ void slave_sort()
        level >>= 1;
        if ((offset & 0x1) == 0) {
          {
-	pthread_mutex_lock(&global->prefix_tree[base + (offset >> 1)].done.Mutex);
-	global->prefix_tree[base + (offset >> 1)].done.Flag = 1;
-	pthread_cond_broadcast(&global->prefix_tree[base + (offset >> 1)].done.CondVar);
-	pthread_mutex_unlock(&global->prefix_tree[base + (offset >> 1)].done.Mutex);}
+	{ union instance26 instance26 = {
+	   {
+   	   offset,
+      	base,
+   	},
+	};
+	
+	liblock_execute_operation(&global->prefix_tree[base + (offset >> 1)].done.Mutex,
+                                  (void *)(uintptr_t)(&instance26), &function27); }}
 ;
        }
      }
@@ -654,14 +759,10 @@ void slave_sort()
        }
        their_node = &(global->prefix_tree[base + offset]);
        {
-	pthread_mutex_lock(&my_node->done.Mutex);
-	if (my_node->done.Flag == 0) {
-		pthread_cond_wait(&my_node->done.CondVar, &my_node->done.Mutex);
-	}
-};
-       {
-	my_node->done.Flag = 0;
-	pthread_mutex_unlock(&my_node->done.Mutex);}
+	{
+	
+	liblock_execute_operation(&my_node->done.Mutex, (void *)(uintptr_t)(my_node),
+                                  &function34); }}
 ;
        for (i = 0; i < radix; i++) {
          my_node->densities[i] = their_node->densities[i];
@@ -674,10 +775,15 @@ void slave_sort()
      base = 0;
      while ((offset & 0x1) != 0) {
        {
-	pthread_mutex_lock(&global->prefix_tree[base + offset - 1].done.Mutex);
-	global->prefix_tree[base + offset - 1].done.Flag = 1;
-	pthread_cond_broadcast(&global->prefix_tree[base + offset - 1].done.CondVar);
-	pthread_mutex_unlock(&global->prefix_tree[base + offset - 1].done.Mutex);}
+	{ union instance40 instance40 = {
+	   {
+   	   offset,
+      	base,
+   	},
+	};
+	
+	liblock_execute_operation(&global->prefix_tree[base + offset - 1].done.Mutex,
+                                  (void *)(uintptr_t)(&instance40), &function41); }}
 ;
        offset >>= 1;
        base += level;
@@ -803,7 +909,7 @@ double product_mod_46(double t1, double 
    t1 = t2 * RADIX_S + a2 * b2;
    t2 = (double)((long)(t1 / RADIX));
 
-   return (t1 - t2 * RADIX);    /* Return the product.  */
+   return( (t1 - t2 * RADIX));    /* Return the product.  */
 }
 
 /*
@@ -823,7 +929,7 @@ double ran_num_init(unsigned long k, dou
       k = j;
    }
 
-   return b;
+   return( b);
 }
 
 long get_max_digits(long max_key)
@@ -841,7 +947,7 @@ long get_max_digits(long max_key)
       temp ++;
     }
   }
-  return temp;
+  return( temp);
 }
 
 long get_log2_radix(long rad)
@@ -851,7 +957,7 @@ long get_log2_radix(long rad)
 
    for (out = 0; out < 20; out++) {
      if (cumulative == rad) {
-       return(out);
+       return((out));
      } else {
        cumulative = cumulative * 2;
      }
@@ -867,7 +973,7 @@ long get_log2_keys(long num_keys)
 
    for (out = 0; out < 30; out++) {
      if (cumulative == num_keys) {
-       return(out);
+       return((out));
      } else {
        cumulative = cumulative * 2;
      }
@@ -892,9 +998,9 @@ long log_2(long number)
   }
 
   if (cumulative == number) {
-    return(out);
+    return((out));
   } else {
-    return(-1);
+    return((-1));
   }
 }
 
